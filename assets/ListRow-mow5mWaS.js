const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/FontColor-BLTHJ7ns.js","assets/Popover-l9nGiES_.js","assets/vendor-THsbNae-.js","assets/_plugin-vue_export-helper-1tPrXgE0.js","assets/Button-BqBn1EJ9.js","assets/FeatherIcon-CihQTfNG.js","assets/Autocomplete-D0UzP5HY.js","assets/Avatar-BPyGJ0o7.js","assets/Badge-BdA8wsdO.js","assets/Breadcrumbs-DZzEegKU.js","assets/Dropdown-CDW2Yf0r.js","assets/Switch-DsWU8vHb.js","assets/useId-DJabvbK8.js","assets/plus-9cl4Avpw.js","assets/chevron-down-s4K2_tft.js","assets/Checkbox-DDtgv2Px.js","assets/DatePicker-BYDYZSXL.js","assets/TextInput-Du8e4_S5.js","assets/debounce-CRCtzhPg.js","assets/dayjs-B433mOaI.js","assets/DateRangePicker-BsM4vNnR.js","assets/TimePicker-BEFn46RH.js","assets/Calendar-B5WfCyZO.js","assets/TabButtons-ERL2igyK.js","assets/Dialog-C98vDs-Q.js","assets/FormControl-P8Z279Vs.js","assets/Select-BJ2wTcEA.js","assets/Textarea-BD_S-_rn.js","assets/ErrorMessage-BZEpav8U.js","assets/FileUploader-BAp3Mh7E.js","assets/Progress-epsaMPIa.js","assets/Rating-DzetqbhK.js","assets/Password-DfWANf_I.js","assets/Spinner-BiLlFsNg.js","assets/Tabs-DgKGHT-u.js","assets/CircularProgressBar-D5UNV7iz.js","assets/Tree-Cs4yHwq9.js","assets/Sidebar-piwXS255.js","assets/NumberChart-BUxAAQvR.js","assets/InsertLink-BgAo4EQb.js","assets/InsertImage-Df_MQcjt.js","assets/InsertVideo-kPXpE6eQ.js","assets/InsertIframe-v8LshaTo.js"])))=>i.map(i=>d[i]);
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
import { C as Checkbox } from "./Checkbox-DDtgv2Px.js";
import { az as ref, aW as computed, aX as useDebounceFn, aY as inject, aB as openBlock, aG as createElementBlock, aF as createBaseVNode, aZ as renderSlot, aS as normalizeProps, aT as guardReactiveProps, aN as toDisplayString, aR as normalizeClass, aL as mergeProps, aH as createCommentVNode, aC as createBlock, a_ as withModifiers, aK as Fragment, aJ as renderList, a$ as normalizeStyle, ay as defineComponent, aE as createVNode, aM as createTextVNode, aP as markRaw, b0 as nodeViewProps, b1 as onMounted, b2 as NodeViewWrapper, aD as withCtx, b3 as withDirectives, b4 as vModelText, b5 as Node, b6 as mergeAttributes, b7 as VueNodeViewRenderer, b8 as nodeInputRule, b9 as Plugin, ba as Selection, bb as watch, bc as readonly, bd as onUnmounted, be as useTemplateRef, bf as toRef, bg as Transition, bh as Teleport, bi as Extension, bj as PluginKey, bk as createApp, aQ as h, bl as nextTick, bm as withKeys, bn as Link$1, bo as getMarkRange, bp as tippy, bq as Mark, br as NodeViewContent, aA as resolveComponent, bs as vModelSelect, bt as VueRenderer, bu as Suggestion, bv as onBeforeUpdate, bw as toValue, bx as resolveDynamicComponent, by as vShow, aU as createStaticVNode, Z as defineAsyncComponent, _ as __vitePreload, bz as BubbleMenu, bA as FloatingMenu, bB as marked, bC as DOMParser$1, bD as Heading$1, bE as textblockTypeInputRule, aI as reactive, bF as createLowlight, bG as useAttrs, bH as Editor, bI as StarterKit, bJ as Table$2, bK as TaskList, bL as TaskItem, bM as TableRow, bN as TableHeader, bO as TableCell, bP as Typography, bQ as TextAlign, bR as TextStyle, bS as CodeBlockLowlight, bT as Placeholder, bU as onBeforeUnmount, bV as provide, bW as grammars, aV as EditorContent, bX as useSlots, bY as ToastAction_default, bZ as ToastClose_default, b_ as ToastDescription_default, b$ as ToastRoot_default, c0 as purify, c1 as lt, c2 as it, c3 as rt, c4 as ut, c5 as ye, c6 as Ge, c7 as je, c8 as createPopper, c9 as ToastProvider_default, ca as ToastViewport_default, cb as mergeModels, cc as useModel, cd as De, ce as ot, cf as set, cg as get, ch as setMany, ci as del, cj as keys, ck as createFetch } from "./vendor-THsbNae-.js";
import { A as Autocomplete } from "./Autocomplete-D0UzP5HY.js";
import "./Avatar-BPyGJ0o7.js";
import "./Badge-BdA8wsdO.js";
import "./Breadcrumbs-DZzEegKU.js";
import { L as LoadingIndicator, B as Button, _ as __unplugin_components_0$2 } from "./Button-BqBn1EJ9.js";
import { _ as _export_sfc } from "./_plugin-vue_export-helper-1tPrXgE0.js";
import { L as LucidePlus, a as LucideCheck } from "./plus-9cl4Avpw.js";
import "./DatePicker-BYDYZSXL.js";
import "./DateRangePicker-BsM4vNnR.js";
import { D as Dialog } from "./Calendar-B5WfCyZO.js";
import { L as LucideX, _ as __unplugin_components_1$1 } from "./Dialog-C98vDs-Q.js";
import "./Dropdown-CDW2Yf0r.js";
import { E as ErrorMessage } from "./ErrorMessage-BZEpav8U.js";
import { F as FeatherIcon } from "./FeatherIcon-CihQTfNG.js";
import "./FileUploader-BAp3Mh7E.js";
import { F as FormControl } from "./FormControl-P8Z279Vs.js";
import { d as debounce } from "./debounce-CRCtzhPg.js";
import "./Progress-epsaMPIa.js";
import { _ as __unplugin_components_1 } from "./Popover-l9nGiES_.js";
import "./Rating-DzetqbhK.js";
import { S as Select } from "./Select-BJ2wTcEA.js";
import "./Password-DfWANf_I.js";
import "./Spinner-BiLlFsNg.js";
import "./Switch-DsWU8vHb.js";
import { T as TabButtons } from "./TabButtons-ERL2igyK.js";
import "./Tabs-DgKGHT-u.js";
import { T as TextInput } from "./TextInput-Du8e4_S5.js";
import "./Textarea-BD_S-_rn.js";
import "./TimePicker-BEFn46RH.js";
import "./CircularProgressBar-D5UNV7iz.js";
import "./Tree-Cs4yHwq9.js";
import { a as LucideChevronRight, L as Link$2 } from "./Sidebar-piwXS255.js";
import "./NumberChart-BUxAAQvR.js";
import { g as getConfig } from "./dayjs-B433mOaI.js";
function getGridTemplateColumns(columns, withCheckbox = true) {
  let checkBoxWidth = withCheckbox ? "14px " : "";
  let columnsWidth = columns.map((col) => {
    let width = col.width || 1;
    if (typeof width === "number") {
      return width + "fr";
    }
    return width;
  }).join(" ");
  return checkBoxWidth + columnsWidth;
}
const alignmentMap = {
  left: "justify-start",
  start: "justify-start",
  center: "justify-center",
  middle: "justify-center",
  right: "justify-end",
  end: "justify-end"
};
const _sfc_main$1c = {
  __name: "ListHeaderItem",
  props: {
    item: {
      type: Object,
      required: true
    },
    debounce: {
      type: Number,
      default: 1e3
    }
  },
  emits: ["columnWidthUpdated"],
  setup(__props, { expose: __expose, emit: __emit }) {
    __expose();
    const props = __props;
    const emit = __emit;
    const resizer = ref(null);
    const columnRef = ref(null);
    const widthInPx = computed(() => {
      if (typeof props.item.width === "string") {
        const parsedWidth = parseInt(props.item.width);
        if (props.item.width.includes("rem")) {
          return parsedWidth * 16;
        } else if (props.item.width.includes("px")) {
          return parsedWidth;
        }
      }
      return columnRef.value.offsetWidth;
    });
    const startResizing = (e) => {
      const initialX = e.clientX;
      const initialWidth = widthInPx.value;
      const onMouseMove = (e2) => {
        document.body.classList.add("select-none");
        document.body.classList.add("cursor-col-resize");
        resizer.value.style.backgroundColor = "rgb(199 199 199)";
        let newWidth = initialWidth + (e2.clientX - initialX);
        props.item.width = `${newWidth < 50 ? 50 : newWidth}px`;
        updateWidth(props.item.width);
      };
      const onMouseUp = () => {
        document.body.classList.remove("select-none");
        document.body.classList.remove("cursor-col-resize");
        resizer.value.style.backgroundColor = "";
        window.removeEventListener("mousemove", onMouseMove);
        window.removeEventListener("mouseup", onMouseUp);
      };
      window.addEventListener("mousemove", onMouseMove);
      window.addEventListener("mouseup", onMouseUp);
    };
    const updateWidth = useDebounceFn((width) => {
      props.item.width = width;
      emit("columnWidthUpdated");
    }, props.debounce);
    const list = inject("list");
    const __returned__ = { props, emit, resizer, columnRef, widthInPx, startResizing, updateWidth, list, get alignmentMap() {
      return alignmentMap;
    }, get useDebounceFn() {
      return useDebounceFn;
    }, ref, computed, inject };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
};
const _hoisted_1$1c = { class: "truncate" };
const _hoisted_2$e = {
  ref: "resizer",
  class: "h-full w-[2px] rounded-full transition-all duration-300 ease-in-out group-hover:bg-gray-400"
};
function _sfc_render$Y(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(
    "div",
    {
      ref: "columnRef",
      class: normalizeClass(["group relative flex items-center", $props.item.align ? $setup.alignmentMap[$props.item.align] : "justify-between"])
    },
    [
      createBaseVNode(
        "div",
        {
          class: normalizeClass(["flex items-center space-x-2 truncate text-sm text-ink-gray-5", _ctx.$attrs.class])
        },
        [
          renderSlot(_ctx.$slots, "prefix", normalizeProps(guardReactiveProps({ item: $props.item }))),
          renderSlot(_ctx.$slots, "default", {}, () => [
            createBaseVNode(
              "div",
              _hoisted_1$1c,
              toDisplayString($props.item.label),
              1
              /* TEXT */
            )
          ]),
          renderSlot(_ctx.$slots, "suffix", normalizeProps(guardReactiveProps({ item: $props.item })))
        ],
        2
        /* CLASS */
      ),
      $setup.list.options.resizeColumn ? renderSlot(_ctx.$slots, "resizer", normalizeProps(mergeProps({ key: 0 }, { item: $props.item })), () => [
        createBaseVNode(
          "div",
          {
            class: "flex h-4 absolute -right-2 w-2 cursor-col-resize justify-center",
            onMousedown: $setup.startResizing
          },
          [
            createBaseVNode(
              "div",
              _hoisted_2$e,
              null,
              512
              /* NEED_PATCH */
            )
          ],
          32
          /* NEED_HYDRATION */
        )
      ]) : createCommentVNode("v-if", true)
    ],
    2
    /* CLASS */
  );
}
_sfc_main$1c.__file = "src/components/ListView/ListHeaderItem.vue";
const ListHeaderItem = /* @__PURE__ */ _export_sfc(_sfc_main$1c, [["render", _sfc_render$Y], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/ListView/ListHeaderItem.vue"]]);
const _sfc_main$1b = {
  __name: "ListHeader",
  emits: ["columnWidthUpdated"],
  setup(__props, { expose: __expose, emit: __emit }) {
    __expose();
    const emit = __emit;
    const list = inject("list");
    const __returned__ = { emit, list, Checkbox, ListHeaderItem, get getGridTemplateColumns() {
      return getGridTemplateColumns;
    }, inject };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
};
function _sfc_render$X(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(
    "div",
    {
      class: "mb-2 grid items-center space-x-4 rounded bg-surface-gray-2 p-2",
      style: normalizeStyle({
        gridTemplateColumns: $setup.getGridTemplateColumns(
          $setup.list.columns,
          $setup.list.options.selectable
        )
      })
    },
    [
      $setup.list.options.selectable ? (openBlock(), createBlock($setup["Checkbox"], {
        key: 0,
        class: "cursor-pointer duration-300",
        modelValue: $setup.list.allRowsSelected,
        onClick: withModifiers($setup.list.toggleAllRows, ["stop"])
      }, null, 8, ["modelValue", "onClick"])) : createCommentVNode("v-if", true),
      renderSlot(_ctx.$slots, "default", {}, () => [
        (openBlock(true), createElementBlock(
          Fragment,
          null,
          renderList($setup.list.columns, (column) => {
            return openBlock(), createBlock($setup["ListHeaderItem"], {
              key: column.key,
              item: column,
              onColumnWidthUpdated: ($event) => $setup.emit("columnWidthUpdated", column)
            }, null, 8, ["item", "onColumnWidthUpdated"]);
          }),
          128
          /* KEYED_FRAGMENT */
        ))
      ])
    ],
    4
    /* STYLE */
  );
}
_sfc_main$1b.__file = "src/components/ListView/ListHeader.vue";
const ListHeader = /* @__PURE__ */ _export_sfc(_sfc_main$1b, [["render", _sfc_render$X], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/ListView/ListHeader.vue"]]);
const _sfc_main$1a = /* @__PURE__ */ defineComponent({
  __name: "Alert",
  props: {
    title: { type: String, required: false },
    type: { type: String, required: false, default: "warning" }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const props = __props;
    const classes = computed(() => {
      return {
        warning: "text-ink-gray-7 bg-surface-blue-1"
      }[props.type];
    });
    const __returned__ = { props, classes };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
_sfc_main$1a.__file = "src/components/Alert/Alert.vue";
const _sfc_main$19 = {
  name: "Loading",
  props: {
    text: {
      type: String,
      default: "Loading..."
    }
  },
  components: {
    LoadingIndicator
  }
};
const _hoisted_1$1b = { class: "flex items-center text-base text-ink-gray-4" };
function _sfc_render$W(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_LoadingIndicator = LoadingIndicator;
  return openBlock(), createElementBlock("div", _hoisted_1$1b, [
    createVNode(_component_LoadingIndicator, { class: "-ml-1 mr-2 h-3 w-3" }),
    createTextVNode(
      " " + toDisplayString($props.text),
      1
      /* TEXT */
    )
  ]);
}
_sfc_main$19.__file = "src/components/LoadingText.vue";
const __unplugin_components_0$1 = /* @__PURE__ */ _export_sfc(_sfc_main$19, [["render", _sfc_render$W], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/LoadingText.vue"]]);
const _sfc_main$18 = {
  name: "Card",
  props: {
    title: {
      type: String
    },
    subtitle: {
      type: String
    },
    loading: {
      type: Boolean
    }
  },
  components: {
    LoadingText: __unplugin_components_0$1
  }
};
_sfc_main$18.__file = "src/components/Card.vue";
const _sfc_main$17 = {
  name: "ConfirmDialog",
  props: {
    title: {
      type: String
    },
    message: {
      type: String
    },
    onConfirm: {
      type: Function,
      default: null
    },
    onCancel: {
      type: Function,
      default: null
    }
  },
  expose: ["show", "hide"],
  components: {
    Dialog,
    Button
  },
  data() {
    return {
      showDialog: true,
      isLoading: false
    };
  },
  methods: {
    handleConfirmation() {
      var _a;
      try {
        (_a = this.onConfirm) == null ? void 0 : _a.call(this, {
          hideDialog: this.hide
        });
      } finally {
        this.isLoading = false;
      }
    },
    show() {
      this.showDialog = true;
    },
    closeDialog() {
      var _a;
      this.hide();
      (_a = this.onCancel) == null ? void 0 : _a.call(this);
    },
    hide() {
      this.showDialog = false;
    }
  },
  computed: {
    primaryActionProps() {
      return {
        label: "Confirm",
        variant: "solid",
        loading: this.isLoading,
        onClick: this.handleConfirmation
      };
    }
  }
};
_sfc_main$17.__file = "src/components/ConfirmDialog.vue";
const dialogs = ref([]);
const _sfc_main$16 = {
  __name: "Dialogs",
  setup(__props, { expose: __expose }) {
    __expose();
    const __returned__ = { get dialogs() {
      return dialogs;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
};
_sfc_main$16.__file = "src/components/Dialogs.vue";
const _sfc_main$15 = /* @__PURE__ */ defineComponent({
  __name: "Divider",
  props: {
    orientation: { type: String, required: false, default: "horizontal" },
    position: { type: String, required: false, default: "center" },
    flexItem: { type: Boolean, required: false },
    action: { type: Object, required: false }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const props = __props;
    const alignmentClasses = computed(() => {
      let spacerDimensionClasses = {
        horizontal: "border-t-[1px] w-full",
        vertical: "border-l-[1px]"
      }[props.orientation];
      let flexClasses = props.flexItem ? "self-stretch h-auto" : "h-full";
      return [spacerDimensionClasses, flexClasses];
    });
    const actionAlignmentClasses = computed(() => {
      return {
        horizontal: {
          center: "left-1/2 top-0 -translate-y-2/4 -translate-x-1/2",
          start: "left-0 top-0 -translate-y-2/4 ml-4",
          end: "right-0 -translate-y-2/4 mr-4"
        },
        vertical: {
          center: "-translate-x-2/4 top-1/2 left-0 -translate-y-1/2",
          start: "-translate-x-2/4 top-0 mt-4 left-0",
          end: "-translate-x-2/4 bottom-0 mb-4 left-0"
        }
      }[props.orientation][props.position];
    });
    const __returned__ = { props, alignmentClasses, actionAlignmentClasses, get Button() {
      return Button;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
_sfc_main$15.__file = "src/components/Divider/Divider.vue";
const _sfc_main$14 = {};
_sfc_main$14.__file = "src/components/GreenCheckIcon.vue";
const _sfc_main$13 = {
  name: "Input",
  inheritAttrs: false,
  expose: ["getInputValue"],
  components: { FeatherIcon },
  props: {
    label: {
      type: String
    },
    type: {
      type: String,
      default: "text",
      validator(value) {
        let isValid = [
          "text",
          "number",
          "checkbox",
          "textarea",
          "select",
          "email",
          "password",
          "date"
        ].includes(value);
        if (!isValid) {
          console.warn(`Invalid value "${value}" for "type" prop for Input`);
        }
        return isValid;
      }
    },
    modelValue: {
      type: [String, Number, Boolean, Object, Array]
    },
    inputClass: {
      type: [String, Array, Object]
    },
    debounce: {
      type: Number
    },
    options: {
      type: Array
    },
    disabled: {
      type: Boolean
    },
    rows: {
      type: Number,
      default: 3
    },
    placeholder: {
      type: String
    },
    iconLeft: {
      type: String
    }
  },
  emits: ["input", "change", "update:modelValue"],
  methods: {
    focus() {
      this.$refs.input.focus();
    },
    blur() {
      this.$refs.input.blur();
    },
    getInputValue(e) {
      let $input = e ? e.target : this.$refs.input;
      let value = $input.value;
      if (this.type == "checkbox") {
        value = $input.checked;
      }
      return value;
    }
  },
  computed: {
    passedInputValue() {
      if ("value" in this.$attrs) {
        return this.$attrs.value;
      }
      return this.modelValue || null;
    },
    inputAttributes() {
      let attrs = {};
      let onInput = (e) => {
        this.$emit("input", this.getInputValue(e));
      };
      if (this.debounce) {
        onInput = debounce(onInput, this.debounce);
      }
      if (this.type == "checkbox") {
        attrs.checked = this.passedInputValue;
      }
      return Object.assign(attrs, this.$attrs, {
        onInput,
        onChange: (e) => {
          this.$emit("change", this.getInputValue(e));
          this.$emit("update:modelValue", this.getInputValue(e));
        }
      });
    },
    selectOptions() {
      return this.options.map((option) => {
        if (typeof option === "string") {
          return {
            label: option,
            value: option
          };
        }
        return option;
      }).filter(Boolean);
    },
    isNormalInput() {
      return [
        "text",
        "number",
        "checkbox",
        "email",
        "password",
        "date"
      ].includes(this.type);
    }
  }
};
_sfc_main$13.__file = "src/components/Input.vue";
const _sfc_main$12 = {
  props: ["to"],
  computed: {
    attributes() {
      return {
        ...this.$attrs,
        target: this.isExternal ? "_blank" : null,
        to: !this.isExternal ? this.to : void 0,
        href: this.isExternal ? this.to : void 0
      };
    },
    isExternal() {
      return this.to.startsWith("http");
    }
  }
};
_sfc_main$12.__file = "src/components/Link.vue";
const _sfc_main$11 = {
  name: "ListItem",
  props: ["title", "subtitle"],
  computed: {
    secondaryText() {
      let text = this.subtitle || "";
      return text.replace("\n", "<br>");
    }
  }
};
_sfc_main$11.__file = "src/components/ListItem.vue";
const _sfc_main$10 = {
  name: "Resource",
  props: ["options"],
  resources: {
    resource() {
      return this.options;
    }
  },
  render() {
    return this.$slots.default({
      resource: this.$resources.resource,
      data: this.$resources.resource.data,
      error: this.$resources.resource.error,
      loading: this.$resources.resource.loading,
      fetch: (params) => this.$resources.resource.fetch(params),
      submit: (params) => this.$resources.resource.submit(params)
    });
  }
};
_sfc_main$10.__file = "src/components/Resource.vue";
const _hoisted_1$1a = {
  class: "lucide lucide-move-diagonal-2",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function render$n(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1a, _cache[0] || (_cache[0] = [
    createBaseVNode(
      "path",
      { d: "M19 13v6h-6" },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      { d: "M5 11V5h6" },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      { d: "m5 5 14 14" },
      null,
      -1
      /* HOISTED */
    )
  ]));
}
const LucideMoveDiagonal2 = markRaw({ name: "lucide-move-diagonal-2", render: render$n });
const _hoisted_1$19 = {
  class: "lucide lucide-align-left",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function render$m(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$19, _cache[0] || (_cache[0] = [
    createBaseVNode(
      "path",
      { d: "M15 12H3" },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      { d: "M17 18H3" },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      { d: "M21 6H3" },
      null,
      -1
      /* HOISTED */
    )
  ]));
}
const LucideAlignLeft = markRaw({ name: "lucide-align-left", render: render$m });
const _hoisted_1$18 = {
  class: "lucide lucide-align-center",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function render$l(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$18, _cache[0] || (_cache[0] = [
    createBaseVNode(
      "path",
      { d: "M17 12H7" },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      { d: "M19 18H5" },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      { d: "M21 6H3" },
      null,
      -1
      /* HOISTED */
    )
  ]));
}
const LucideAlignCenter = markRaw({ name: "lucide-align-center", render: render$l });
const _hoisted_1$17 = {
  class: "lucide lucide-align-right",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function render$k(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$17, _cache[0] || (_cache[0] = [
    createBaseVNode(
      "path",
      { d: "M21 12H9" },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      { d: "M21 18H7" },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      { d: "M21 6H3" },
      null,
      -1
      /* HOISTED */
    )
  ]));
}
const LucideAlignRight = markRaw({ name: "lucide-align-right", render: render$k });
const _sfc_main$$ = /* @__PURE__ */ defineComponent({
  __name: "ImageNodeView",
  props: nodeViewProps,
  setup(__props, { expose: __expose }) {
    __expose();
    const props = __props;
    const imageRef = ref(null);
    const containerRef = ref(null);
    const isResizing = ref(false);
    const startDragX = ref(0);
    const startWidth = ref(0);
    const originalAspectRatio = ref(1);
    function selectImage() {
      props.editor.commands.setNodeSelection(props.getPos());
    }
    const caption = ref(props.node.attrs.alt || "");
    const isEditable = ref(false);
    onMounted(() => {
      isEditable.value = props.editor.isEditable;
      if (imageRef.value) {
        const initialWidth = props.node.attrs.width || imageRef.value.naturalWidth;
        const initialHeight = props.node.attrs.height || imageRef.value.naturalHeight;
        if (initialWidth && initialHeight) {
          originalAspectRatio.value = initialHeight / initialWidth;
        }
      }
    });
    props.editor.on("update", () => {
      isEditable.value = props.editor.isEditable;
    });
    function updateCaption(event) {
      const newCaption = event.target.value;
      caption.value = newCaption;
      props.updateAttributes({ alt: newCaption });
    }
    function handleKeydown(event) {
      if (event.key === "Enter") {
        event.preventDefault();
        createParagraphAfterImage();
      } else if (event.key === "Escape" || event.key === "ArrowDown") {
        event.preventDefault();
        setCursorAfterImage();
      }
      if (event.key === "ArrowUp") {
        event.preventDefault();
        setCursorBeforeImage();
      }
    }
    function setCursorAt(pos) {
      props.editor.commands.focus();
      props.editor.chain().setTextSelection(pos).scrollIntoView().run();
    }
    function createParagraphAfterImage() {
      const pos = props.getPos();
      props.editor.commands.focus();
      props.editor.chain().setTextSelection(pos + 1).createParagraphNear().scrollIntoView().run();
    }
    function setCursorAfterImage() {
      const pos = props.getPos();
      setCursorAt(pos + 1);
    }
    function setCursorBeforeImage() {
      const pos = props.getPos();
      setCursorAt(pos - 1);
    }
    function startResize(event) {
      var _a, _b, _c;
      if (!isEditable.value) return;
      selectImage();
      isResizing.value = true;
      startDragX.value = event.clientX;
      startWidth.value = ((_a = imageRef.value) == null ? void 0 : _a.offsetWidth) || props.node.attrs.width || 0;
      const width = props.node.attrs.width || ((_b = imageRef.value) == null ? void 0 : _b.naturalWidth);
      const height = props.node.attrs.height || ((_c = imageRef.value) == null ? void 0 : _c.naturalHeight);
      if (width && height) {
        originalAspectRatio.value = height / width;
      } else {
        originalAspectRatio.value = 1;
      }
      window.addEventListener("mousemove", handleResize);
      window.addEventListener("mouseup", stopResize);
      document.body.style.cursor = "ew-resize";
    }
    function handleResize(event) {
      if (!isResizing.value || !imageRef.value || !containerRef.value) return;
      const editorElement = props.editor.view.dom;
      const editorWidth = editorElement.clientWidth;
      const deltaX = event.clientX - startDragX.value;
      let newWidth = startWidth.value + deltaX;
      newWidth = Math.max(50, Math.min(newWidth, editorWidth));
      const newHeight = newWidth * originalAspectRatio.value;
      imageRef.value.style.width = `${newWidth}px`;
      imageRef.value.style.height = `${newHeight}px`;
      containerRef.value.style.width = `${newWidth}px`;
    }
    function stopResize() {
      if (!isResizing.value) return;
      isResizing.value = false;
      window.removeEventListener("mousemove", handleResize);
      window.removeEventListener("mouseup", stopResize);
      document.body.style.cursor = "";
      if (imageRef.value && containerRef.value) {
        const finalWidth = imageRef.value.offsetWidth;
        const finalHeight = imageRef.value.offsetHeight;
        props.updateAttributes({ width: finalWidth, height: finalHeight });
        imageRef.value.style.width = "";
        imageRef.value.style.height = "";
        containerRef.value.style.width = "";
      }
    }
    function setAlignment(align) {
      props.editor.commands.setImageAlign(align);
    }
    const __returned__ = { props, imageRef, containerRef, isResizing, startDragX, startWidth, originalAspectRatio, selectImage, caption, isEditable, updateCaption, handleKeydown, setCursorAt, createParagraphAfterImage, setCursorAfterImage, setCursorBeforeImage, startResize, handleResize, stopResize, setAlignment, get NodeViewWrapper() {
      return NodeViewWrapper;
    }, LoadingIndicator, get ErrorMessage() {
      return ErrorMessage;
    }, get LucideMoveDiagonal2() {
      return LucideMoveDiagonal2;
    }, get LucideAlignLeft() {
      return LucideAlignLeft;
    }, get LucideAlignCenter() {
      return LucideAlignCenter;
    }, get LucideAlignRight() {
      return LucideAlignRight;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$16 = { class: "relative" };
const _hoisted_2$d = ["src", "alt", "width", "height"];
const _hoisted_3$9 = { class: "absolute bottom-2 right-2 flex items-center gap-2" };
const _hoisted_4$6 = {
  key: 0,
  class: "flex divide-x divide-outline-gray-5 rounded bg-black/65"
};
const _hoisted_5$6 = {
  key: 1,
  class: "inset-0 absolute flex items-center justify-center z-10"
};
const _hoisted_6$5 = { class: "bg-gray-900/80 p-2 inset-0 leading-none rounded-sm flex flex-col items-center justify-center gap-2" };
const _hoisted_7$4 = { class: "flex items-center gap-2" };
const _hoisted_8$3 = ["disabled"];
const _hoisted_9$2 = {
  key: 1,
  class: "w-full py-1.5"
};
function _sfc_render$V(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock($setup["NodeViewWrapper"], null, {
    default: withCtx(() => [
      createBaseVNode(
        "div",
        {
          ref: "containerRef",
          class: normalizeClass(["relative overflow-hidden not-prose my-6 rounded-[2px] block max-w-full", [
            { "ring-2 ring-outline-gray-3 ring-offset-2": _ctx.selected },
            _ctx.node.attrs.align === "center" ? "mx-auto" : "",
            _ctx.node.attrs.align === "right" ? "ml-auto mr-0" : "",
            _ctx.node.attrs.align === "left" ? "mr-auto ml-0" : ""
          ]]),
          style: normalizeStyle({ width: _ctx.node.attrs.width ? `${_ctx.node.attrs.width}px` : "auto" })
        },
        [
          createBaseVNode("div", _hoisted_1$16, [
            _ctx.node.attrs.src ? (openBlock(), createElementBlock("img", {
              key: 0,
              ref: "imageRef",
              class: "rounded-[2px]",
              src: _ctx.node.attrs.src,
              alt: _ctx.node.attrs.alt || "",
              width: _ctx.node.attrs.width,
              height: _ctx.node.attrs.height,
              onClick: withModifiers($setup.selectImage, ["stop"])
            }, null, 8, _hoisted_2$d)) : createCommentVNode("v-if", true),
            createBaseVNode("div", _hoisted_3$9, [
              createCommentVNode(" Alignment Controls "),
              _ctx.selected && $setup.isEditable ? (openBlock(), createElementBlock("div", _hoisted_4$6, [
                createBaseVNode(
                  "button",
                  {
                    onClick: _cache[0] || (_cache[0] = withModifiers(($event) => $setup.setAlignment("left"), ["stop"])),
                    class: normalizeClass([
                      "px-1.5 py-1 hover:text-ink-white",
                      _ctx.node.attrs.align === "left" ? "text-ink-white" : "text-ink-gray-4"
                    ])
                  },
                  [
                    createVNode($setup["LucideAlignLeft"], { class: "size-4" })
                  ],
                  2
                  /* CLASS */
                ),
                createBaseVNode(
                  "button",
                  {
                    onClick: _cache[1] || (_cache[1] = withModifiers(($event) => $setup.setAlignment("center"), ["stop"])),
                    class: normalizeClass([
                      "px-1.5 py-1 hover:text-ink-white",
                      _ctx.node.attrs.align === "center" ? "text-ink-white" : "text-ink-gray-4"
                    ])
                  },
                  [
                    createVNode($setup["LucideAlignCenter"], { class: "size-4" })
                  ],
                  2
                  /* CLASS */
                ),
                createBaseVNode(
                  "button",
                  {
                    onClick: _cache[2] || (_cache[2] = withModifiers(($event) => $setup.setAlignment("right"), ["stop"])),
                    class: normalizeClass([
                      "px-1.5 py-1 hover:text-ink-white",
                      _ctx.node.attrs.align === "right" ? "text-ink-white" : "text-ink-gray-4"
                    ])
                  },
                  [
                    createVNode($setup["LucideAlignRight"], { class: "size-4" })
                  ],
                  2
                  /* CLASS */
                )
              ])) : createCommentVNode("v-if", true),
              createCommentVNode(" Resize Handle "),
              _ctx.selected && $setup.isEditable ? (openBlock(), createElementBlock(
                "button",
                {
                  key: 1,
                  class: "cursor-nw-resize bg-black/65 rounded p-1",
                  onMousedown: withModifiers($setup.startResize, ["prevent"])
                },
                [
                  createVNode($setup["LucideMoveDiagonal2"], { class: "text-white size-4" })
                ],
                32
                /* NEED_HYDRATION */
              )) : createCommentVNode("v-if", true)
            ]),
            createCommentVNode(" Loading indicator overlay "),
            _ctx.node.attrs.loading ? (openBlock(), createElementBlock("div", _hoisted_5$6, [
              createBaseVNode("div", _hoisted_6$5, [
                createBaseVNode("div", _hoisted_7$4, [
                  createVNode($setup["LoadingIndicator"], { class: "text-gray-100 size-4" }),
                  _cache[4] || (_cache[4] = createBaseVNode(
                    "span",
                    { class: "text-gray-100" },
                    "Uploading...",
                    -1
                    /* HOISTED */
                  ))
                ])
              ])
            ])) : createCommentVNode("v-if", true)
          ]),
          ($setup.isEditable || _ctx.node.attrs.alt) && !_ctx.node.attrs.error ? withDirectives((openBlock(), createElementBlock("input", {
            key: 0,
            "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => $setup.caption = $event),
            class: "w-full text-center bg-transparent text-sm text-ink-gray-6 h-7 border-none focus:ring-0 placeholder-ink-gray-4",
            placeholder: "Add caption",
            disabled: !$setup.isEditable,
            onChange: $setup.updateCaption,
            onKeydown: $setup.handleKeydown
          }, null, 40, _hoisted_8$3)), [
            [vModelText, $setup.caption]
          ]) : createCommentVNode("v-if", true),
          _ctx.node.attrs.error ? (openBlock(), createElementBlock("div", _hoisted_9$2, [
            createVNode($setup["ErrorMessage"], {
              message: `Upload Failed: ${_ctx.node.attrs.error}`
            }, null, 8, ["message"])
          ])) : createCommentVNode("v-if", true)
        ],
        6
        /* CLASS, STYLE */
      )
    ]),
    _: 1
    /* STABLE */
  });
}
_sfc_main$$.__file = "src/components/TextEditor/extensions/image/ImageNodeView.vue";
const ImageNodeView = /* @__PURE__ */ _export_sfc(_sfc_main$$, [["render", _sfc_render$V], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/TextEditor/extensions/image/ImageNodeView.vue"]]);
const inputRegex = /(?:^|\s)(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/;
const ImageExtension = Node.create({
  name: "image",
  group: "block",
  draggable: true,
  selectable: true,
  addAttributes() {
    return {
      src: { default: null },
      alt: { default: null },
      title: { default: null },
      width: { default: null },
      height: { default: null },
      loading: {
        default: false,
        parseHTML: () => false
      },
      align: {
        default: "left",
        parseHTML: (element) => {
          const align = (element.getAttribute("data-align") || element.getAttribute("align") || "left").toLowerCase();
          if (["left", "center", "right"].includes(align)) {
            return align;
          }
          return "left";
        },
        renderHTML: (attributes) => {
          return {
            "data-align": attributes.align || "left"
          };
        }
      },
      uploadId: {
        default: null,
        parseHTML: () => null
      },
      error: {
        default: null,
        parseHTML: () => null
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "img[src]",
        getAttrs: (node) => {
          if (typeof node === "string") return {};
          const element = node;
          return {
            src: element.getAttribute("src"),
            alt: element.getAttribute("alt"),
            title: element.getAttribute("title"),
            width: element.getAttribute("width"),
            height: element.getAttribute("height")
          };
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return [
      "img",
      mergeAttributes(this.options.HTMLAttributes || {}, HTMLAttributes)
    ];
  },
  addNodeView() {
    return VueNodeViewRenderer(ImageNodeView);
  },
  addOptions() {
    return {
      uploadFunction: null,
      HTMLAttributes: {}
    };
  },
  addCommands() {
    return {
      setImageAlign: (align) => ({ commands: commands2 }) => {
        return commands2.updateAttributes(this.name, { align });
      },
      setImage: (attributes) => ({ commands: commands2, editor }) => {
        const result = commands2.insertContent({
          type: this.name,
          attrs: attributes
        });
        if (result && attributes.src) {
          findImageNodeBySource(editor.view, attributes.src, (node, pos) => {
            updateNodeWithDimensions(attributes.src, editor.view, pos);
          });
        }
        return result;
      },
      uploadImage: (file) => ({ editor }) => {
        return uploadImage(file, editor.view, null, this.options);
      },
      selectAndUploadImage: () => ({ editor }) => {
        const input = document.createElement("input");
        input.type = "file";
        input.accept = "image/*";
        input.onchange = (event) => {
          const target = event.target;
          if (target.files && target.files.length) {
            const file = target.files[0];
            editor.commands.uploadImage(file);
          }
        };
        input.click();
        return true;
      }
    };
  },
  addInputRules() {
    return [
      nodeInputRule({
        find: inputRegex,
        type: this.type,
        getAttributes: (match) => {
          const [, , alt, src, title] = match;
          return { src, alt, title };
        }
      })
    ];
  },
  addProseMirrorPlugins() {
    const extensionThis = this;
    return [
      new Plugin({
        props: {
          handleDOMEvents: {
            drop: (view, event) => {
              var _a, _b;
              const hasFiles = (_b = (_a = event.dataTransfer) == null ? void 0 : _a.files) == null ? void 0 : _b.length;
              if (!hasFiles || !extensionThis.options.uploadFunction) {
                return false;
              }
              const images = Array.from(event.dataTransfer.files).filter(
                (file) => /image/i.test(file.type)
              );
              if (images.length === 0) {
                return false;
              }
              event.preventDefault();
              const coordinates = view.posAtCoords({
                left: event.clientX,
                top: event.clientY
              });
              let pos = null;
              if (coordinates) {
                pos = coordinates.pos;
                const transaction = view.state.tr.setSelection(
                  Selection.near(view.state.doc.resolve(pos))
                );
                view.dispatch(transaction);
              }
              processMultipleImages(images, view, pos, extensionThis.options);
              return true;
            },
            handlePaste: (view, event) => {
              var _a;
              if (!extensionThis.options.uploadFunction) {
                return false;
              }
              const clipboardItems = (_a = event.clipboardData) == null ? void 0 : _a.items;
              if (!clipboardItems || clipboardItems.length === 0) {
                return false;
              }
              const images = [];
              for (let i = 0; i < clipboardItems.length; i++) {
                const item = clipboardItems[i];
                if (item.kind === "file" && item.type.indexOf("image/") !== -1) {
                  const file = item.getAsFile();
                  if (file) {
                    images.push(file);
                  }
                }
              }
              if (images.length === 0) {
                return false;
              }
              event.preventDefault();
              processMultipleImages(images, view, null, extensionThis.options);
              return true;
            }
          }
        },
        appendTransaction(transactions, oldState, newState) {
          const newImageNodes = [];
          if (transactions.some((tr) => tr.docChanged)) {
            newState.doc.descendants((node, pos) => {
              if (node.type.name === "image" && node.attrs.src && (!node.attrs.width || !node.attrs.height) && !node.attrs.loading) {
                newImageNodes.push({ node, pos });
              }
            });
          }
          if (newImageNodes.length === 0) return null;
          newImageNodes.forEach(({ node, pos }) => {
            const editor = extensionThis.editor;
            if (editor) {
              updateNodeWithDimensions(node.attrs.src, editor.view, pos);
            }
          });
          return null;
        }
      })
    ];
  }
});
function findInsertPosition(view, lastNodeId) {
  if (!lastNodeId) {
    return null;
  }
  let insertPos = null;
  view.state.doc.descendants((node, pos) => {
    if (node.type.name === "image" && node.attrs.uploadId === lastNodeId) {
      insertPos = pos + node.nodeSize;
      return false;
    }
  });
  return insertPos;
}
function uploadImageBase(file, view, pos, options, insertMode, onComplete, moveCursor = false) {
  if (!options.uploadFunction) {
    console.error("uploadFunction option is not provided");
    return false;
  }
  const uploadId = `upload-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
  fileToBase64(file).then((base64Result) => {
    const node = view.state.schema.nodes.image.create({
      loading: true,
      uploadId,
      src: base64Result
    });
    const tr = view.state.tr;
    if (pos != null) {
      tr.insert(pos, node);
    } else if (insertMode === "replace") {
      tr.replaceSelectionWith(node);
    } else {
      const insertPos = view.state.selection.from;
      tr.insert(insertPos, node);
    }
    view.dispatch(tr);
    if (moveCursor) {
      const nodeSize = node.nodeSize || 1;
      setTimeout(() => {
        try {
          let nodePos = null;
          view.state.doc.descendants((n, p) => {
            if (n.type.name === "image" && n.attrs.uploadId === uploadId) {
              nodePos = p;
              return false;
            }
          });
          if (nodePos !== null) {
            const posAfter = nodePos + nodeSize;
            const transaction = view.state.tr.setSelection(
              Selection.near(view.state.doc.resolve(posAfter))
            );
            view.dispatch(transaction);
          }
        } catch (e) {
          console.error("Error moving cursor:", e);
        }
      }, 10);
    }
    return options.uploadFunction(file);
  }).then((uploadedImage) => {
    return getImageDimensions(uploadedImage.file_url).then((dimensions) => {
      return {
        ...uploadedImage,
        width: dimensions.width,
        height: dimensions.height
      };
    }).catch(() => {
      return uploadedImage;
    });
  }).then((uploadedImage) => {
    const transaction = view.state.tr;
    view.state.doc.descendants((node, pos2) => {
      if (node.type.name === "image" && node.attrs.uploadId === uploadId) {
        transaction.setNodeMarkup(pos2, void 0, {
          ...node.attrs,
          src: uploadedImage.file_url,
          width: uploadedImage.width || node.attrs.width,
          height: uploadedImage.height || node.attrs.height,
          loading: false
        });
        return false;
      }
    });
    view.dispatch(transaction);
    if (onComplete) onComplete(uploadId);
  }).catch((error) => {
    console.error("Image upload failed:", error);
    try {
      const transaction = view.state.tr;
      view.state.doc.descendants((node, pos2) => {
        if (node.type.name === "image" && node.attrs.uploadId === uploadId) {
          transaction.setNodeMarkup(pos2, void 0, {
            ...node.attrs,
            loading: false,
            error: error.message || "Failed to upload image"
          });
          return false;
        }
      });
      view.dispatch(transaction);
    } catch (e) {
      console.error("Error updating failed node:", e);
    }
    if (onComplete) onComplete(uploadId);
  });
  return true;
}
function uploadImageWithTracking(file, view, pos, options, onComplete) {
  return uploadImageBase(file, view, pos, options, "insert", onComplete, true);
}
function uploadImage(file, view, pos, options) {
  return uploadImageBase(file, view, pos, options, "replace");
}
function findImageNodeBySource(view, src, callback) {
  view.state.doc.descendants((node, pos) => {
    if (node.type.name === "image" && node.attrs.src === src) {
      callback(node, pos);
      return false;
    }
  });
}
function updateNodeWithDimensions(src, view, pos) {
  getImageDimensions(src).then((dimensions) => {
    const node = view.state.doc.nodeAt(pos);
    if (!node || node.type.name !== "image") {
      return;
    }
    const currentAttrs = node.attrs;
    if (currentAttrs.width == null || currentAttrs.height == null) {
      const transaction = view.state.tr.setNodeMarkup(pos, void 0, {
        ...currentAttrs,
        width: currentAttrs.width ?? dimensions.width,
        height: currentAttrs.height ?? dimensions.height
      });
      view.dispatch(transaction);
    }
  }).catch((error) => {
  });
}
function getImageDimensions(src) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => resolve({
      width: img.naturalWidth,
      height: img.naturalHeight
    });
    img.onerror = reject;
    img.src = src;
  });
}
function processMultipleImages(images, view, pos, options) {
  if (images.length === 1) {
    uploadImage(images[0], view, pos, options);
    return;
  }
  let imageQueue = [...images];
  let lastInsertedNodeId = null;
  const processNextImage = () => {
    if (imageQueue.length === 0) return;
    const file = imageQueue.shift();
    if (!file) return;
    const currentPos = lastInsertedNodeId ? findInsertPosition(view, lastInsertedNodeId) : pos;
    uploadImageWithTracking(file, view, currentPos, options, (newNodeId) => {
      lastInsertedNodeId = newNodeId;
      setTimeout(processNextImage, 100);
    });
  };
  processNextImage();
}
function useTouchHandler(options) {
  const {
    targetRef,
    zoomLevel = ref(100),
    onSwipeLeft,
    onSwipeRight,
    onDoubleTap,
    onTap,
    onPanStart,
    onPanMove,
    onPanAnimate,
    onPanEnd,
    onPinchStart,
    onPinchMove,
    onPinchEnd,
    doubleTapDelay = 300,
    minSwipeDistance = 50,
    maxVerticalSwipeDistance = 75,
    maxTapDuration = 200,
    maxTapMovement = 10,
    panThreshold = 5,
    // Pixels moved before pan starts
    inertiaDamping = 0.94,
    // Damping for inertia slowdown (higher = slower stop)
    inertiaVelocityThreshold = 0.5
    // Pixels per ms
  } = options;
  const isPanning = ref(false);
  const isPinching = ref(false);
  const isAnimatingPan = ref(false);
  const startPanCoords = ref({ x: 0, y: 0 });
  const lastTapTime = ref(0);
  const touchStartTime = ref(0);
  const touchStartDistance = ref(0);
  const initialTouchPoints = ref(null);
  const lastMoveTime = ref(0);
  const lastMoveCoords = ref({ x: 0, y: 0 });
  const panVelocity = ref({ x: 0, y: 0 });
  const animationFrameId = ref(null);
  const cancelInertiaAnimation = () => {
    if (animationFrameId.value !== null) {
      cancelAnimationFrame(animationFrameId.value);
      animationFrameId.value = null;
    }
    isAnimatingPan.value = false;
    panVelocity.value = { x: 0, y: 0 };
  };
  const handleTouchStart = (event) => {
    cancelInertiaAnimation();
    event.preventDefault();
    isPanning.value = false;
    isPinching.value = false;
    initialTouchPoints.value = event.touches;
    const currentTime = performance.now();
    const timeSinceLastTap = currentTime - lastTapTime.value;
    if (timeSinceLastTap < doubleTapDelay && timeSinceLastTap > 0 && event.touches.length === 1 && onDoubleTap) {
      onDoubleTap(event);
      lastTapTime.value = 0;
      touchStartTime.value = 0;
      return;
    }
    touchStartTime.value = currentTime;
    if (event.touches.length === 1) {
      lastTapTime.value = currentTime;
      const touch = event.touches[0];
      startPanCoords.value = { x: touch.clientX, y: touch.clientY };
      lastMoveTime.value = currentTime;
      lastMoveCoords.value = { ...startPanCoords.value };
      panVelocity.value = { x: 0, y: 0 };
      if (onPanStart) onPanStart(event);
    } else if (event.touches.length === 2) {
      lastTapTime.value = 0;
      const touch1 = event.touches[0];
      const touch2 = event.touches[1];
      touchStartDistance.value = Math.hypot(
        touch2.clientX - touch1.clientX,
        touch2.clientY - touch1.clientY
      );
      isPinching.value = true;
      if (onPinchStart) onPinchStart(event);
    } else {
      lastTapTime.value = 0;
      touchStartTime.value = 0;
    }
  };
  const handleTouchMove = (event) => {
    if (!initialTouchPoints.value) return;
    event.preventDefault();
    const currentTime = performance.now();
    const deltaTime = currentTime - lastMoveTime.value;
    if (event.touches.length === 2 && initialTouchPoints.value.length === 2) {
      isPanning.value = false;
      isPinching.value = true;
      const touch1 = event.touches[0];
      const touch2 = event.touches[1];
      const currentDistance = Math.hypot(
        touch2.clientX - touch1.clientX,
        touch2.clientY - touch1.clientY
      );
      if (touchStartDistance.value > 0 && onPinchMove) {
        const scale = currentDistance / touchStartDistance.value;
        onPinchMove(scale, event);
      }
      panVelocity.value = { x: 0, y: 0 };
    } else if (event.touches.length === 1 && initialTouchPoints.value.length === 1 && !isPinching.value) {
      const currentX = event.touches[0].clientX;
      const currentY = event.touches[0].clientY;
      const rawDeltaX = currentX - lastMoveCoords.value.x;
      const rawDeltaY = currentY - lastMoveCoords.value.y;
      if (deltaTime > 1) {
        panVelocity.value = {
          x: rawDeltaX / deltaTime,
          y: rawDeltaY / deltaTime
        };
      } else {
        panVelocity.value = { x: 0, y: 0 };
      }
      lastMoveTime.value = currentTime;
      lastMoveCoords.value = { x: currentX, y: currentY };
      const deltaXFromStart = currentX - startPanCoords.value.x;
      const deltaYFromStart = currentY - startPanCoords.value.y;
      if (!isPanning.value && zoomLevel.value > 100 && (Math.abs(deltaXFromStart) > panThreshold || Math.abs(deltaYFromStart) > panThreshold)) {
        isPanning.value = true;
        startPanCoords.value = {
          x: currentX,
          y: currentY
        };
      }
      if (isPanning.value && onPanMove) {
        const zoomFactor = zoomLevel.value / 100;
        const panDeltaX = deltaXFromStart / zoomFactor;
        const panDeltaY = deltaYFromStart / zoomFactor;
        onPanMove(panDeltaX, panDeltaY, event);
      }
    }
  };
  const handleTouchEnd = (event) => {
    var _a;
    const touchesLeft = event.touches.length;
    const touchEndTime = performance.now();
    const wasPanning = isPanning.value;
    const wasPinching = isPinching.value;
    const finalVelocity = { ...panVelocity.value };
    if (wasPanning && initialTouchPoints.value && touchesLeft < initialTouchPoints.value.length) {
      isPanning.value = false;
      if (onPanEnd) onPanEnd(event);
      const velocityMagnitude = Math.hypot(finalVelocity.x, finalVelocity.y);
      if (velocityMagnitude > inertiaVelocityThreshold && onPanAnimate && zoomLevel.value > 100) {
        isAnimatingPan.value = true;
        let lastFrameTime = performance.now();
        let animVelocity = { ...finalVelocity };
        const animate = (currentTime) => {
          if (!isAnimatingPan.value) return;
          const frameDeltaTime = Math.max(1, currentTime - lastFrameTime);
          lastFrameTime = currentTime;
          const zoomFactor = zoomLevel.value / 100;
          const moveX = animVelocity.x * frameDeltaTime / zoomFactor;
          const moveY = animVelocity.y * frameDeltaTime / zoomFactor;
          onPanAnimate(moveX, moveY);
          const dampingFactor = Math.pow(
            Math.min(0.999, inertiaDamping),
            // Ensure base is < 1
            frameDeltaTime / 16.67
            // Normalize damping based on ~60fps
          );
          animVelocity.x *= dampingFactor;
          animVelocity.y *= dampingFactor;
          if (Math.hypot(animVelocity.x, animVelocity.y) < 0.01 || zoomLevel.value <= 100) {
            cancelInertiaAnimation();
          } else {
            animationFrameId.value = requestAnimationFrame(animate);
          }
        };
        animationFrameId.value = requestAnimationFrame(animate);
      } else {
        panVelocity.value = { x: 0, y: 0 };
      }
    } else if (!wasPanning) {
      panVelocity.value = { x: 0, y: 0 };
    }
    if (wasPinching && touchesLeft < 2) {
      isPinching.value = false;
      touchStartDistance.value = 0;
      if (onPinchEnd) onPinchEnd(event);
    }
    if (touchesLeft === 0 && event.changedTouches.length === 1 && // Ensure it's the end of a single touch sequence
    touchStartTime.value > 0 && // Ensure there was a valid start time recorded
    ((_a = initialTouchPoints.value) == null ? void 0 : _a.length) === 1) {
      const endCoords = event.changedTouches[0];
      const deltaX = endCoords.clientX - startPanCoords.value.x;
      const deltaY = endCoords.clientY - startPanCoords.value.y;
      const duration = touchEndTime - touchStartTime.value;
      if (!wasPanning && // Only detect swipe if not panning
      zoomLevel.value <= 100 && // Swipes only make sense at base zoom
      Math.abs(deltaX) > minSwipeDistance && Math.abs(deltaY) < maxVerticalSwipeDistance) {
        if (deltaX < 0 && onSwipeLeft) {
          onSwipeLeft();
        } else if (deltaX > 0 && onSwipeRight) {
          onSwipeRight();
        }
      } else if (!wasPanning && duration < maxTapDuration && Math.abs(deltaX) < maxTapMovement && Math.abs(deltaY) < maxTapMovement && onTap) {
        onTap(event);
      }
    }
    if (touchesLeft === 0) {
      touchStartTime.value = 0;
      startPanCoords.value = { x: 0, y: 0 };
      initialTouchPoints.value = null;
      isPinching.value = false;
      if (!isAnimatingPan.value) {
        panVelocity.value = { x: 0, y: 0 };
      }
    } else if (touchesLeft === 1 && !isPanning.value && !isPinching.value) {
      startPanCoords.value = {
        x: event.touches[0].clientX,
        y: event.touches[0].clientY
      };
      touchStartTime.value = performance.now();
      initialTouchPoints.value = event.touches;
    }
  };
  watch(
    targetRef,
    (newTarget, oldTarget) => {
      if (oldTarget) {
        oldTarget.removeEventListener("touchstart", handleTouchStart);
        oldTarget.removeEventListener("touchmove", handleTouchMove);
        oldTarget.removeEventListener("touchend", handleTouchEnd);
        oldTarget.removeEventListener("touchcancel", handleTouchEnd);
        cancelInertiaAnimation();
      }
      if (newTarget) {
        newTarget.addEventListener("touchstart", handleTouchStart, {
          passive: false
        });
        newTarget.addEventListener("touchmove", handleTouchMove, {
          passive: false
        });
        newTarget.addEventListener("touchend", handleTouchEnd, {
          passive: true
        });
        newTarget.addEventListener("touchcancel", handleTouchEnd, {
          passive: true
        });
      }
    },
    { immediate: true }
  );
  return {
    isPanning: readonly(isPanning),
    isPinching: readonly(isPinching),
    isAnimatingPan: readonly(isAnimatingPan)
    // Expose inertia animation status
  };
}
function useImageNavigation({
  initialIndex,
  imageCount,
  onNavigate
}) {
  const currentIndex = ref(initialIndex.value);
  watch(initialIndex, (newVal) => {
    currentIndex.value = newVal;
    onNavigate == null ? void 0 : onNavigate();
  });
  function nextImage() {
    if (imageCount.value > 0) {
      currentIndex.value = (currentIndex.value + 1) % imageCount.value;
      onNavigate == null ? void 0 : onNavigate();
    }
  }
  function previousImage() {
    if (imageCount.value > 0) {
      currentIndex.value = (currentIndex.value - 1 + imageCount.value) % imageCount.value;
      onNavigate == null ? void 0 : onNavigate();
    }
  }
  return {
    currentIndex,
    nextImage,
    previousImage
  };
}
function useZoomPan({ containerRef, isEnabled }) {
  const zoomLevel = ref(100);
  const panPosition = ref({ x: 0, y: 0 });
  const isMousePanning = ref(false);
  const startMousePanCoords = ref({ x: 0, y: 0 });
  const initialPanPositionOnGestureStart = ref({ x: 0, y: 0 });
  const snapThresholdLower = 90;
  const snapThresholdUpper = 110;
  watch(zoomLevel, (newZoom, oldZoom) => {
    if (newZoom <= 100 && oldZoom > 100) {
      panPosition.value = { x: 0, y: 0 };
    }
  });
  function zoomIn() {
    zoomLevel.value = Math.min(zoomLevel.value + 25, 300);
  }
  function zoomOut() {
    const newZoom = Math.max(zoomLevel.value - 25, 25);
    if (zoomLevel.value > 100 && newZoom < 100) {
      zoomLevel.value = 100;
    } else {
      zoomLevel.value = newZoom;
    }
  }
  function resetZoom() {
    zoomLevel.value = 100;
    panPosition.value = { x: 0, y: 0 };
    isMousePanning.value = false;
    initialPanPositionOnGestureStart.value = { x: 0, y: 0 };
  }
  function handlePanStart(event) {
    if (zoomLevel.value <= 100) return;
    event.preventDefault();
    isMousePanning.value = true;
    startMousePanCoords.value = { x: event.clientX, y: event.clientY };
    initialPanPositionOnGestureStart.value = { ...panPosition.value };
    const handlePanMove = (moveEvent) => {
      if (!isMousePanning.value) return;
      const deltaX = moveEvent.clientX - startMousePanCoords.value.x;
      const deltaY = moveEvent.clientY - startMousePanCoords.value.y;
      const zoomFactor = zoomLevel.value / 100;
      panPosition.value = {
        x: initialPanPositionOnGestureStart.value.x + deltaX / zoomFactor,
        y: initialPanPositionOnGestureStart.value.y + deltaY / zoomFactor
      };
    };
    const handlePanEnd = () => {
      if (isMousePanning.value) {
        isMousePanning.value = false;
        document.removeEventListener("mousemove", handlePanMove);
        document.removeEventListener("mouseup", handlePanEnd);
      }
    };
    document.addEventListener("mousemove", handlePanMove);
    document.addEventListener("mouseup", handlePanEnd);
  }
  function handleWheel(event) {
    var _a;
    if (!isEnabled.value) return;
    if ((_a = containerRef.value) == null ? void 0 : _a.contains(event.target)) {
      event.preventDefault();
      let dampingFactor = event.ctrlKey ? 0.5 : 0.2;
      const zoomChange = -event.deltaY * dampingFactor;
      const currentZoom = zoomLevel.value;
      const newZoom = Math.round(currentZoom + zoomChange);
      let clampedZoom = Math.max(25, Math.min(300, newZoom));
      if (currentZoom > 100 && clampedZoom < 100 || currentZoom < 100 && clampedZoom > 100) {
        if (Math.abs(100 - clampedZoom) < Math.abs(zoomChange) * 1.5) {
          clampedZoom = 100;
        }
      }
      zoomLevel.value = clampedZoom;
    }
  }
  onMounted(() => {
    const container = containerRef.value;
    if (container) {
      container.addEventListener("wheel", handleWheel, {
        passive: false,
        capture: true
      });
    }
  });
  onUnmounted(() => {
    const container = containerRef.value;
    if (container) {
      container.removeEventListener("wheel", handleWheel, { capture: true });
    }
    if (isMousePanning.value) {
      isMousePanning.value = false;
    }
  });
  return {
    zoomLevel,
    panPosition,
    isMousePanning,
    initialPanPositionOnGestureStart,
    zoomIn,
    zoomOut,
    resetZoom,
    handlePanStart,
    snapThresholdLower,
    snapThresholdUpper
  };
}
const _hoisted_1$15 = {
  class: "lucide lucide-download",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function render$j(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$15, _cache[0] || (_cache[0] = [
    createBaseVNode(
      "path",
      { d: "M12 15V3" },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      { d: "m7 10 5 5 5-5" },
      null,
      -1
      /* HOISTED */
    )
  ]));
}
const LucideDownload = markRaw({ name: "lucide-download", render: render$j });
const _hoisted_1$14 = {
  class: "lucide lucide-maximize",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function render$i(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$14, _cache[0] || (_cache[0] = [
    createBaseVNode(
      "path",
      { d: "M8 3H5a2 2 0 0 0-2 2v3" },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      { d: "M21 8V5a2 2 0 0 0-2-2h-3" },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      { d: "M3 16v3a2 2 0 0 0 2 2h3" },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      { d: "M16 21h3a2 2 0 0 0 2-2v-3" },
      null,
      -1
      /* HOISTED */
    )
  ]));
}
const LucideMaximize = markRaw({ name: "lucide-maximize", render: render$i });
const _hoisted_1$13 = {
  class: "lucide lucide-minimize",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function render$h(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$13, _cache[0] || (_cache[0] = [
    createBaseVNode(
      "path",
      { d: "M8 3v3a2 2 0 0 1-2 2H3" },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      { d: "M21 8h-3a2 2 0 0 1-2-2V3" },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      { d: "M3 16h3a2 2 0 0 1 2 2v3" },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      { d: "M16 21v-3a2 2 0 0 1 2-2h3" },
      null,
      -1
      /* HOISTED */
    )
  ]));
}
const LucideMinimize = markRaw({ name: "lucide-minimize", render: render$h });
const _hoisted_1$12 = {
  class: "lucide lucide-chevron-left",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function render$g(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$12, _cache[0] || (_cache[0] = [
    createBaseVNode(
      "path",
      { d: "m15 18-6-6 6-6" },
      null,
      -1
      /* HOISTED */
    )
  ]));
}
const LucideChevronLeft = markRaw({ name: "lucide-chevron-left", render: render$g });
const _hoisted_1$11 = {
  class: "lucide lucide-minus",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function render$f(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$11, _cache[0] || (_cache[0] = [
    createBaseVNode(
      "path",
      { d: "M5 12h14" },
      null,
      -1
      /* HOISTED */
    )
  ]));
}
const Minus = markRaw({ name: "lucide-minus", render: render$f });
const INACTIVITY_TIMEOUT = 3e3;
const _sfc_main$_ = /* @__PURE__ */ defineComponent({
  __name: "ImageViewerModal",
  props: {
    show: { type: Boolean, required: true },
    images: { type: Array, required: true },
    initialIndex: { type: Number, required: true }
  },
  emits: ["update:show"],
  setup(__props, { expose: __expose, emit: __emit }) {
    __expose();
    const props = __props;
    const emit = __emit;
    const imageContainer = useTemplateRef("imageContainer");
    const backdropElement = useTemplateRef("backdropElement");
    const controlsBar = useTemplateRef("controlsBar");
    const controlsBarHeight = ref(0);
    const isFullscreen = ref(false);
    const touchStartZoom = ref(100);
    const isControlsVisible = ref(true);
    const inactivityTimer = ref(null);
    const {
      zoomLevel,
      panPosition,
      isMousePanning,
      initialPanPositionOnGestureStart,
      zoomIn,
      zoomOut,
      resetZoom,
      handlePanStart,
      snapThresholdLower,
      snapThresholdUpper
    } = useZoomPan({
      containerRef: imageContainer,
      isEnabled: toRef(props, "show")
    });
    const { currentIndex, nextImage, previousImage } = useImageNavigation({
      initialIndex: toRef(props, "initialIndex"),
      imageCount: computed(() => props.images.length),
      onNavigate: resetZoom
    });
    const currentImage = computed(() => props.images[currentIndex.value]);
    const {
      isPanning: isTouchPanning,
      isPinching,
      isAnimatingPan
    } = useTouchHandler({
      targetRef: imageContainer,
      zoomLevel,
      panThreshold: 10,
      onSwipeLeft: () => {
        if (zoomLevel.value <= 100) nextImage();
      },
      onSwipeRight: () => {
        if (zoomLevel.value <= 100) previousImage();
      },
      onDoubleTap: (event) => {
        var _a;
        if ((_a = controlsBar.value) == null ? void 0 : _a.contains(event.target)) return;
        if (zoomLevel.value > 100) {
          resetZoom();
        } else {
          zoomLevel.value = 200;
          panPosition.value = { x: 0, y: 0 };
        }
      },
      onTap: (event) => {
        if (event.target === backdropElement.value) {
          close();
        }
      },
      onPanStart: () => {
        if (zoomLevel.value <= 100) return;
        initialPanPositionOnGestureStart.value = { ...panPosition.value };
      },
      onPanMove: (deltaX, deltaY) => {
        if (zoomLevel.value <= 100) return;
        panPosition.value = {
          x: initialPanPositionOnGestureStart.value.x + deltaX,
          y: initialPanPositionOnGestureStart.value.y + deltaY
        };
      },
      onPanAnimate: (deltaX, deltaY) => {
        panPosition.value = {
          x: panPosition.value.x + deltaX,
          y: panPosition.value.y + deltaY
        };
      },
      onPinchStart: () => {
        touchStartZoom.value = zoomLevel.value;
        initialPanPositionOnGestureStart.value = { ...panPosition.value };
      },
      onPinchMove: (scale) => {
        const newZoom = touchStartZoom.value * scale;
        let finalZoom = Math.max(25, Math.min(300, Math.round(newZoom)));
        if (finalZoom > snapThresholdLower && finalZoom < snapThresholdUpper) {
          finalZoom = 100;
        }
        zoomLevel.value = finalZoom;
      },
      onPinchEnd: () => {
        if (zoomLevel.value < 100) {
          resetZoom();
        }
        initialPanPositionOnGestureStart.value = { x: 0, y: 0 };
      }
    });
    const isPanning = computed(() => isMousePanning.value || isTouchPanning.value);
    function showControlsAndResetTimer() {
      isControlsVisible.value = true;
      if (inactivityTimer.value) {
        clearTimeout(inactivityTimer.value);
      }
      inactivityTimer.value = setTimeout(() => {
        if (!isPanning.value && !isPinching.value) {
          isControlsVisible.value = false;
        } else {
          showControlsAndResetTimer();
        }
      }, INACTIVITY_TIMEOUT);
    }
    function handleActivity() {
      if (!isPinching.value || !isControlsVisible.value) {
        showControlsAndResetTimer();
      }
    }
    function close() {
      emit("update:show", false);
      resetZoom();
      if (inactivityTimer.value) {
        clearTimeout(inactivityTimer.value);
        inactivityTimer.value = null;
      }
    }
    function downloadImage() {
      var _a;
      const imageToDownload = currentImage.value;
      const link = document.createElement("a");
      link.href = imageToDownload.src;
      const filename = ((_a = imageToDownload.alt) == null ? void 0 : _a.replace(/[^a-z0-9]/gi, "_").toLowerCase()) || imageToDownload.src.split("/").pop() || "download";
      link.download = filename.includes(".") ? filename : `${filename}.jpg`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
    function toggleFullscreen() {
      const container = imageContainer.value;
      if (!isFullscreen.value) {
        if (container == null ? void 0 : container.requestFullscreen) {
          container.requestFullscreen();
          isFullscreen.value = true;
        }
      } else {
        if (document.exitFullscreen) {
          document.exitFullscreen();
          isFullscreen.value = false;
        }
      }
    }
    function handleFullscreenChange() {
      isFullscreen.value = Boolean(document.fullscreenElement);
    }
    function handleKeyDown(event) {
      if (!props.show) return;
      handleActivity();
      switch (event.key) {
        case "ArrowLeft":
          if (!isPanning.value) previousImage();
          event.preventDefault();
          break;
        case "ArrowRight":
          if (!isPanning.value) nextImage();
          event.preventDefault();
          break;
        case "+":
        case "=":
          zoomIn();
          event.preventDefault();
          break;
        case "-":
          zoomOut();
          event.preventDefault();
          break;
        case "Escape":
          close();
          event.preventDefault();
          break;
        case "f":
        case "F":
          toggleFullscreen();
          event.preventDefault();
          break;
      }
    }
    watch(
      () => props.show,
      (newValue) => {
        if (newValue) {
          isControlsVisible.value = true;
          resetZoom();
          showControlsAndResetTimer();
        } else {
          if (inactivityTimer.value) {
            clearTimeout(inactivityTimer.value);
            inactivityTimer.value = null;
          }
          if (isFullscreen.value && document.exitFullscreen) {
            document.exitFullscreen();
          }
        }
      }
    );
    watch(controlsBar, (newVal) => {
      if (newVal) {
        const updateHeight = () => {
          controlsBarHeight.value = newVal.offsetHeight;
        };
        const resizeObserver = new ResizeObserver(updateHeight);
        resizeObserver.observe(newVal);
        updateHeight();
        onUnmounted(() => resizeObserver.disconnect());
      } else {
        controlsBarHeight.value = 0;
      }
    });
    onMounted(() => {
      document.addEventListener("fullscreenchange", handleFullscreenChange);
      document.addEventListener("keydown", handleKeyDown);
    });
    onUnmounted(() => {
      document.removeEventListener("fullscreenchange", handleFullscreenChange);
      document.removeEventListener("keydown", handleKeyDown);
      if (inactivityTimer.value) {
        clearTimeout(inactivityTimer.value);
      }
      if (isFullscreen.value && document.exitFullscreen) {
        document.exitFullscreen();
      }
    });
    const __returned__ = { props, emit, imageContainer, backdropElement, controlsBar, controlsBarHeight, isFullscreen, touchStartZoom, isControlsVisible, inactivityTimer, INACTIVITY_TIMEOUT, zoomLevel, panPosition, isMousePanning, initialPanPositionOnGestureStart, zoomIn, zoomOut, resetZoom, handlePanStart, snapThresholdLower, snapThresholdUpper, currentIndex, nextImage, previousImage, currentImage, isTouchPanning, isPinching, isAnimatingPan, isPanning, showControlsAndResetTimer, handleActivity, close, downloadImage, toggleFullscreen, handleFullscreenChange, handleKeyDown, Tooltip: __unplugin_components_0$2, get LucideDownload() {
      return LucideDownload;
    }, get LucideMaximize() {
      return LucideMaximize;
    }, get LucideMinimize() {
      return LucideMinimize;
    }, get LucideChevronLeft() {
      return LucideChevronLeft;
    }, get LucideChevronRight() {
      return LucideChevronRight;
    }, get LucidePlus() {
      return LucidePlus;
    }, get LucideMinus() {
      return Minus;
    }, get LucideX() {
      return LucideX;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$10 = { class: "relative z-10 flex flex-col items-center" };
const _hoisted_2$c = ["src", "alt"];
const _hoisted_3$8 = { class: "bg-black/65 rounded flex items-center" };
const _hoisted_4$5 = { class: "px-2 text-sm tabular-nums text-gray-400 select-none" };
const _hoisted_5$5 = { class: "bg-black/65 rounded flex items-center" };
const _hoisted_6$4 = { class: "bg-black/65 rounded flex items-center" };
const _hoisted_7$3 = { class: "bg-black/65 rounded flex items-center" };
function _sfc_render$U(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Teleport, { to: "body" }, [
    createVNode(Transition, {
      "enter-active-class": "transition-opacity duration-150 ease-in-out",
      "leave-active-class": "transition-opacity duration-150 ease-in-out",
      "enter-from-class": "opacity-0",
      "leave-to-class": "opacity-0",
      appear: ""
    }, {
      default: withCtx(() => [
        $setup.props.show ? (openBlock(), createElementBlock(
          "div",
          {
            key: 0,
            class: "fixed top-0 left-0 w-full h-full bg-black sm:bg-black/90 z-[50] flex flex-col justify-center items-center overflow-hidden touch-none",
            ref: "imageContainer",
            onMousemove: $setup.handleActivity,
            onTouchstart: $setup.handleActivity,
            onTouchmove: $setup.handleActivity
          },
          [
            createCommentVNode(" Dedicated Backdrop "),
            createBaseVNode(
              "div",
              {
                class: "absolute inset-0 z-0",
                ref: "backdropElement",
                onClick: $setup.close
              },
              null,
              512
              /* NEED_PATCH */
            ),
            createCommentVNode(" Image Container "),
            createBaseVNode("div", _hoisted_1$10, [
              createBaseVNode("img", {
                src: $setup.currentImage.src,
                alt: $setup.currentImage.alt || "Image preview",
                class: "max-w-screen max-h-screen object-contain block",
                style: normalizeStyle({
                  transform: `scale(${$setup.zoomLevel / 100}) translate(${$setup.panPosition.x}px, ${$setup.panPosition.y}px)`,
                  cursor: $setup.zoomLevel > 100 ? $setup.isMousePanning ? "grabbing" : "grab" : "default",
                  transition: $setup.isPanning || $setup.isPinching || $setup.isAnimatingPan ? "none" : "transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)"
                }),
                onMousedown: _cache[0] || (_cache[0] = (...args) => $setup.handlePanStart && $setup.handlePanStart(...args)),
                draggable: "false"
              }, null, 44, _hoisted_2$c)
            ]),
            createCommentVNode(" Caption "),
            $setup.currentImage.alt ? (openBlock(), createElementBlock(
              "div",
              {
                key: 0,
                class: normalizeClass(["absolute bottom-4 p-2 text-center rounded-sm text-white text-sm bg-black/65 z-10 transition-opacity duration-300 ease-in-out", { "opacity-0 pointer-events-none": !$setup.isControlsVisible }])
              },
              toDisplayString($setup.currentImage.alt),
              3
              /* TEXT, CLASS */
            )) : createCommentVNode("v-if", true),
            createCommentVNode(" Controls bar "),
            createBaseVNode(
              "div",
              {
                ref: "controlsBar",
                class: normalizeClass(["absolute top-4 flex items-center space-x-3 p-2 text-white z-20 transition-opacity duration-300 ease-in-out", { "opacity-0 pointer-events-none": !$setup.isControlsVisible }]),
                onTouchstart: _cache[6] || (_cache[6] = withModifiers(() => {
                }, ["stop"])),
                onTouchmove: _cache[7] || (_cache[7] = withModifiers(() => {
                }, ["stop"])),
                onTouchend: _cache[8] || (_cache[8] = withModifiers(() => {
                }, ["stop"])),
                onMousedown: _cache[9] || (_cache[9] = withModifiers(() => {
                }, ["stop"])),
                onWheel: _cache[10] || (_cache[10] = withModifiers(() => {
                }, ["stop"]))
              },
              [
                createCommentVNode(" Navigation controls "),
                createBaseVNode("div", _hoisted_3$8, [
                  createVNode($setup["Tooltip"], { text: "Previous image" }, {
                    default: withCtx(() => [
                      createBaseVNode("button", {
                        class: "p-2 hover:bg-gray-900 rounded-l focus:outline-none",
                        onClick: _cache[1] || (_cache[1] = withModifiers((...args) => $setup.previousImage && $setup.previousImage(...args), ["stop"]))
                      }, [
                        createVNode($setup["LucideChevronLeft"], { class: "size-4" })
                      ])
                    ]),
                    _: 1
                    /* STABLE */
                  }),
                  createBaseVNode(
                    "span",
                    _hoisted_4$5,
                    toDisplayString($setup.currentIndex + 1) + "/" + toDisplayString($setup.props.images.length),
                    1
                    /* TEXT */
                  ),
                  createVNode($setup["Tooltip"], { text: "Next image" }, {
                    default: withCtx(() => [
                      createBaseVNode("button", {
                        class: "p-2 hover:bg-gray-900 rounded-r focus:outline-none",
                        onClick: _cache[2] || (_cache[2] = withModifiers((...args) => $setup.nextImage && $setup.nextImage(...args), ["stop"]))
                      }, [
                        createVNode($setup["LucideChevronRight"], { class: "size-4" })
                      ])
                    ]),
                    _: 1
                    /* STABLE */
                  })
                ]),
                createCommentVNode(" Zoom controls "),
                createBaseVNode("div", _hoisted_5$5, [
                  createVNode($setup["Tooltip"], { text: "Zoom out" }, {
                    default: withCtx(() => [
                      createBaseVNode("button", {
                        class: "p-2 hover:bg-gray-900 rounded-l focus:outline-none",
                        onClick: _cache[3] || (_cache[3] = withModifiers((...args) => $setup.zoomOut && $setup.zoomOut(...args), ["stop"]))
                      }, [
                        createVNode($setup["LucideMinus"], { class: "size-4" })
                      ])
                    ]),
                    _: 1
                    /* STABLE */
                  }),
                  createVNode($setup["Tooltip"], { text: "Reset zoom" }, {
                    default: withCtx(() => [
                      createBaseVNode(
                        "button",
                        {
                          class: "p-2 hover:bg-gray-900 text-sm text-gray-400 focus:outline-none",
                          onClick: _cache[4] || (_cache[4] = withModifiers((...args) => $setup.resetZoom && $setup.resetZoom(...args), ["stop"]))
                        },
                        toDisplayString($setup.zoomLevel) + "% ",
                        1
                        /* TEXT */
                      )
                    ]),
                    _: 1
                    /* STABLE */
                  }),
                  createVNode($setup["Tooltip"], { text: "Zoom in" }, {
                    default: withCtx(() => [
                      createBaseVNode("button", {
                        class: "p-2 hover:bg-gray-900 rounded-r focus:outline-none",
                        onClick: _cache[5] || (_cache[5] = withModifiers((...args) => $setup.zoomIn && $setup.zoomIn(...args), ["stop"]))
                      }, [
                        createVNode($setup["LucidePlus"], { class: "size-4" })
                      ])
                    ]),
                    _: 1
                    /* STABLE */
                  })
                ]),
                createCommentVNode(" Action controls "),
                createBaseVNode("div", _hoisted_6$4, [
                  createVNode($setup["Tooltip"], { text: "Download image" }, {
                    default: withCtx(() => [
                      createBaseVNode("button", {
                        class: "p-2 hover:bg-gray-900 rounded-l focus:outline-none",
                        onClick: withModifiers($setup.downloadImage, ["stop"])
                      }, [
                        createVNode($setup["LucideDownload"], { class: "size-4" })
                      ])
                    ]),
                    _: 1
                    /* STABLE */
                  }),
                  createVNode($setup["Tooltip"], {
                    text: $setup.isFullscreen ? "Exit fullscreen" : "Enter fullscreen"
                  }, {
                    default: withCtx(() => [
                      createBaseVNode("button", {
                        class: "p-2 hover:bg-gray-900 rounded-r focus:outline-none hidden sm:block",
                        onClick: withModifiers($setup.toggleFullscreen, ["stop"])
                      }, [
                        !$setup.isFullscreen ? (openBlock(), createBlock($setup["LucideMaximize"], {
                          key: 0,
                          class: "size-4"
                        })) : (openBlock(), createBlock($setup["LucideMinimize"], {
                          key: 1,
                          class: "size-4"
                        }))
                      ])
                    ]),
                    _: 1
                    /* STABLE */
                  }, 8, ["text"])
                ]),
                createCommentVNode(" Close button "),
                createBaseVNode("div", _hoisted_7$3, [
                  createVNode($setup["Tooltip"], { text: "Close" }, {
                    default: withCtx(() => [
                      createBaseVNode("button", {
                        class: "p-2 hover:bg-gray-900 rounded focus:outline-none",
                        onClick: withModifiers($setup.close, ["stop"])
                      }, [
                        createVNode($setup["LucideX"], { class: "size-4" })
                      ])
                    ]),
                    _: 1
                    /* STABLE */
                  })
                ])
              ],
              34
              /* CLASS, NEED_HYDRATION */
            )
          ],
          544
          /* NEED_HYDRATION, NEED_PATCH */
        )) : createCommentVNode("v-if", true)
      ]),
      _: 1
      /* STABLE */
    })
  ]);
}
_sfc_main$_.__file = "src/components/TextEditor/ImageViewerModal.vue";
const ImageViewerModal = /* @__PURE__ */ _export_sfc(_sfc_main$_, [["render", _sfc_render$U], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/TextEditor/ImageViewerModal.vue"]]);
const ImageViewerExtension = Extension.create({
  name: "imageViewer",
  onBeforeCreate() {
    if (!document.querySelector("style[data-image-viewer-style]")) {
      const style = document.createElement("style");
      style.textContent = `
          .ProseMirror:not(.ProseMirror-focused) img {
            cursor: pointer;
          }
        `;
      style.setAttribute("data-image-viewer-style", "true");
      document.head.appendChild(style);
    }
  },
  onDestroy() {
    const style = document.querySelector("style[data-image-viewer-style]");
    if (style) {
      document.head.removeChild(style);
    }
  },
  addCommands() {
    return {
      openImageViewer: (src) => ({ editor }) => {
        const images = [];
        editor.state.doc.descendants((node) => {
          if (node.type.name === "image") {
            images.push({
              src: node.attrs.src,
              alt: node.attrs.alt || null
            });
          }
          return true;
        });
        const currentIndex = images.findIndex((image) => image.src === src);
        openImageViewerModal(images, currentIndex);
        return true;
      }
    };
  },
  addProseMirrorPlugins() {
    const extension = this;
    return [
      new Plugin({
        key: new PluginKey("imageViewer"),
        props: {
          handleClick(view, pos, event) {
            if (extension.editor.isEditable) {
              return false;
            }
            const { state } = view;
            const clickedNode = state.doc.nodeAt(pos);
            if ((clickedNode == null ? void 0 : clickedNode.type.name) === "image") {
              event.preventDefault();
              const src = clickedNode.attrs.src;
              extension.editor.commands.openImageViewer(src);
              return true;
            }
            if (event.target instanceof HTMLImageElement) {
              let foundImageNode = false;
              state.doc.descendants((node, nodePos) => {
                if (node.type.name === "image" && !foundImageNode) {
                  const domNode = view.nodeDOM(nodePos);
                  if (domNode && (domNode === event.target || domNode.contains(event.target))) {
                    event.preventDefault();
                    extension.editor.commands.openImageViewer(node.attrs.src);
                    foundImageNode = true;
                    return false;
                  }
                }
                return true;
              });
              if (foundImageNode) return true;
            }
            return false;
          }
        }
      })
    ];
  }
});
function openImageViewerModal(images, initialIndex) {
  const container = document.createElement("div");
  document.body.appendChild(container);
  const app = createApp({
    render() {
      return h(ImageViewerModal, {
        show: true,
        images,
        // Pass the collected image data
        initialIndex,
        // Pass the starting index
        "onUpdate:show": (value) => {
          if (!value) {
            setTimeout(() => {
              app.unmount();
              container.remove();
            }, 0);
          }
        }
      });
    }
  });
  app.mount(container);
}
const VideoExtension = Node.create({
  name: "video",
  group: "block",
  selectable: true,
  draggable: true,
  atom: true,
  addOptions() {
    return {
      uploadFunction: null,
      HTMLAttributes: {}
    };
  },
  addAttributes() {
    return {
      src: {
        default: null
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "video"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return [
      "video",
      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, {
        controls: ""
      })
    ];
  },
  addCommands() {
    return {
      setVideo: (options) => ({ commands: commands2 }) => {
        return commands2.insertContent({
          type: this.name,
          attrs: options
        });
      },
      uploadVideo: (file) => ({ editor }) => {
        const pos = editor.state.selection.from;
        return uploadVideoInternal(file, editor.view, pos, this.options);
      },
      selectAndUploadVideo: () => ({ editor }) => {
        if (!this.options.uploadFunction) {
          console.error("uploadFunction option is not provided for videos.");
          return false;
        }
        const input = document.createElement("input");
        input.type = "file";
        input.accept = "video/*";
        input.onchange = (event) => {
          const target = event.target;
          if (target.files && target.files.length) {
            const file = target.files[0];
            editor.commands.uploadVideo(file);
          }
        };
        input.click();
        return true;
      }
    };
  },
  addNodeView() {
    return ({ editor, node }) => {
      const div = document.createElement("div");
      div.className = "relative aspect-w-16 aspect-h-9" + (editor.isEditable ? " cursor-pointer" : "");
      const video = document.createElement("video");
      video.src = node.attrs.src;
      video.setAttribute("controls", "");
      if (editor.isEditable) {
        let videoPill = document.createElement("div");
        videoPill.className = "absolute top-0 right-0 text-xs m-2 bg-surface-gray-6 text-ink-white px-2 py-1 rounded-md";
        videoPill.innerHTML = "Video";
        div.append(videoPill);
      }
      div.append(video);
      return {
        dom: div
      };
    };
  }
});
function uploadVideoInternal(file, view, pos, options) {
  if (!options.uploadFunction) {
    console.error("uploadFunction option is not provided for videos.");
    return false;
  }
  options.uploadFunction(file).then((uploadedVideo) => {
    const { schema } = view.state;
    const node = schema.nodes.video.create({ src: uploadedVideo.file_url });
    const transaction = view.state.tr;
    if (pos != null) {
      transaction.insert(pos, node);
    } else {
      transaction.replaceSelectionWith(node);
    }
    view.dispatch(transaction);
  }).catch((error) => {
    console.error("Video upload failed:", error);
  });
  return true;
}
const ALLOWED_DOMAINS = [
  "youtube.com",
  "www.youtube.com",
  "youtu.be",
  "vimeo.com",
  "player.vimeo.com",
  "codepen.io",
  "codesandbox.io",
  "figma.com",
  "www.figma.com",
  "embed.figma.com",
  "docs.google.com",
  "drive.google.com",
  "notion.so",
  "www.notion.so"
];
const PLATFORM_CONFIGS = [
  {
    name: "YouTube",
    ratio: 9 / 16,
    // 16:9 aspect ratio
    defaultWidth: 640,
    urlPatterns: ["youtube.com", "youtu.be", "youtube-nocookie.com"]
  },
  {
    name: "Vimeo",
    ratio: 9 / 16,
    // 16:9 aspect ratio
    defaultWidth: 640,
    urlPatterns: ["vimeo.com", "player.vimeo.com"]
  },
  {
    name: "CodePen",
    ratio: 3 / 2,
    // 2:3 aspect ratio (taller for code demos)
    defaultWidth: 500,
    urlPatterns: ["codepen.io"]
  },
  {
    name: "CodeSandbox",
    ratio: 3 / 2,
    // 2:3 aspect ratio
    defaultWidth: 500,
    urlPatterns: ["codesandbox.io"]
  },
  {
    name: "Figma",
    ratio: 9 / 16,
    // 16:9 default for design embeds
    defaultWidth: 800,
    urlPatterns: ["figma.com", "www.figma.com", "embed.figma.com"]
  },
  {
    name: "Google Docs",
    ratio: 4 / 3,
    // 4:3 for documents
    defaultWidth: 600,
    urlPatterns: ["docs.google.com", "drive.google.com"]
  },
  {
    name: "Notion",
    ratio: 4 / 3,
    // 4:3 for pages
    defaultWidth: 600,
    urlPatterns: ["notion.so", "www.notion.so"]
  }
];
function detectPlatform(url) {
  try {
    const urlObj = new URL(url);
    const domain = urlObj.hostname.toLowerCase();
    return PLATFORM_CONFIGS.find(
      (config) => config.urlPatterns.some((pattern) => domain.includes(pattern))
    ) || null;
  } catch {
    return null;
  }
}
function calculateAspectRatio(url) {
  const platform = detectPlatform(url);
  if (platform) {
    return {
      ratio: platform.ratio,
      width: platform.defaultWidth,
      height: Math.round(platform.defaultWidth * platform.ratio),
      platform: platform.name
    };
  }
  return {
    ratio: 9 / 16,
    width: 640,
    height: 360,
    platform: "Generic"
  };
}
function getOptimalDimensions(url, containerWidth) {
  const aspectInfo = calculateAspectRatio(url);
  if (containerWidth) {
    const CONTAINER_PADDING = 40;
    const maxWidth = Math.min(containerWidth - CONTAINER_PADDING, aspectInfo.width);
    return {
      width: maxWidth,
      height: Math.round(maxWidth * aspectInfo.ratio)
    };
  }
  return {
    width: aspectInfo.width,
    height: aspectInfo.height
  };
}
function validateURL(url, options) {
  var _a, _b;
  try {
    if (url.startsWith("/")) return true;
    const urlObj = new URL(url);
    const domain = urlObj.hostname.toLowerCase();
    if ((_a = options.blockedDomains) == null ? void 0 : _a.some((blocked) => domain.includes(blocked))) {
      return false;
    }
    if ((_b = options.allowedDomains) == null ? void 0 : _b.length) {
      return options.allowedDomains.some(
        (allowed) => domain.includes(allowed.toLowerCase())
      );
    }
    return true;
  } catch {
    return false;
  }
}
function processURL(url) {
  try {
    const urlObj = new URL(url);
    const domain = urlObj.hostname.toLowerCase();
    if (domain.includes("youtube.com") || domain.includes("youtu.be")) {
      return convertToYouTubeEmbed(url);
    }
    if (domain.includes("vimeo.com")) {
      return convertToVimeoEmbed(url);
    }
    if (domain.includes("codepen.io")) {
      return convertToCodePenEmbed(url);
    }
    if (domain.includes("figma.com")) {
      return convertToFigmaEmbed(url);
    }
    return url;
  } catch {
    return url;
  }
}
function convertToYouTubeEmbed(url) {
  try {
    const urlObj = new URL(url);
    let videoId = "";
    if (urlObj.hostname === "youtu.be") {
      videoId = urlObj.pathname.slice(1);
    } else if (urlObj.hostname.includes("youtube.com")) {
      videoId = urlObj.searchParams.get("v") || "";
      if (urlObj.pathname.includes("/embed/")) {
        return url;
      }
    }
    if (videoId) {
      return `https://www.youtube.com/embed/${videoId}?rel=0&modestbranding=1`;
    }
  } catch (e) {
    console.warn("Failed to convert YouTube URL:", e);
  }
  return url;
}
function convertToVimeoEmbed(url) {
  try {
    if (url.includes("player.vimeo.com")) {
      return url;
    }
    const match = url.match(/vimeo\.com\/(?:.*\/)?(\d+)/);
    if (match == null ? void 0 : match[1]) {
      return `https://player.vimeo.com/video/${match[1]}?title=0&byline=0&portrait=0`;
    }
  } catch (e) {
    console.warn("Failed to convert Vimeo URL:", e);
  }
  return url;
}
function convertToCodePenEmbed(url) {
  try {
    if (url.includes("/embed/")) {
      return url;
    }
    const match = url.match(/codepen\.io\/([^\/]+)\/pen\/([^\/\?]+)/);
    if ((match == null ? void 0 : match[1]) && (match == null ? void 0 : match[2])) {
      return `https://codepen.io/${match[1]}/embed/${match[2]}?default-tab=result`;
    }
  } catch (e) {
    console.warn("Failed to convert CodePen URL:", e);
  }
  return url;
}
function convertToFigmaEmbed(url) {
  try {
    const urlObj = new URL(url);
    if (urlObj.hostname === "www.figma.com" || urlObj.hostname === "figma.com") {
      if (urlObj.pathname.startsWith("/design/")) {
        urlObj.hostname = "embed.figma.com";
        urlObj.searchParams.set("embed-host", "share");
        return urlObj.toString();
      }
    }
    if (urlObj.hostname === "embed.figma.com") {
      if (!urlObj.searchParams.has("embed-host")) {
        urlObj.searchParams.set("embed-host", "share");
      }
      return urlObj.toString();
    }
    return url;
  } catch (e) {
    console.warn("Failed to convert Figma URL:", e);
  }
  return url;
}
const _sfc_main$Z = /* @__PURE__ */ defineComponent({
  __name: "IframeNodeView",
  props: nodeViewProps,
  setup(__props, { expose: __expose }) {
    __expose();
    const props = __props;
    const iframeRef = ref(null);
    const containerRef = ref(null);
    const isResizing = ref(false);
    const startDragX = ref(0);
    const startWidth = ref(0);
    const originalAspectRatio = ref(9 / 16);
    const isEditable = ref(false);
    function selectIframe() {
      props.editor.commands.setNodeSelection(props.getPos());
    }
    const platformInfo = computed(() => {
      if (props.node.attrs.src) {
        const platform = detectPlatform(props.node.attrs.src);
        const aspectInfo = calculateAspectRatio(props.node.attrs.src);
        return {
          platform: (platform == null ? void 0 : platform.name) || "Generic",
          aspectRatio: aspectInfo.ratio
        };
      }
      return { platform: "Generic", aspectRatio: 9 / 16 };
    });
    const iframeStyles = computed(() => {
      const width = props.node.attrs.width || 640;
      const height = props.node.attrs.height || width * originalAspectRatio.value;
      return {
        width: `${width}px`,
        height: `${height}px`
      };
    });
    onMounted(() => {
      isEditable.value = props.editor.isEditable;
      if (props.node.attrs.aspectRatio) {
        originalAspectRatio.value = props.node.attrs.aspectRatio;
      } else if (props.node.attrs.src) {
        const aspectInfo = calculateAspectRatio(props.node.attrs.src);
        originalAspectRatio.value = aspectInfo.ratio;
        props.updateAttributes({ aspectRatio: aspectInfo.ratio });
      }
    });
    props.editor.on("update", () => {
      isEditable.value = props.editor.isEditable;
    });
    function startResize(event) {
      var _a;
      if (!isEditable.value) return;
      selectIframe();
      isResizing.value = true;
      startDragX.value = event.clientX;
      startWidth.value = ((_a = containerRef.value) == null ? void 0 : _a.offsetWidth) || props.node.attrs.width || 640;
      if (props.node.attrs.aspectRatio) {
        originalAspectRatio.value = props.node.attrs.aspectRatio;
      } else {
        const width = props.node.attrs.width || startWidth.value;
        const height = props.node.attrs.height || width * originalAspectRatio.value;
        if (width && height) {
          originalAspectRatio.value = height / width;
        }
      }
      window.addEventListener("mousemove", handleResize);
      window.addEventListener("mouseup", stopResize);
      document.body.style.cursor = "ew-resize";
    }
    function handleResize(event) {
      if (!isResizing.value || !iframeRef.value || !containerRef.value) return;
      const editorElement = props.editor.view.dom;
      const editorWidth = editorElement.clientWidth;
      const deltaX = event.clientX - startDragX.value;
      let newWidth = startWidth.value + deltaX;
      const MIN_WIDTH = 200;
      const PADDING = 40;
      newWidth = Math.max(MIN_WIDTH, Math.min(newWidth, editorWidth - PADDING));
      const newHeight = newWidth * originalAspectRatio.value;
      iframeRef.value.style.width = `${newWidth}px`;
      iframeRef.value.style.height = `${newHeight}px`;
      containerRef.value.style.width = `${newWidth}px`;
    }
    function stopResize() {
      if (!isResizing.value) return;
      isResizing.value = false;
      window.removeEventListener("mousemove", handleResize);
      window.removeEventListener("mouseup", stopResize);
      document.body.style.cursor = "";
      if (iframeRef.value && containerRef.value) {
        const finalWidth = iframeRef.value.offsetWidth;
        const finalHeight = iframeRef.value.offsetHeight;
        props.updateAttributes({
          width: finalWidth,
          height: finalHeight,
          aspectRatio: originalAspectRatio.value
        });
        iframeRef.value.style.width = "";
        iframeRef.value.style.height = "";
        containerRef.value.style.width = "";
      }
    }
    function setAlignment(align) {
      props.updateAttributes({ align });
    }
    function handleKeydown(event) {
      if (event.key === "Enter") {
        event.preventDefault();
        createParagraphAfterIframe();
      } else if (event.key === "Escape" || event.key === "ArrowDown") {
        event.preventDefault();
        setCursorAfterIframe();
      }
      if (event.key === "ArrowUp") {
        event.preventDefault();
        setCursorBeforeIframe();
      }
    }
    function setCursorAt(pos) {
      props.editor.commands.focus();
      props.editor.chain().setTextSelection(pos).scrollIntoView().run();
    }
    function createParagraphAfterIframe() {
      const pos = props.getPos();
      props.editor.commands.focus();
      props.editor.chain().setTextSelection(pos + 1).createParagraphNear().scrollIntoView().run();
    }
    function setCursorAfterIframe() {
      const pos = props.getPos();
      setCursorAt(pos + 1);
    }
    function setCursorBeforeIframe() {
      const pos = props.getPos();
      setCursorAt(pos - 1);
    }
    const __returned__ = { props, iframeRef, containerRef, isResizing, startDragX, startWidth, originalAspectRatio, isEditable, selectIframe, platformInfo, iframeStyles, startResize, handleResize, stopResize, setAlignment, handleKeydown, setCursorAt, createParagraphAfterIframe, setCursorAfterIframe, setCursorBeforeIframe, get NodeViewWrapper() {
      return NodeViewWrapper;
    }, get LucideMoveDiagonal2() {
      return LucideMoveDiagonal2;
    }, get LucideAlignLeft() {
      return LucideAlignLeft;
    }, get LucideAlignCenter() {
      return LucideAlignCenter;
    }, get LucideAlignRight() {
      return LucideAlignRight;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$$ = { class: "relative" };
const _hoisted_2$b = ["src", "title"];
const _hoisted_3$7 = { class: "absolute bottom-2 right-2 flex items-center gap-2 z-20" };
const _hoisted_4$4 = {
  key: 0,
  class: "flex divide-x divide-ink-gray-6 rounded-md bg-black/65"
};
const _hoisted_5$4 = {
  key: 2,
  class: "flex items-center justify-center bg-surface-gray-1 rounded-lg w-[640px] h-[360px]"
};
const _hoisted_6$3 = ["value", "disabled"];
function _sfc_render$T(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock($setup["NodeViewWrapper"], null, {
    default: withCtx(() => [
      createBaseVNode(
        "div",
        {
          ref: "containerRef",
          class: normalizeClass(["relative overflow-hidden not-prose my-6 rounded-lg block max-w-full focus:outline-none", [
            { "ring-2 ring-outline-gray-3 ring-offset-2": _ctx.selected },
            _ctx.node.attrs.align === "center" ? "mx-auto" : "",
            _ctx.node.attrs.align === "right" ? "ml-auto mr-0" : "",
            _ctx.node.attrs.align === "left" ? "mr-auto ml-0" : ""
          ]]),
          style: normalizeStyle({
            width: _ctx.node.attrs.width ? `${_ctx.node.attrs.width}px` : "auto",
            maxWidth: "100%"
          }),
          onKeydown: $setup.handleKeydown,
          tabindex: "0"
        },
        [
          createBaseVNode("div", _hoisted_1$$, [
            _ctx.node.attrs.src ? (openBlock(), createElementBlock("iframe", {
              key: 0,
              ref: "iframeRef",
              class: normalizeClass(["rounded-lg border-0 block max-w-full h-auto", {
                "pointer-events-none": $setup.isEditable && !$setup.props.node.attrs.interactive
              }]),
              src: _ctx.node.attrs.src,
              style: normalizeStyle($setup.iframeStyles),
              title: _ctx.node.attrs.title || "",
              frameborder: "0",
              allowfullscreen: "",
              loading: "lazy",
              referrerpolicy: "no-referrer-when-downgrade",
              sandbox: "allow-scripts allow-same-origin allow-popups allow-forms",
              onClick: withModifiers($setup.selectIframe, ["stop"])
            }, null, 14, _hoisted_2$b)) : createCommentVNode("v-if", true),
            createCommentVNode(" Transparent overlay for selection in edit mode "),
            $setup.isEditable && !$setup.props.node.attrs.interactive ? (openBlock(), createElementBlock("div", {
              key: 1,
              class: "absolute inset-0 cursor-pointer z-10",
              onClick: withModifiers($setup.selectIframe, ["stop"])
            })) : createCommentVNode("v-if", true),
            createCommentVNode(" Controls overlay "),
            createBaseVNode("div", _hoisted_3$7, [
              createCommentVNode(" Alignment Controls "),
              _ctx.selected && $setup.isEditable ? (openBlock(), createElementBlock("div", _hoisted_4$4, [
                createBaseVNode(
                  "button",
                  {
                    onClick: _cache[0] || (_cache[0] = withModifiers(($event) => $setup.setAlignment("left"), ["stop"])),
                    class: normalizeClass([
                      "px-1.5 py-1 text-ink-gray-4 hover:text-white transition-colors duration-150",
                      { "text-white": _ctx.node.attrs.align === "left" }
                    ]),
                    title: "Align Left"
                  },
                  [
                    createVNode($setup["LucideAlignLeft"], { class: "size-4" })
                  ],
                  2
                  /* CLASS */
                ),
                createBaseVNode(
                  "button",
                  {
                    onClick: _cache[1] || (_cache[1] = withModifiers(($event) => $setup.setAlignment("center"), ["stop"])),
                    class: normalizeClass([
                      "px-1.5 py-1 text-ink-gray-4 hover:text-white transition-colors duration-150",
                      { "text-white": _ctx.node.attrs.align === "center" }
                    ]),
                    title: "Align Center"
                  },
                  [
                    createVNode($setup["LucideAlignCenter"], { class: "size-4" })
                  ],
                  2
                  /* CLASS */
                ),
                createBaseVNode(
                  "button",
                  {
                    onClick: _cache[2] || (_cache[2] = withModifiers(($event) => $setup.setAlignment("right"), ["stop"])),
                    class: normalizeClass([
                      "px-1.5 py-1 text-ink-gray-4 hover:text-white transition-colors duration-150",
                      { "text-white": _ctx.node.attrs.align === "right" }
                    ]),
                    title: "Align Right"
                  },
                  [
                    createVNode($setup["LucideAlignRight"], { class: "size-4" })
                  ],
                  2
                  /* CLASS */
                )
              ])) : createCommentVNode("v-if", true),
              createCommentVNode(" Resize Handle "),
              _ctx.selected && $setup.isEditable ? (openBlock(), createElementBlock(
                "button",
                {
                  key: 1,
                  class: "cursor-nw-resize bg-black/65 rounded-md p-1",
                  onMousedown: withModifiers($setup.startResize, ["prevent"]),
                  title: "Resize"
                },
                [
                  createVNode($setup["LucideMoveDiagonal2"], { class: "text-white size-4" })
                ],
                32
                /* NEED_HYDRATION */
              )) : createCommentVNode("v-if", true)
            ]),
            createCommentVNode(" Loading state for new embeds "),
            !_ctx.node.attrs.src ? (openBlock(), createElementBlock("div", _hoisted_5$4, _cache[4] || (_cache[4] = [
              createBaseVNode(
                "div",
                { class: "text-ink-gray-5 text-center" },
                [
                  createBaseVNode("div", { class: "text-lg mb-1" }, "🔗"),
                  createBaseVNode("div", { class: "text-sm" }, "Loading embed...")
                ],
                -1
                /* HOISTED */
              )
            ]))) : createCommentVNode("v-if", true)
          ]),
          createCommentVNode(" Caption/Title input "),
          ($setup.isEditable || _ctx.node.attrs.title) && _ctx.node.attrs.src ? (openBlock(), createElementBlock("input", {
            key: 0,
            value: _ctx.node.attrs.title,
            class: "w-full text-center bg-transparent text-sm text-ink-gray-6 h-7 border-0 mt-2 focus:outline-none focus:ring-0 placeholder-ink-gray-4 disabled:opacity-60",
            placeholder: "Add caption",
            disabled: !$setup.isEditable,
            onInput: _cache[3] || (_cache[3] = (e) => $setup.props.updateAttributes({ title: e.target.value })),
            onKeydown: $setup.handleKeydown
          }, null, 40, _hoisted_6$3)) : createCommentVNode("v-if", true)
        ],
        38
        /* CLASS, STYLE, NEED_HYDRATION */
      )
    ]),
    _: 1
    /* STABLE */
  });
}
_sfc_main$Z.__file = "src/components/TextEditor/extensions/iframe/IframeNodeView.vue";
const IframeNodeView = /* @__PURE__ */ _export_sfc(_sfc_main$Z, [["render", _sfc_render$T], ["__scopeId", "data-v-18a67733"], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/TextEditor/extensions/iframe/IframeNodeView.vue"]]);
const IframeExtension = Node.create({
  name: "iframe",
  group: "block",
  selectable: true,
  draggable: true,
  atom: true,
  addOptions() {
    return {
      allowedDomains: ALLOWED_DOMAINS,
      blockedDomains: [],
      HTMLAttributes: {}
    };
  },
  addAttributes() {
    return {
      src: {
        default: null,
        parseHTML: (element) => element.getAttribute("src"),
        renderHTML: (attributes) => ({
          src: attributes.src
        })
      },
      width: {
        default: null,
        parseHTML: (element) => {
          const width = element.getAttribute("width");
          return width ? parseInt(width, 10) : null;
        },
        renderHTML: (attributes) => ({
          width: attributes.width ? String(attributes.width) : null
        })
      },
      height: {
        default: null,
        parseHTML: (element) => {
          const height = element.getAttribute("height");
          return height ? parseInt(height, 10) : null;
        },
        renderHTML: (attributes) => ({
          height: attributes.height ? String(attributes.height) : null
        })
      },
      aspectRatio: {
        default: 9 / 16,
        // Default 16:9 aspect ratio
        parseHTML: () => null,
        // Don't parse from HTML
        renderHTML: () => ({})
        // Don't render to HTML
      },
      align: {
        default: "center",
        parseHTML: (element) => {
          const align = (element.getAttribute("data-align") || element.getAttribute("align") || "left").toLowerCase();
          if (["left", "center", "right"].includes(align)) {
            return align;
          }
          return "left";
        },
        renderHTML: (attributes) => {
          return {
            "data-align": attributes.align || "center"
          };
        }
      },
      title: {
        default: null,
        parseHTML: (element) => element.getAttribute("title"),
        renderHTML: (attributes) => ({
          title: attributes.title
        })
      },
      frameborder: {
        default: "0",
        renderHTML: () => ({
          frameborder: "0"
        })
      },
      allowfullscreen: {
        default: "true",
        renderHTML: () => ({
          allowfullscreen: "true"
        })
      },
      sandbox: {
        default: "allow-scripts allow-same-origin allow-popups allow-forms",
        renderHTML: (attributes) => ({
          sandbox: attributes.sandbox
        })
      },
      interactive: {
        default: false,
        parseHTML: (el) => el.getAttribute("data-interactive") === "true",
        renderHTML: (attrs) => ({
          "data-interactive": attrs.interactive ? "true" : "false"
        })
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "iframe[src]",
        getAttrs: (element) => {
          const src = element.getAttribute("src");
          const width = element.getAttribute("width");
          const height = element.getAttribute("height");
          const title = element.getAttribute("title");
          const align = element.getAttribute("data-align");
          return {
            src,
            width: width ? parseInt(width, 10) : null,
            height: height ? parseInt(height, 10) : null,
            title: title || null,
            align: align || "center"
          };
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return [
      "iframe",
      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, {
        loading: "lazy",
        referrerpolicy: "no-referrer-when-downgrade"
      })
    ];
  },
  addNodeView() {
    return VueNodeViewRenderer(IframeNodeView);
  },
  addCommands() {
    return {
      setIframeAlign: (align) => ({ commands: commands2 }) => {
        return commands2.updateAttributes(this.name, { align });
      },
      setIframe: (options) => ({ commands: commands2, editor }) => {
        if (!validateURL(options.src, this.options)) {
          return false;
        }
        const processedSrc = processURL(options.src);
        const editorElement = editor.view.dom;
        const editorWidth = (editorElement == null ? void 0 : editorElement.clientWidth) || 800;
        const optimalDimensions = getOptimalDimensions(processedSrc, editorWidth);
        const attrs = {
          src: processedSrc,
          width: options.width || optimalDimensions.width,
          height: options.height || optimalDimensions.height,
          title: options.title,
          align: options.align || "center",
          aspectRatio: optimalDimensions.height / optimalDimensions.width,
          interactive: options.interactive
        };
        return commands2.insertContent({
          type: this.name,
          attrs
        });
      },
      insertIframeURL: (url) => ({ commands: commands2 }) => {
        const processedUrl = processURL(url);
        return commands2.setIframe({ src: processedUrl });
      },
      openIframeDialog: () => ({ editor }) => {
        const event = new CustomEvent("iframe:open-dialog", {
          detail: { editor }
        });
        editor.view.dom.dispatchEvent(event);
        return true;
      }
    };
  },
  // Add ProseMirror plugin for paste handling
  addProseMirrorPlugins() {
    const extensionThis = this;
    return [
      new Plugin({
        key: new PluginKey("iframe-paste-handler"),
        props: {
          handlePaste: (view, event, slice) => {
            var _a, _b;
            const text = (_a = event.clipboardData) == null ? void 0 : _a.getData("text/plain");
            const html = (_b = event.clipboardData) == null ? void 0 : _b.getData("text/html");
            if (html) {
              const iframeData = parseIframeFromHTML(html);
              if (iframeData) {
                return createIframeNode(view, extensionThis, iframeData.src, iframeData.width, iframeData.height, iframeData.title);
              }
            }
            if (text && text.includes("<iframe")) {
              const iframeData = parseIframeFromHTML(text);
              if (iframeData) {
                return createIframeNode(view, extensionThis, iframeData.src, iframeData.width, iframeData.height, iframeData.title);
              }
            }
            if (text) {
              const urlPattern = /^https?:\/\/(?:www\.)?(?:youtube\.com\/watch\?v=[\w-]+|youtu\.be\/[\w-]+|youtube\.com\/embed\/[\w-]+|vimeo\.com\/\d+|player\.vimeo\.com\/video\/\d+|codepen\.io\/[\w-]+\/pen\/[\w-]+|codesandbox\.io\/[\w\/.-]+|figma\.com\/[\w\/.-]+|embed\.figma\.com\/[\w\/.-]+)$/;
              if (urlPattern.test(text.trim())) {
                return createIframeNode(view, extensionThis, text.trim());
              }
            }
            return false;
          }
        }
      })
    ];
  }
});
function parseIframeFromHTML(html) {
  try {
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, "text/html");
    const iframe = doc.querySelector("iframe");
    if (!iframe) {
      const iframeMatch = html.match(/<iframe[^>]*src=["']([^"']+)["'][^>]*>/i);
      if (iframeMatch) {
        const src2 = iframeMatch[1];
        const widthMatch = html.match(/width=["'](\d+)["']/i);
        const heightMatch = html.match(/height=["'](\d+)["']/i);
        const titleMatch = html.match(/title=["']([^"']+)["']/i);
        return {
          src: src2,
          width: widthMatch ? parseInt(widthMatch[1], 10) : void 0,
          height: heightMatch ? parseInt(heightMatch[1], 10) : void 0,
          title: titleMatch ? titleMatch[1] : void 0
        };
      }
      return null;
    }
    const src = iframe.getAttribute("src");
    if (!src) return null;
    const width = iframe.getAttribute("width") ? parseInt(iframe.getAttribute("width"), 10) : void 0;
    const height = iframe.getAttribute("height") ? parseInt(iframe.getAttribute("height"), 10) : void 0;
    const title = iframe.getAttribute("title") || void 0;
    return { src, width, height, title };
  } catch (error) {
    return null;
  }
}
function createIframeNode(view, extensionThis, src, width, height, title) {
  const shouldCreateEmbed = confirm(`Do you want to embed this content?

URL: ${src}

Click "OK" to create an embed, or "Cancel" to paste as plain text.`);
  if (!shouldCreateEmbed) {
    return false;
  }
  if (!validateURL(src, extensionThis.options)) {
    return false;
  }
  console.log("URL validated, creating iframe node");
  const processedUrl = processURL(src);
  const editorElement = extensionThis.editor.view.dom;
  const editorWidth = (editorElement == null ? void 0 : editorElement.clientWidth) || 800;
  const finalWidth = width || getOptimalDimensions(processedUrl, editorWidth).width;
  const finalHeight = height || getOptimalDimensions(processedUrl, editorWidth).height;
  const attrs = {
    src: processedUrl,
    width: finalWidth,
    height: finalHeight,
    title,
    align: "center",
    aspectRatio: finalHeight / finalWidth
  };
  const node = view.state.schema.nodes.iframe.create(attrs);
  const tr = view.state.tr.replaceSelectionWith(node);
  view.dispatch(tr);
  return true;
}
function isValidUrl(url) {
  if (url === "") {
    return true;
  }
  if (/^(https?:\/\/|mailto:|tel:|\/\/)[^\s]+$/i.test(url)) {
    return true;
  }
  if (/^([./#][^\s]*)$/i.test(url)) {
    return true;
  }
  if (/^[\w\-]([\w\-./#?=&%]*)$/i.test(url)) {
    return true;
  }
  return false;
}
const _sfc_main$Y = /* @__PURE__ */ defineComponent({
  __name: "EditLink",
  props: {
    href: { type: String, required: true }
  },
  emits: ["updateHref", "close"],
  setup(__props, { expose: __expose, emit: __emit }) {
    __expose();
    const props = __props;
    const emit = __emit;
    const _href = ref(props.href);
    const input = useTemplateRef("input");
    const submitLink = () => {
      if (_href.value === "" || isValidUrl(_href.value)) {
        emit("updateHref", _href.value);
      }
    };
    onMounted(async () => {
      var _a;
      await nextTick();
      if ((_a = input.value) == null ? void 0 : _a.el) {
        input.value.el.focus();
        input.value.el.select();
      }
    });
    const __returned__ = { props, emit, _href, input, submitLink, Button, TextInput, Tooltip: __unplugin_components_0$2, get LucideCheck() {
      return LucideCheck;
    }, get LucideX() {
      return LucideX;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$_ = { class: "p-2 flex min-w-72 items-center gap-2 bg-surface-white shadow-xl rounded-lg" };
const _hoisted_2$a = { class: "shrink-0 flex items-center gap-2" };
function _sfc_render$S(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$_, [
    createVNode($setup["TextInput"], {
      ref: "input",
      type: "text",
      class: "w-full",
      placeholder: "https://example.com",
      modelValue: $setup._href,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup._href = $event),
      onKeydown: [
        withKeys($setup.submitLink, ["enter"]),
        _cache[1] || (_cache[1] = withKeys(($event) => _ctx.$emit("close"), ["esc"]))
      ]
    }, null, 8, ["modelValue"]),
    createBaseVNode("div", _hoisted_2$a, [
      createVNode($setup["Tooltip"], {
        text: "Submit",
        placement: "top"
      }, {
        default: withCtx(() => [
          createVNode($setup["Button"], {
            label: "Submit",
            onClick: $setup.submitLink
          }, {
            icon: withCtx(() => [
              createVNode($setup["LucideCheck"], { class: "size-4" })
            ]),
            _: 1
            /* STABLE */
          })
        ]),
        _: 1
        /* STABLE */
      }),
      createVNode($setup["Tooltip"], {
        text: "Remove link",
        placement: "top"
      }, {
        default: withCtx(() => [
          createVNode($setup["Button"], {
            label: "Remove link",
            onClick: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("updateHref", ""))
          }, {
            icon: withCtx(() => [
              createVNode($setup["LucideX"], { class: "size-4" })
            ]),
            _: 1
            /* STABLE */
          })
        ]),
        _: 1
        /* STABLE */
      })
    ])
  ]);
}
_sfc_main$Y.__file = "src/components/TextEditor/EditLink.vue";
const EditLink = /* @__PURE__ */ _export_sfc(_sfc_main$Y, [["render", _sfc_render$S], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/TextEditor/EditLink.vue"]]);
function linkPasteHandler(options) {
  return new Plugin({
    key: new PluginKey("handlePasteLink"),
    props: {
      handlePaste: (view, event, slice) => {
        const { state } = view;
        const { selection } = state;
        const { empty } = selection;
        if (empty) {
          return false;
        }
        let textContent = "";
        slice.content.forEach((node) => {
          textContent += node.textContent;
        });
        if (!textContent) {
          return false;
        }
        let link = isValidUrl(textContent) ? textContent : null;
        if (!link) {
          return false;
        }
        return options.editor.chain().setTextSelection({ from: selection.from, to: selection.to }).setLink({ href: link }).setTextSelection(selection.to).command(({ tr }) => {
          tr.setStoredMarks([]);
          return true;
        }).run();
      }
    }
  });
}
const LinkExtension = Link$1.extend({
  addOptions() {
    var _a;
    return {
      ...(_a = this.parent) == null ? void 0 : _a.call(this),
      openOnClick: false,
      autolink: true,
      defaultProtocol: "https",
      linkOnPaste: false
    };
  },
  addCommands() {
    var _a;
    return {
      ...(_a = this.parent) == null ? void 0 : _a.call(this),
      openLinkEditor: () => ({ editor }) => {
        const { state } = editor;
        const { from, to } = state.selection;
        const { doc } = state;
        let range = void 0;
        let mark = void 0;
        let shouldDelayPopover = false;
        if (from === to) {
          const $pos = state.selection.$from;
          const markRange = getMarkRange($pos, this.type);
          if (markRange) {
            range = markRange;
            mark = doc.resolve(markRange.from).marks().find((m) => m.type === this.type);
            editor.chain().setTextSelection({ from: markRange.from, to: markRange.to }).run();
            shouldDelayPopover = true;
          } else {
            return false;
          }
        } else {
          range = { from, to };
          mark = doc.resolve(from).marks().find((m) => m.type === this.type);
        }
        if (!range) return false;
        const existingHref = (mark == null ? void 0 : mark.attrs.href) || "";
        const selectionFrom = range.from;
        const selectionTo = range.to;
        const showPopover = () => {
          openLinkEditor(existingHref, editor.view.dom).then((href) => {
            if (href === null) {
              return;
            }
            let chain = editor.chain().focus(null, { scrollIntoView: false });
            if (href === "") {
              chain.setTextSelection({ from: selectionFrom, to: selectionTo }).unsetLink().command(({ tr }) => {
                tr.setStoredMarks([]);
                return true;
              }).run();
              return;
            }
            chain = chain.setTextSelection({ from: selectionFrom, to: selectionTo }).setLink({ href }).setTextSelection(selectionTo).command(({ tr }) => {
              tr.setStoredMarks([]);
              return true;
            });
            const posAfterLink = selectionTo;
            const charAfter = posAfterLink < doc.content.size ? doc.textBetween(posAfterLink, posAfterLink + 1) : null;
            if (charAfter === null || charAfter !== " ") {
              chain = chain.insertContent(" ");
            }
            chain.run();
          }).catch(() => {
          });
        };
        if (shouldDelayPopover) {
          requestAnimationFrame(showPopover);
        } else {
          showPopover();
        }
        return true;
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-k": () => this.editor.commands.openLinkEditor()
    };
  },
  addProseMirrorPlugins() {
    var _a;
    let plugins = ((_a = this.parent) == null ? void 0 : _a.call(this)) || [];
    plugins.push(
      linkPasteHandler({
        editor: this.editor,
        defaultProtocol: this.options.defaultProtocol,
        type: this.type
      })
    );
    plugins.push(
      clearLinkOnBoundaryPlugin({
        editor: this.editor,
        type: this.type
      })
    );
    return plugins;
  }
});
function openLinkEditor(href, anchor) {
  return new Promise((resolve, reject) => {
    const container = document.createElement("div");
    document.body.appendChild(container);
    let virtualReference;
    const selection = window.getSelection();
    if (selection && selection.rangeCount > 0) {
      const range = selection.getRangeAt(0);
      const rect = range.getBoundingClientRect();
      const isCollapsed = range.collapsed;
      virtualReference = {
        getBoundingClientRect: () => ({
          width: 0,
          height: rect.height,
          top: rect.top,
          right: isCollapsed ? rect.left : rect.right,
          bottom: rect.bottom,
          left: rect.left,
          x: rect.left,
          y: rect.top,
          toJSON: () => {
          }
        })
      };
    } else {
      virtualReference = {
        getBoundingClientRect: () => anchor.getBoundingClientRect()
      };
    }
    let app = null;
    let tippyInstance = null;
    let isDestroyed = false;
    let promiseSettled = false;
    const settlePromise = (action, value) => {
      if (promiseSettled) return;
      promiseSettled = true;
      if (action === "resolve") {
        resolve(value);
      } else {
        reject(value);
      }
    };
    const destroy = () => {
      if (isDestroyed) return;
      isDestroyed = true;
      settlePromise("reject", "Link editing cancelled or destroyed");
      requestAnimationFrame(() => {
        tippyInstance == null ? void 0 : tippyInstance.destroy();
        app == null ? void 0 : app.unmount();
        container == null ? void 0 : container.remove();
        app = null;
        tippyInstance = null;
      });
    };
    app = createApp({
      render() {
        return h(EditLink, {
          href,
          onClose: () => {
            settlePromise("reject", "Link editing cancelled");
            destroy();
          },
          onUpdateHref: (newHref) => {
            settlePromise("resolve", newHref);
            destroy();
          }
        });
      }
    });
    app.mount(container);
    tippyInstance = tippy(anchor, {
      getReferenceClientRect: () => virtualReference.getBoundingClientRect(),
      content: container,
      trigger: "manual",
      interactive: true,
      appendTo: document.body,
      placement: "top",
      arrow: false,
      theme: "link-editor",
      maxWidth: "none",
      onHidden() {
        destroy();
      },
      hideOnClick: true,
      interactiveDebounce: 75
    });
    if (!tippyInstance) {
      container.remove();
      settlePromise("reject", "Failed to initialize link editor tooltip");
      return;
    }
    tippyInstance.show();
  });
}
function clearLinkOnBoundaryPlugin(options) {
  return new Plugin({
    key: new PluginKey("clearLinkMarkOnBoundary"),
    appendTransaction: (transactions, oldState, newState) => {
      if (!options.editor.isEditable) {
        return null;
      }
      const { tr, doc, selection, storedMarks } = newState;
      const { $from, empty } = selection;
      if (!empty || !storedMarks || storedMarks.length === 0) {
        return null;
      }
      const linkMarkType = options.type;
      const hasStoredLinkMark = storedMarks.some(
        (mark) => mark.type === linkMarkType
      );
      if (!hasStoredLinkMark) {
        return null;
      }
      const marksAtCursor = $from.marks();
      const activeLinkAtCursor = marksAtCursor.some(
        (mark) => mark.type === linkMarkType
      );
      if (activeLinkAtCursor) {
        return null;
      }
      return tr.setStoredMarks([]);
    }
  });
}
const textColorHexMap = {
  black: "#000000",
  red: "#dc2626",
  blue: "#1579D0",
  green: "#16a34a",
  yellow: "#ca8a04",
  orange: "#ea580c",
  purple: "#9333ea",
  pink: "#db2777",
  gray: "#6b7280",
  indigo: "#4f46e5",
  teal: "#0d9488",
  cyan: "#06b6d4"
};
const highlightColorHexMap = {
  red: "#fecaca",
  blue: "#bfdbfe",
  green: "#bbf7d0",
  yellow: "#fef08a",
  orange: "#fed7aa",
  purple: "#e9d5ff",
  pink: "#fbcfe8",
  gray: "#e5e7eb",
  indigo: "#c7d2fe",
  teal: "#99f6e4",
  cyan: "#a5f3fc"
};
const legacyTextColorMap = {
  "#1F272E": "gray",
  "#ca8a04": "yellow",
  "#ea580c": "orange",
  "#dc2626": "red",
  "#16a34a": "green",
  "#1579D0": "blue",
  "#9333ea": "purple",
  "#db2777": "pink"
};
const legacyHighlightColorMap = {
  "#fef9c3": "yellow",
  "#ffedd5": "orange",
  "#fee2e2": "red",
  "#dcfce7": "green",
  "#D3E9FC": "blue",
  "#f3e8ff": "purple",
  "#fce7f3": "pink"
};
function getClosestNamedColor(color, allowedColors, colorMap, legacyMap) {
  if (legacyMap && color.startsWith("#") && legacyMap[color]) {
    return legacyMap[color];
  }
  let r = 0, g = 0, b = 0;
  if (color.startsWith("#")) {
    const hex = color.substring(1);
    if (hex.length === 6) {
      r = parseInt(hex.substring(0, 2), 16);
      g = parseInt(hex.substring(2, 4), 16);
      b = parseInt(hex.substring(4, 6), 16);
    }
  } else if (color.startsWith("rgb")) {
    const rgbMatch = /rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/i.exec(color);
    if (rgbMatch) {
      r = parseInt(rgbMatch[1], 10);
      g = parseInt(rgbMatch[2], 10);
      b = parseInt(rgbMatch[3], 10);
    }
  }
  if (isNaN(r) || isNaN(g) || isNaN(b)) {
    return null;
  }
  let closestColor = null;
  let minDistance = Infinity;
  for (const colorName of allowedColors) {
    const namedHex = colorMap[colorName];
    if (!namedHex) continue;
    const namedHexClean = namedHex.startsWith("#") ? namedHex.substring(1) : namedHex;
    if (namedHexClean.length !== 6) continue;
    const nr = parseInt(namedHexClean.substring(0, 2), 16);
    const ng = parseInt(namedHexClean.substring(2, 4), 16);
    const nb = parseInt(namedHexClean.substring(4, 6), 16);
    const distance = Math.sqrt(
      Math.pow(r - nr, 2) + Math.pow(g - ng, 2) + Math.pow(b - nb, 2)
    );
    if (distance < minDistance) {
      minDistance = distance;
      closestColor = colorName;
    }
  }
  return closestColor;
}
function extractColorFromStyle(style, allowedColors, colorMap = textColorHexMap, legacyMap = legacyTextColorMap, property = "color") {
  const allColorsInMap = Object.keys(colorMap);
  const hexColorMatch = new RegExp(`${property}:\\s*(#[0-9a-f]{6})`, "i").exec(
    style
  );
  if (hexColorMatch && hexColorMatch[1]) {
    const closestOverallColor = getClosestNamedColor(
      hexColorMatch[1],
      allColorsInMap,
      // Search in all colors from the map
      colorMap,
      legacyMap
    );
    if (closestOverallColor) {
      if (allowedColors.includes(closestOverallColor)) {
        if (closestOverallColor === "gray") {
          return null;
        }
        return closestOverallColor;
      }
    }
  }
  const rgbColorMatch = new RegExp(
    `${property}:\\s*(rgb\\(\\s*\\d+\\s*,\\s*\\d+\\s*,\\s*\\d+\\s*\\))`,
    "i"
  ).exec(style);
  if (rgbColorMatch && rgbColorMatch[1]) {
    const closestOverallColor = getClosestNamedColor(
      rgbColorMatch[1],
      allColorsInMap,
      // Search in all colors from the map
      colorMap,
      legacyMap
    );
    if (closestOverallColor) {
      if (allowedColors.includes(closestOverallColor)) {
        if (closestOverallColor === "gray") {
          return null;
        }
        return closestOverallColor;
      }
    }
  }
  return null;
}
function extractTextColorFromStyle(style, allowedColors) {
  return extractColorFromStyle(
    style,
    allowedColors,
    textColorHexMap,
    legacyTextColorMap,
    "color"
  );
}
function extractHighlightColorFromStyle(style, allowedColors) {
  return extractColorFromStyle(
    style,
    allowedColors,
    highlightColorHexMap,
    legacyHighlightColorMap,
    "background-color"
  );
}
const NamedColorExtension = Extension.create({
  name: "namedColor",
  addOptions() {
    return {
      types: ["textStyle"],
      colors: [
        "red",
        "blue",
        "green",
        "yellow",
        "orange",
        "purple",
        "pink",
        "gray",
        "teal",
        "cyan"
      ]
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          color: {
            default: null,
            parseHTML: (element) => {
              const style = element.getAttribute("style");
              if (style) {
                const colorMatch = style.match(
                  /color:\s*var\(--prose-color-(\w+)\)/
                );
                if (colorMatch && this.options.colors.includes(colorMatch[1])) {
                  return colorMatch[1];
                }
                const extractedColor = extractTextColorFromStyle(
                  style,
                  this.options.colors
                );
                if (extractedColor) {
                  return extractedColor;
                }
              }
              return null;
            },
            renderHTML: (attributes) => {
              if (!attributes.color || !this.options.colors.includes(attributes.color)) {
                return {};
              }
              return {
                style: `color: var(--prose-color-${attributes.color})`
              };
            }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setColorByName: (colorName) => ({ chain, state, editor }) => {
        if (!this.options.colors.includes(colorName)) {
          console.warn(
            `Color "${colorName}" is not in the allowed colors list`
          );
          return false;
        }
        const { to, empty } = state.selection;
        let commandChain = chain().setMark("textStyle", { color: colorName });
        if (!empty) {
          commandChain = commandChain.setTextSelection(to).command(({ tr }) => {
            tr.setStoredMarks([]);
            return true;
          });
        }
        return commandChain.focus().run();
      },
      unsetColor: () => ({ chain }) => {
        return chain().setMark("textStyle", { color: null }).removeEmptyTextStyle().run();
      }
    };
  }
});
const NamedHighlightExtension = Mark.create({
  name: "namedHighlight",
  addOptions() {
    return {
      HTMLAttributes: {},
      multicolor: true,
      colors: [
        "yellow",
        "blue",
        "green",
        "red",
        "orange",
        "purple",
        "pink",
        "gray",
        "teal",
        "cyan"
      ]
    };
  },
  addAttributes() {
    if (!this.options.multicolor) {
      return {};
    }
    return {
      color: {
        default: null,
        parseHTML: (element) => {
          const style = element.getAttribute("style");
          if (style) {
            const highlightMatch = style.match(
              /background-color:\s*var\(--prose-highlight-(\w+)\)/
            );
            if (highlightMatch && this.options.colors.includes(highlightMatch[1])) {
              return highlightMatch[1];
            }
          }
          const legacyColorAttr = element.getAttribute("data-color");
          if (legacyColorAttr) {
            const closestColor = getClosestNamedColor(
              legacyColorAttr,
              this.options.colors,
              highlightColorHexMap,
              legacyHighlightColorMap
            );
            if (closestColor) {
              return closestColor;
            }
          }
          if (style) {
            const extractedColor = extractHighlightColorFromStyle(
              style,
              this.options.colors
            );
            if (extractedColor) {
              return extractedColor;
            }
          }
          return null;
        },
        renderHTML: (attributes) => {
          if (!attributes.color || !this.options.colors.includes(attributes.color)) {
            return {};
          }
          return {
            style: `background-color: var(--prose-highlight-${attributes.color})`
          };
        }
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "mark"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return [
      "mark",
      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),
      0
    ];
  },
  addCommands() {
    return {
      setHighlightByName: (colorName) => ({ chain, commands: commands2, editor, state }) => {
        if (!this.options.colors.includes(colorName)) {
          console.warn(
            `Highlight color "${colorName}" is not in the allowed colors list`
          );
          return false;
        }
        const { from, to, empty } = state.selection;
        let commandChain = chain();
        if (this.options.multicolor) {
          commandChain = commandChain.setMark(this.name, { color: colorName });
        } else {
          commandChain = commandChain.setMark(this.name);
        }
        if (!empty) {
          commandChain = commandChain.setTextSelection(to).command(({ tr }) => {
            tr.setStoredMarks([]);
            return true;
          });
        }
        return commandChain.focus().run();
      },
      toggleHighlightByName: (colorName) => ({ chain, commands: commands2, editor, state }) => {
        if (!this.options.colors.includes(colorName)) {
          console.warn(
            `Highlight color "${colorName}" is not in the allowed colors list`
          );
          return false;
        }
        const { to, empty } = state.selection;
        const highlightAttributes = this.options.multicolor ? { color: colorName } : void 0;
        const isCurrentlyActive = editor.isActive(
          this.name,
          highlightAttributes
        );
        let commandChain = chain().toggleMark(this.name, highlightAttributes);
        if (!empty && !isCurrentlyActive) {
          commandChain = commandChain.setTextSelection(to).command(({ tr }) => {
            tr.setStoredMarks([]);
            return true;
          });
        }
        return commandChain.focus().run();
      },
      unsetHighlight: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  }
});
const _sfc_main$X = {
  components: {
    NodeViewWrapper,
    NodeViewContent
  },
  props: nodeViewProps,
  computed: {
    selectedLanguage: {
      get() {
        return this.node.attrs.language;
      },
      set(language) {
        this.updateAttributes({ language });
      }
    },
    languages() {
      let supportedLanguages = this.extension.options.lowlight.listLanguages();
      return supportedLanguages.map((language) => {
        return {
          label: language,
          value: language
        };
      }).concat([{ label: "html", value: "xml" }]).sort((a, b) => a.label.localeCompare(b.label));
    }
  }
};
const _hoisted_1$Z = { class: "code-block-container" };
const _hoisted_2$9 = ["value"];
function _sfc_render$R(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_node_view_content = resolveComponent("node-view-content");
  const _component_node_view_wrapper = resolveComponent("node-view-wrapper");
  return openBlock(), createBlock(_component_node_view_wrapper, null, {
    default: withCtx(() => [
      createBaseVNode("div", _hoisted_1$Z, [
        withDirectives(createBaseVNode(
          "select",
          {
            class: "language-selector form-select py-0",
            contenteditable: "false",
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $options.selectedLanguage = $event)
          },
          [
            _cache[1] || (_cache[1] = createBaseVNode(
              "option",
              { value: null },
              "auto",
              -1
              /* HOISTED */
            )),
            _cache[2] || (_cache[2] = createBaseVNode(
              "option",
              { disabled: "" },
              "—",
              -1
              /* HOISTED */
            )),
            (openBlock(true), createElementBlock(
              Fragment,
              null,
              renderList($options.languages, (language, index) => {
                return openBlock(), createElementBlock("option", {
                  value: language.value,
                  key: language.value
                }, toDisplayString(language.label), 9, _hoisted_2$9);
              }),
              128
              /* KEYED_FRAGMENT */
            ))
          ],
          512
          /* NEED_PATCH */
        ), [
          [vModelSelect, $options.selectedLanguage]
        ]),
        createBaseVNode("pre", null, [
          createBaseVNode("code", null, [
            createVNode(_component_node_view_content)
          ])
        ])
      ])
    ]),
    _: 1
    /* STABLE */
  });
}
_sfc_main$X.__file = "src/components/TextEditor/CodeBlockComponent.vue";
const CodeBlockComponent = /* @__PURE__ */ _export_sfc(_sfc_main$X, [["render", _sfc_render$R], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/TextEditor/CodeBlockComponent.vue"]]);
function createSuggestionExtension(options) {
  return Extension.create({
    name: options.name,
    addOptions() {
      const customOptions = options.addOptions ? options.addOptions.call(this) : {};
      return {
        ...customOptions,
        suggestion: {
          char: options.char,
          pluginKey: options.pluginKey,
          items: options.items,
          command: options.command,
          allowSpaces: options.allowSpaces,
          startOfLine: options.startOfLine,
          decorationTag: options.decorationTag || "span",
          decorationClass: options.decorationClass || "suggestion",
          render: () => {
            let component;
            let popup;
            return {
              onStart: (props) => {
                component = new VueRenderer(options.component, {
                  editor: props.editor,
                  props
                });
                if (!props.clientRect || !component.element) {
                  return;
                }
                const defaultTippyOptions = {
                  getReferenceClientRect: props.clientRect,
                  appendTo: () => document.body,
                  content: component.element,
                  showOnCreate: true,
                  interactive: true,
                  trigger: "manual",
                  placement: "bottom-start"
                };
                popup = tippy("body", {
                  ...defaultTippyOptions,
                  ...options.tippyOptions
                });
              },
              onUpdate(props) {
                component == null ? void 0 : component.updateProps(props);
                if (!props.clientRect) {
                  return;
                }
                if (popup && popup[0]) {
                  popup[0].setProps({
                    getReferenceClientRect: props.clientRect
                  });
                }
              },
              onKeyDown(props) {
                if (props.event.key === "Escape") {
                  if (popup && popup[0]) {
                    popup[0].hide();
                  }
                  return true;
                }
                if (component && component.ref && typeof component.ref.onKeyDown === "function") {
                  return component.ref.onKeyDown(props);
                }
                return false;
              },
              onExit() {
                if (popup && popup[0]) {
                  popup[0].destroy();
                }
                if (component) {
                  component.destroy();
                }
                popup = null;
                component = null;
              }
            };
          }
        }
      };
    },
    addProseMirrorPlugins() {
      return [
        Suggestion({
          editor: this.editor,
          ...this.options.suggestion
        })
      ];
    }
  });
}
const _sfc_main$W = /* @__PURE__ */ defineComponent({
  __name: "SuggestionList",
  props: {
    items: {
      type: Array,
      required: true
    },
    command: {
      type: Function,
      required: true
    },
    containerClass: {
      type: String,
      default: ""
    },
    itemClass: {
      type: String,
      default: ""
    },
    showNoResults: {
      type: Boolean,
      default: false
    }
  },
  setup(__props, { expose: __expose }) {
    const props = __props;
    const selectedIndex = ref(0);
    const container = ref(null);
    const itemRefs = ref([]);
    onBeforeUpdate(() => {
      itemRefs.value = [];
    });
    const scrollIntoView = () => {
      nextTick(() => {
        const selectedElement = itemRefs.value[selectedIndex.value];
        if (selectedElement) {
          selectedElement.scrollIntoView({ block: "nearest" });
        }
      });
    };
    const selectItem = (index) => {
      const item = props.items[index];
      if (item) {
        props.command(item);
      }
    };
    const onKeyDown = ({ event }) => {
      if (!props.items.length) return false;
      if (event.key === "ArrowUp") {
        upHandler();
        return true;
      }
      if (event.key === "ArrowDown") {
        downHandler();
        return true;
      }
      if (event.key === "Enter") {
        enterHandler();
        return true;
      }
      return false;
    };
    const upHandler = () => {
      selectedIndex.value = (selectedIndex.value + props.items.length - 1) % props.items.length;
      scrollIntoView();
    };
    const downHandler = () => {
      selectedIndex.value = (selectedIndex.value + 1) % props.items.length;
      scrollIntoView();
    };
    const enterHandler = () => {
      selectItem(selectedIndex.value);
    };
    watch(
      () => props.items,
      () => {
        selectedIndex.value = 0;
      }
    );
    __expose({
      onKeyDown
    });
    const __returned__ = { props, selectedIndex, container, itemRefs, scrollIntoView, selectItem, onKeyDown, upHandler, downHandler, enterHandler };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$Y = ["onClick", "onMouseover"];
const _hoisted_2$8 = {
  key: 0,
  class: "px-3 py-1.5 text-sm text-ink-gray-5"
};
function _sfc_render$Q(_ctx, _cache, $props, $setup, $data, $options) {
  return $props.items.length ? (openBlock(), createElementBlock(
    "div",
    {
      key: 0,
      ref: "container",
      class: normalizeClass(["relative max-h-[300px] min-w-40 overflow-y-auto rounded-lg bg-surface-white p-1 text-base shadow-lg", $props.containerClass])
    },
    [
      (openBlock(true), createElementBlock(
        Fragment,
        null,
        renderList($props.items, (item, index) => {
          return openBlock(), createElementBlock("button", {
            key: index,
            ref_for: true,
            ref: (el) => {
              if (el) $setup.itemRefs[index] = el;
            },
            class: normalizeClass([
              "flex w-full items-center whitespace-nowrap rounded-md px-2 py-1.5 text-sm text-ink-gray-9",
              index === $setup.selectedIndex ? "bg-surface-gray-2" : "",
              $props.itemClass
            ]),
            onClick: ($event) => $setup.selectItem(index),
            onMouseover: ($event) => $setup.selectedIndex = index
          }, [
            renderSlot(_ctx.$slots, "default", {
              item,
              index
            }, () => [
              createBaseVNode(
                "span",
                null,
                toDisplayString(item.display || item.title || item.name),
                1
                /* TEXT */
              )
            ])
          ], 42, _hoisted_1$Y);
        }),
        128
        /* KEYED_FRAGMENT */
      )),
      !$props.items.length && $props.showNoResults ? (openBlock(), createElementBlock("div", _hoisted_2$8, " No results ")) : createCommentVNode("v-if", true)
    ],
    2
    /* CLASS */
  )) : createCommentVNode("v-if", true);
}
_sfc_main$W.__file = "src/components/TextEditor/extensions/suggestion/SuggestionList.vue";
const SuggestionList = /* @__PURE__ */ _export_sfc(_sfc_main$W, [["render", _sfc_render$Q], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/TextEditor/extensions/suggestion/SuggestionList.vue"]]);
function createMentionNode(component) {
  const config = {
    name: "mention",
    group: "inline",
    inline: true,
    selectable: true,
    atom: true,
    addOptions() {
      return {
        component: void 0
      };
    },
    addAttributes() {
      return {
        id: {
          default: null,
          parseHTML: (element) => element.getAttribute("data-id"),
          renderHTML: (attributes) => {
            if (!attributes.id) {
              return {};
            }
            return { "data-id": attributes.id };
          }
        },
        label: {
          default: null,
          parseHTML: (element) => element.getAttribute("data-label"),
          renderHTML: (attributes) => {
            if (!attributes.label) {
              return {};
            }
            return { "data-label": attributes.label };
          }
        }
      };
    },
    parseHTML() {
      return [
        {
          tag: 'span.mention[data-type="mention"]',
          getAttrs: (dom) => {
            const element = dom;
            return {
              id: element.getAttribute("data-id"),
              label: element.getAttribute("data-label")
            };
          }
        }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return [
        "span",
        mergeAttributes(HTMLAttributes, {
          class: "mention",
          "data-type": "mention"
        }),
        `@${HTMLAttributes["data-label"] || HTMLAttributes.id || ""}`
      ];
    }
  };
  if (component) {
    config.addNodeView = () => {
      return VueNodeViewRenderer(component);
    };
  }
  return Node.create(config);
}
const MentionSuggestionExtension = createSuggestionExtension({
  name: "mentionSuggestion",
  char: "@",
  pluginKey: new PluginKey("mentionSuggestion"),
  component: SuggestionList,
  addOptions() {
    return {
      mentions: []
    };
  },
  items: ({ query, editor }) => {
    const { mentions: _mentions } = editor.extensionManager.extensions.find(
      (ext) => ext.name === "mentionSuggestion"
    ).options;
    const mentions = toValue(_mentions);
    const filtered = mentions.filter(
      (mention) => mention.label.toLowerCase().startsWith(query.toLowerCase())
    ).slice(0, 10).map((mention) => ({
      ...mention,
      display: mention.label
    }));
    return filtered;
  },
  command: ({ editor, range, props }) => {
    const attributes = {
      id: props.id || props.value,
      label: props.label
    };
    editor.chain().focus().insertContentAt(range, [
      {
        type: "mention",
        attrs: attributes
      },
      {
        type: "text",
        text: " "
      }
    ]).run();
  },
  tippyOptions: {
    placement: "bottom-start",
    offset: [0, 8]
  },
  allowSpaces: false,
  decorationTag: "span",
  decorationClass: "mention-suggestion-active"
});
const MentionExtension = Extension.create({
  name: "mentionExtension",
  addOptions() {
    return {
      mentions: [],
      component: void 0
    };
  },
  addExtensions() {
    return [
      createMentionNode(this.options.component),
      MentionSuggestionExtension.configure({
        mentions: this.options.mentions
      })
    ];
  }
});
const _sfc_main$V = {
  name: "TipTapMenu",
  props: ["buttons"],
  inject: ["editor"],
  components: {
    Popover: __unplugin_components_1
  },
  methods: {
    onButtonClick(button) {
      button.action(this.editor);
    }
  }
};
const _hoisted_1$X = { class: "inline-flex bg-surface-white px-1 py-1" };
const _hoisted_2$7 = { class: "inline-flex items-center gap-1" };
const _hoisted_3$6 = {
  key: 0,
  class: "h-4 w-[2px] border-l"
};
const _hoisted_4$3 = {
  key: 1,
  class: "shrink-0"
};
const _hoisted_5$3 = ["onClick", "set"];
const _hoisted_6$2 = { key: 1 };
const _hoisted_7$2 = { class: "p-1.5 mt-2 rounded-lg bg-surface-modal shadow-2xl ring-1 ring-black ring-opacity-5 focus:outline-none" };
const _hoisted_8$2 = ["onClick"];
const _hoisted_9$1 = {
  key: 1,
  class: "whitespace-nowrap text-ink-gray-7"
};
const _hoisted_10$1 = ["onClick", "title"];
const _hoisted_11$1 = {
  key: 1,
  class: "inline-block h-4 min-w-[1rem] text-sm leading-4"
};
function _sfc_render$P(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Popover = __unplugin_components_1;
  return openBlock(), createElementBlock("div", _hoisted_1$X, [
    createBaseVNode("div", _hoisted_2$7, [
      (openBlock(true), createElementBlock(
        Fragment,
        null,
        renderList($props.buttons, (button) => {
          return openBlock(), createElementBlock(
            Fragment,
            {
              key: button.label
            },
            [
              button.type === "separator" ? (openBlock(), createElementBlock("div", _hoisted_3$6)) : button.map ? (openBlock(), createElementBlock("div", _hoisted_4$3, [
                createVNode(
                  _component_Popover,
                  null,
                  {
                    target: withCtx(({ togglePopover }) => [
                      createBaseVNode("button", {
                        class: "rounded px-2 py-1 text-base font-medium text-ink-gray-8 transition-colors hover:bg-surface-gray-2",
                        onClick: togglePopover,
                        set: _ctx.activeBtn = button.find((b) => b.isActive($options.editor)) || button[0]
                      }, [
                        _ctx.activeBtn.icon ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.activeBtn.icon), {
                          key: 0,
                          class: "h-4 w-4"
                        })) : (openBlock(), createElementBlock(
                          "span",
                          _hoisted_6$2,
                          toDisplayString(_ctx.activeBtn.label),
                          1
                          /* TEXT */
                        ))
                      ], 8, _hoisted_5$3)
                    ]),
                    body: withCtx(({ close }) => [
                      createBaseVNode("ul", _hoisted_7$2, [
                        (openBlock(true), createElementBlock(
                          Fragment,
                          null,
                          renderList(button, (option) => {
                            return withDirectives((openBlock(), createElementBlock(
                              "li",
                              null,
                              [
                                createBaseVNode("button", {
                                  class: "w-full h-7 rounded px-2 text-base flex items-center gap-2 hover:bg-surface-gray-3",
                                  onClick: () => {
                                    $options.onButtonClick(option);
                                    close();
                                  }
                                }, [
                                  option.icon ? (openBlock(), createBlock(resolveDynamicComponent(option.icon), {
                                    key: 0,
                                    class: "size-4 flex-shrink-0 text-ink-gray-6"
                                  })) : createCommentVNode("v-if", true),
                                  option.label ? (openBlock(), createElementBlock(
                                    "span",
                                    _hoisted_9$1,
                                    toDisplayString(option.label),
                                    1
                                    /* TEXT */
                                  )) : createCommentVNode("v-if", true)
                                ], 8, _hoisted_8$2)
                              ],
                              512
                              /* NEED_PATCH */
                            )), [
                              [vShow, option.isDisabled ? !option.isDisabled($options.editor) : true]
                            ]);
                          }),
                          256
                          /* UNKEYED_FRAGMENT */
                        ))
                      ])
                    ]),
                    _: 2
                    /* DYNAMIC */
                  },
                  1024
                  /* DYNAMIC_SLOTS */
                )
              ])) : (openBlock(), createBlock(
                resolveDynamicComponent(button.component || "div"),
                mergeProps({
                  key: 2,
                  ref_for: true
                }, { editor: $options.editor }),
                {
                  default: withCtx((componentSlotProps) => [
                    createBaseVNode("button", {
                      class: normalizeClass(["flex rounded p-1 text-ink-gray-8 transition-colors", [
                        button.isActive($options.editor) || (componentSlotProps == null ? void 0 : componentSlotProps.isActive) ? "bg-surface-gray-3" : "hover:bg-surface-gray-2",
                        button.class
                      ]]),
                      onClick: ($event) => (componentSlotProps == null ? void 0 : componentSlotProps.onClick) ? componentSlotProps.onClick(button) : $options.onButtonClick(button),
                      title: button.label
                    }, [
                      button.icon ? (openBlock(), createBlock(resolveDynamicComponent(button.icon), {
                        key: 0,
                        class: "h-4 w-4"
                      })) : (openBlock(), createElementBlock(
                        "span",
                        _hoisted_11$1,
                        toDisplayString(button.text),
                        1
                        /* TEXT */
                      ))
                    ], 10, _hoisted_10$1)
                  ]),
                  _: 2
                  /* DYNAMIC */
                },
                1040
                /* FULL_PROPS, DYNAMIC_SLOTS */
              ))
            ],
            64
            /* STABLE_FRAGMENT */
          );
        }),
        128
        /* KEYED_FRAGMENT */
      ))
    ])
  ]);
}
_sfc_main$V.__file = "src/components/TextEditor/Menu.vue";
const __unplugin_components_0 = /* @__PURE__ */ _export_sfc(_sfc_main$V, [["render", _sfc_render$P], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/TextEditor/Menu.vue"]]);
const _sfc_main$U = {};
const _hoisted_1$W = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  width: "24",
  height: "24"
};
function _sfc_render$O(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$W, _cache[0] || (_cache[0] = [
    createBaseVNode(
      "path",
      {
        fill: "none",
        d: "M0 0H24V24H0z"
      },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      {
        d: "M13 20h-2v-7H4v7H2V4h2v7h7V4h2v16zm8-12v12h-2v-9.796l-2 .536V8.67L19.5 8H21z",
        fill: "currentColor"
      },
      null,
      -1
      /* HOISTED */
    )
  ]));
}
_sfc_main$U.__file = "src/components/TextEditor/icons/h-1.vue";
const H1 = /* @__PURE__ */ _export_sfc(_sfc_main$U, [["render", _sfc_render$O], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/TextEditor/icons/h-1.vue"]]);
const _sfc_main$T = {};
const _hoisted_1$V = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  width: "24",
  height: "24"
};
function _sfc_render$N(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$V, _cache[0] || (_cache[0] = [
    createBaseVNode(
      "path",
      {
        fill: "none",
        d: "M0 0H24V24H0z"
      },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      {
        d: "M4 4v7h7V4h2v16h-2v-7H4v7H2V4h2zm14.5 4c2.071 0 3.75 1.679 3.75 3.75 0 .857-.288 1.648-.772 2.28l-.148.18L18.034 18H22v2h-7v-1.556l4.82-5.546c.268-.307.43-.709.43-1.148 0-.966-.784-1.75-1.75-1.75-.918 0-1.671.707-1.744 1.606l-.006.144h-2C14.75 9.679 16.429 8 18.5 8z",
        fill: "currentColor"
      },
      null,
      -1
      /* HOISTED */
    )
  ]));
}
_sfc_main$T.__file = "src/components/TextEditor/icons/h-2.vue";
const H2 = /* @__PURE__ */ _export_sfc(_sfc_main$T, [["render", _sfc_render$N], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/TextEditor/icons/h-2.vue"]]);
const _sfc_main$S = {};
const _hoisted_1$U = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  width: "24",
  height: "24"
};
function _sfc_render$M(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$U, _cache[0] || (_cache[0] = [
    createBaseVNode(
      "path",
      {
        fill: "none",
        d: "M0 0H24V24H0z"
      },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      {
        d: "M22 8l-.002 2-2.505 2.883c1.59.435 2.757 1.89 2.757 3.617 0 2.071-1.679 3.75-3.75 3.75-1.826 0-3.347-1.305-3.682-3.033l1.964-.382c.156.806.866 1.415 1.718 1.415.966 0 1.75-.784 1.75-1.75s-.784-1.75-1.75-1.75c-.286 0-.556.069-.794.19l-1.307-1.547L19.35 10H15V8h7zM4 4v7h7V4h2v16h-2v-7H4v7H2V4h2z",
        fill: "currentColor"
      },
      null,
      -1
      /* HOISTED */
    )
  ]));
}
_sfc_main$S.__file = "src/components/TextEditor/icons/h-3.vue";
const H3 = /* @__PURE__ */ _export_sfc(_sfc_main$S, [["render", _sfc_render$M], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/TextEditor/icons/h-3.vue"]]);
const _sfc_main$R = {};
const _hoisted_1$T = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  width: "24",
  height: "24"
};
function _sfc_render$L(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$T, _cache[0] || (_cache[0] = [
    createBaseVNode(
      "path",
      {
        fill: "none",
        d: "M0 0H24V24H0z"
      },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      {
        d: "M13 20h-2v-7H4v7H2V4h2v7h7V4h2v16zm9-12v8h1.5v2H22v2h-2v-2h-5.5v-1.34l5-8.66H22zm-2 3.133L17.19 16H20v-4.867z",
        fill: "currentColor"
      },
      null,
      -1
      /* HOISTED */
    )
  ]));
}
_sfc_main$R.__file = "src/components/TextEditor/icons/h-4.vue";
const H4 = /* @__PURE__ */ _export_sfc(_sfc_main$R, [["render", _sfc_render$L], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/TextEditor/icons/h-4.vue"]]);
const _sfc_main$Q = {};
const _hoisted_1$S = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  width: "24",
  height: "24"
};
function _sfc_render$K(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$S, _cache[0] || (_cache[0] = [
    createBaseVNode(
      "path",
      {
        fill: "none",
        d: "M0 0H24V24H0z"
      },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      {
        d: "M22 8v2h-4.323l-.464 2.636c.33-.089.678-.136 1.037-.136 2.21 0 4 1.79 4 4s-1.79 4-4 4c-1.827 0-3.367-1.224-3.846-2.897l1.923-.551c.24.836 1.01 1.448 1.923 1.448 1.105 0 2-.895 2-2s-.895-2-2-2c-.63 0-1.193.292-1.56.748l-1.81-.904L16 8h6zM4 4v7h7V4h2v16h-2v-7H4v7H2V4h2z",
        fill: "currentColor"
      },
      null,
      -1
      /* HOISTED */
    )
  ]));
}
_sfc_main$Q.__file = "src/components/TextEditor/icons/h-5.vue";
const H5 = /* @__PURE__ */ _export_sfc(_sfc_main$Q, [["render", _sfc_render$K], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/TextEditor/icons/h-5.vue"]]);
const _sfc_main$P = {};
const _hoisted_1$R = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  width: "24",
  height: "24"
};
function _sfc_render$J(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$R, _cache[0] || (_cache[0] = [
    createBaseVNode(
      "path",
      {
        fill: "none",
        d: "M0 0H24V24H0z"
      },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      {
        d: "M21.097 8l-2.598 4.5c2.21 0 4.001 1.79 4.001 4s-1.79 4-4 4-4-1.79-4-4c0-.736.199-1.426.546-2.019L18.788 8h2.309zM4 4v7h7V4h2v16h-2v-7H4v7H2V4h2zm14.5 10.5c-1.105 0-2 .895-2 2s.895 2 2 2 2-.895 2-2-.895-2-2-2z",
        fill: "currentColor"
      },
      null,
      -1
      /* HOISTED */
    )
  ]));
}
_sfc_main$P.__file = "src/components/TextEditor/icons/h-6.vue";
const H6 = /* @__PURE__ */ _export_sfc(_sfc_main$P, [["render", _sfc_render$J], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/TextEditor/icons/h-6.vue"]]);
const _sfc_main$O = {};
const _hoisted_1$Q = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  width: "24",
  height: "24"
};
function _sfc_render$I(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$Q, _cache[0] || (_cache[0] = [
    createBaseVNode(
      "path",
      {
        fill: "none",
        d: "M0 0h24v24H0z"
      },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      {
        d: "M13 6v15h-2V6H5V4h14v2z",
        fill: "currentColor"
      },
      null,
      -1
      /* HOISTED */
    )
  ]));
}
_sfc_main$O.__file = "src/components/TextEditor/icons/text.vue";
const Text = /* @__PURE__ */ _export_sfc(_sfc_main$O, [["render", _sfc_render$I], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/TextEditor/icons/text.vue"]]);
const _sfc_main$N = {};
const _hoisted_1$P = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  width: "24",
  height: "24"
};
function _sfc_render$H(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$P, _cache[0] || (_cache[0] = [
    createBaseVNode(
      "path",
      {
        fill: "none",
        d: "M0 0h24v24H0z"
      },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      {
        d: "M8 11h4.5a2.5 2.5 0 1 0 0-5H8v5zm10 4.5a4.5 4.5 0 0 1-4.5 4.5H6V4h6.5a4.5 4.5 0 0 1 3.256 7.606A4.498 4.498 0 0 1 18 15.5zM8 13v5h5.5a2.5 2.5 0 1 0 0-5H8z",
        fill: "currentColor"
      },
      null,
      -1
      /* HOISTED */
    )
  ]));
}
_sfc_main$N.__file = "src/components/TextEditor/icons/bold.vue";
const Bold = /* @__PURE__ */ _export_sfc(_sfc_main$N, [["render", _sfc_render$H], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/TextEditor/icons/bold.vue"]]);
const _sfc_main$M = {};
const _hoisted_1$O = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  width: "24",
  height: "24"
};
function _sfc_render$G(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$O, _cache[0] || (_cache[0] = [
    createBaseVNode(
      "path",
      {
        fill: "none",
        d: "M0 0h24v24H0z"
      },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      {
        d: "M15 20H7v-2h2.927l2.116-12H9V4h8v2h-2.927l-2.116 12H15z",
        fill: "currentColor"
      },
      null,
      -1
      /* HOISTED */
    )
  ]));
}
_sfc_main$M.__file = "src/components/TextEditor/icons/italic.vue";
const Italic = /* @__PURE__ */ _export_sfc(_sfc_main$M, [["render", _sfc_render$G], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/TextEditor/icons/italic.vue"]]);
const _sfc_main$L = {};
const _hoisted_1$N = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  width: "24",
  height: "24"
};
function _sfc_render$F(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$N, _cache[0] || (_cache[0] = [
    createBaseVNode(
      "path",
      {
        fill: "none",
        d: "M0 0h24v24H0z"
      },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      {
        d: "M8 3v9a4 4 0 1 0 8 0V3h2v9a6 6 0 1 1-12 0V3h2zM4 20h16v2H4v-2z",
        fill: "currentColor"
      },
      null,
      -1
      /* HOISTED */
    )
  ]));
}
_sfc_main$L.__file = "src/components/TextEditor/icons/underline.vue";
const Underline = /* @__PURE__ */ _export_sfc(_sfc_main$L, [["render", _sfc_render$F], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/TextEditor/icons/underline.vue"]]);
const _sfc_main$K = {};
const _hoisted_1$M = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  width: "24",
  height: "24"
};
function _sfc_render$E(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$M, _cache[0] || (_cache[0] = [
    createBaseVNode(
      "path",
      {
        fill: "none",
        d: "M0 0h24v24H0z"
      },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      {
        d: "M17.154 14c.23.516.346 1.09.346 1.72 0 1.342-.524 2.392-1.571 3.147C14.88 19.622 13.433 20 11.586 20c-1.64 0-3.263-.381-4.87-1.144V16.6c1.52.877 3.075 1.316 4.666 1.316 2.551 0 3.83-.732 3.839-2.197a2.21 2.21 0 0 0-.648-1.603l-.12-.117H3v-2h18v2h-3.846zm-4.078-3H7.629a4.086 4.086 0 0 1-.481-.522C6.716 9.92 6.5 9.246 6.5 8.452c0-1.236.466-2.287 1.397-3.153C8.83 4.433 10.271 4 12.222 4c1.471 0 2.879.328 4.222.984v2.152c-1.2-.687-2.515-1.03-3.946-1.03-2.48 0-3.719.782-3.719 2.346 0 .42.218.786.654 1.099.436.313.974.562 1.613.75.62.18 1.297.414 2.03.699z",
        fill: "currentColor"
      },
      null,
      -1
      /* HOISTED */
    )
  ]));
}
_sfc_main$K.__file = "src/components/TextEditor/icons/strikethrough.vue";
const Strikethrough = /* @__PURE__ */ _export_sfc(_sfc_main$K, [["render", _sfc_render$E], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/TextEditor/icons/strikethrough.vue"]]);
const _sfc_main$J = {};
const _hoisted_1$L = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  width: "24",
  height: "24"
};
function _sfc_render$D(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$L, _cache[0] || (_cache[0] = [
    createBaseVNode(
      "path",
      {
        fill: "none",
        d: "M0 0h24v24H0z"
      },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      {
        d: "M3 4h18v2H3V4zm2 15h14v2H5v-2zm-2-5h18v2H3v-2zm2-5h14v2H5V9z",
        fill: "currentColor"
      },
      null,
      -1
      /* HOISTED */
    )
  ]));
}
_sfc_main$J.__file = "src/components/TextEditor/icons/align-center.vue";
const AlignCenter = /* @__PURE__ */ _export_sfc(_sfc_main$J, [["render", _sfc_render$D], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/TextEditor/icons/align-center.vue"]]);
const _sfc_main$I = {};
const _hoisted_1$K = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  width: "24",
  height: "24"
};
function _sfc_render$C(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$K, _cache[0] || (_cache[0] = [
    createBaseVNode(
      "path",
      {
        fill: "none",
        d: "M0 0h24v24H0z"
      },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      {
        d: "M3 4h18v2H3V4zm0 15h14v2H3v-2zm0-5h18v2H3v-2zm0-5h14v2H3V9z",
        fill: "currentColor"
      },
      null,
      -1
      /* HOISTED */
    )
  ]));
}
_sfc_main$I.__file = "src/components/TextEditor/icons/align-left.vue";
const AlignLeft = /* @__PURE__ */ _export_sfc(_sfc_main$I, [["render", _sfc_render$C], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/TextEditor/icons/align-left.vue"]]);
const _sfc_main$H = {};
const _hoisted_1$J = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  width: "24",
  height: "24"
};
function _sfc_render$B(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$J, _cache[0] || (_cache[0] = [
    createBaseVNode(
      "path",
      {
        fill: "none",
        d: "M0 0h24v24H0z"
      },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      {
        d: "M3 4h18v2H3V4zm4 15h14v2H7v-2zm-4-5h18v2H3v-2zm4-5h14v2H7V9z",
        fill: "currentColor"
      },
      null,
      -1
      /* HOISTED */
    )
  ]));
}
_sfc_main$H.__file = "src/components/TextEditor/icons/align-right.vue";
const AlignRight = /* @__PURE__ */ _export_sfc(_sfc_main$H, [["render", _sfc_render$B], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/TextEditor/icons/align-right.vue"]]);
const _sfc_main$G = {};
const _hoisted_1$I = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  width: "24",
  height: "24"
};
function _sfc_render$A(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$I, _cache[0] || (_cache[0] = [
    createBaseVNode(
      "path",
      {
        fill: "none",
        d: "M0 0h24v24H0z"
      },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      {
        d: "M15.246 14H8.754l-1.6 4H5l6-15h2l6 15h-2.154l-1.6-4zm-.8-2L12 5.885 9.554 12h4.892zM3 20h18v2H3v-2z",
        fill: "currentColor"
      },
      null,
      -1
      /* HOISTED */
    )
  ]));
}
_sfc_main$G.__file = "src/components/TextEditor/icons/font-color.vue";
const FontColor = /* @__PURE__ */ _export_sfc(_sfc_main$G, [["render", _sfc_render$A], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/TextEditor/icons/font-color.vue"]]);
const _sfc_main$F = {};
const _hoisted_1$H = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  width: "24",
  height: "24"
};
function _sfc_render$z(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$H, _cache[0] || (_cache[0] = [
    createBaseVNode(
      "path",
      {
        fill: "none",
        d: "M0 0h24v24H0z"
      },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      {
        d: "M8 4h13v2H8V4zM5 3v3h1v1H3V6h1V4H3V3h2zM3 14v-2.5h2V11H3v-1h3v2.5H4v.5h2v1H3zm2 5.5H3v-1h2V18H3v-1h3v4H3v-1h2v-.5zM8 11h13v2H8v-2zm0 7h13v2H8v-2z",
        fill: "currentColor"
      },
      null,
      -1
      /* HOISTED */
    )
  ]));
}
_sfc_main$F.__file = "src/components/TextEditor/icons/list-ordered.vue";
const ListOrdered$1 = /* @__PURE__ */ _export_sfc(_sfc_main$F, [["render", _sfc_render$z], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/TextEditor/icons/list-ordered.vue"]]);
const _sfc_main$E = {};
const _hoisted_1$G = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  width: "24",
  height: "24"
};
function _sfc_render$y(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$G, _cache[0] || (_cache[0] = [
    createBaseVNode(
      "path",
      {
        fill: "none",
        d: "M0 0h24v24H0z"
      },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      {
        d: "M8 4h13v2H8V4zM4.5 6.5a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zm0 7a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zm0 6.9a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zM8 11h13v2H8v-2zm0 7h13v2H8v-2z",
        fill: "currentColor"
      },
      null,
      -1
      /* HOISTED */
    )
  ]));
}
_sfc_main$E.__file = "src/components/TextEditor/icons/list-unordered.vue";
const ListUnordered = /* @__PURE__ */ _export_sfc(_sfc_main$E, [["render", _sfc_render$y], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/TextEditor/icons/list-unordered.vue"]]);
const _sfc_main$D = {};
const _hoisted_1$F = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "2",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  class: "lucide lucide-list-checks-icon lucide-list-checks"
};
function _sfc_render$x(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$F, _cache[0] || (_cache[0] = [
    createStaticVNode('<path d="m3 17 2 2 4-4"></path><path d="m3 7 2 2 4-4"></path><path d="M13 6h8"></path><path d="M13 12h8"></path><path d="M13 18h8"></path>', 5)
  ]));
}
_sfc_main$D.__file = "src/components/TextEditor/icons/list-task.vue";
const ListTask$1 = /* @__PURE__ */ _export_sfc(_sfc_main$D, [["render", _sfc_render$x], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/TextEditor/icons/list-task.vue"]]);
const _sfc_main$C = {};
const _hoisted_1$E = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  width: "24",
  height: "24"
};
function _sfc_render$w(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$E, _cache[0] || (_cache[0] = [
    createBaseVNode(
      "path",
      {
        fill: "none",
        d: "M0 0h24v24H0z"
      },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      {
        d: "M19.417 6.679C20.447 7.773 21 9 21 10.989c0 3.5-2.457 6.637-6.03 8.188l-.893-1.378c3.335-1.804 3.987-4.145 4.247-5.621-.537.278-1.24.375-1.929.311-1.804-.167-3.226-1.648-3.226-3.489a3.5 3.5 0 0 1 3.5-3.5c1.073 0 2.099.49 2.748 1.179zm-10 0C10.447 7.773 11 9 11 10.989c0 3.5-2.457 6.637-6.03 8.188l-.893-1.378c3.335-1.804 3.987-4.145 4.247-5.621-.537.278-1.24.375-1.929.311C4.591 12.322 3.17 10.841 3.17 9a3.5 3.5 0 0 1 3.5-3.5c1.073 0 2.099.49 2.748 1.179z",
        fill: "currentColor"
      },
      null,
      -1
      /* HOISTED */
    )
  ]));
}
_sfc_main$C.__file = "src/components/TextEditor/icons/double-quotes-r.vue";
const DoubleQuotes = /* @__PURE__ */ _export_sfc(_sfc_main$C, [["render", _sfc_render$w], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/TextEditor/icons/double-quotes-r.vue"]]);
const _sfc_main$B = {};
const _hoisted_1$D = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  width: "24",
  height: "24"
};
function _sfc_render$v(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$D, _cache[0] || (_cache[0] = [
    createBaseVNode(
      "path",
      {
        fill: "none",
        d: "M0 0h24v24H0z"
      },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      {
        d: "M16.95 8.464l1.414-1.414 4.95 4.95-4.95 4.95-1.414-1.414L20.485 12 16.95 8.464zm-9.9 0L3.515 12l3.535 3.536-1.414 1.414L.686 12l4.95-4.95L7.05 8.464z",
        fill: "currentColor"
      },
      null,
      -1
      /* HOISTED */
    )
  ]));
}
_sfc_main$B.__file = "src/components/TextEditor/icons/code-view.vue";
const CodeView = /* @__PURE__ */ _export_sfc(_sfc_main$B, [["render", _sfc_render$v], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/TextEditor/icons/code-view.vue"]]);
const _sfc_main$A = {};
const _hoisted_1$C = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  width: "24",
  height: "24"
};
function _sfc_render$u(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$C, _cache[0] || (_cache[0] = [
    createBaseVNode(
      "path",
      {
        fill: "none",
        d: "M0 0h24v24H0z"
      },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      {
        d: "M18.364 15.536L16.95 14.12l1.414-1.414a5 5 0 1 0-7.071-7.071L9.879 7.05 8.464 5.636 9.88 4.222a7 7 0 0 1 9.9 9.9l-1.415 1.414zm-2.828 2.828l-1.415 1.414a7 7 0 0 1-9.9-9.9l1.415-1.414L7.05 9.88l-1.414 1.414a5 5 0 1 0 7.071 7.071l1.414-1.414 1.415 1.414zm-.708-10.607l1.415 1.415-7.071 7.07-1.415-1.414 7.071-7.07z",
        fill: "currentColor"
      },
      null,
      -1
      /* HOISTED */
    )
  ]));
}
_sfc_main$A.__file = "src/components/TextEditor/icons/link.vue";
const Link = /* @__PURE__ */ _export_sfc(_sfc_main$A, [["render", _sfc_render$u], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/TextEditor/icons/link.vue"]]);
const _sfc_main$z = {};
const _hoisted_1$B = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  width: "24",
  height: "24"
};
function _sfc_render$t(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$B, _cache[0] || (_cache[0] = [
    createBaseVNode(
      "path",
      {
        fill: "none",
        d: "M0 0h24v24H0z"
      },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      {
        d: "M21 15v3h3v2h-3v3h-2v-3h-3v-2h3v-3h2zm.008-12c.548 0 .992.445.992.993V13h-2V5H4v13.999L14 9l3 3v2.829l-3-3L6.827 19H14v2H2.992A.993.993 0 0 1 2 20.007V3.993A1 1 0 0 1 2.992 3h18.016zM8 7a2 2 0 1 1 0 4 2 2 0 0 1 0-4z",
        fill: "currentColor"
      },
      null,
      -1
      /* HOISTED */
    )
  ]));
}
_sfc_main$z.__file = "src/components/TextEditor/icons/image-add-line.vue";
const Image$2 = /* @__PURE__ */ _export_sfc(_sfc_main$z, [["render", _sfc_render$t], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/TextEditor/icons/image-add-line.vue"]]);
const _sfc_main$y = {};
const _hoisted_1$A = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  width: "24",
  height: "24"
};
function _sfc_render$s(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$A, _cache[0] || (_cache[0] = [
    createBaseVNode(
      "path",
      {
        fill: "none",
        d: "M0 0H24V24H0z"
      },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      {
        d: "M16 4c.552 0 1 .448 1 1v4.2l5.213-3.65c.226-.158.538-.103.697.124.058.084.09.184.09.286v12.08c0 .276-.224.5-.5.5-.103 0-.203-.032-.287-.09L17 14.8V19c0 .552-.448 1-1 1H2c-.552 0-1-.448-1-1V5c0-.552.448-1 1-1h14zm-1 2H3v12h12V6zM8 8h2v3h3v2H9.999L10 16H8l-.001-3H5v-2h3V8zm13 .841l-4 2.8v.718l4 2.8V8.84z",
        fill: "currentColor"
      },
      null,
      -1
      /* HOISTED */
    )
  ]));
}
_sfc_main$y.__file = "src/components/TextEditor/icons/video-add-line.vue";
const Video$1 = /* @__PURE__ */ _export_sfc(_sfc_main$y, [["render", _sfc_render$s], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/TextEditor/icons/video-add-line.vue"]]);
const _hoisted_1$z = {
  class: "lucide lucide-gallery-vertical",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function render$e(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$z, _cache[0] || (_cache[0] = [
    createBaseVNode(
      "path",
      { d: "M3 2h18" },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "rect",
      {
        width: "18",
        height: "12",
        x: "3",
        y: "6",
        rx: "2"
      },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      { d: "M3 22h18" },
      null,
      -1
      /* HOISTED */
    )
  ]));
}
const GalleryVertical = markRaw({ name: "lucide-gallery-vertical", render: render$e });
const _sfc_main$x = {};
const _hoisted_1$y = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  width: "24",
  height: "24"
};
function _sfc_render$r(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$y, _cache[0] || (_cache[0] = [
    createBaseVNode(
      "path",
      {
        fill: "none",
        d: "M0 0h24v24H0z"
      },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      {
        d: "M5.828 7l2.536 2.536L6.95 10.95 2 6l4.95-4.95 1.414 1.414L5.828 5H13a8 8 0 1 1 0 16H4v-2h9a6 6 0 1 0 0-12H5.828z",
        fill: "currentColor"
      },
      null,
      -1
      /* HOISTED */
    )
  ]));
}
_sfc_main$x.__file = "src/components/TextEditor/icons/arrow-go-back-line.vue";
const ArrowGoBack = /* @__PURE__ */ _export_sfc(_sfc_main$x, [["render", _sfc_render$r], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/TextEditor/icons/arrow-go-back-line.vue"]]);
const _sfc_main$w = {};
const _hoisted_1$x = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  width: "24",
  height: "24"
};
function _sfc_render$q(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$x, _cache[0] || (_cache[0] = [
    createBaseVNode(
      "path",
      {
        fill: "none",
        d: "M0 0h24v24H0z"
      },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      {
        d: "M18.172 7H11a6 6 0 1 0 0 12h9v2h-9a8 8 0 1 1 0-16h7.172l-2.536-2.536L17.05 1.05 22 6l-4.95 4.95-1.414-1.414L18.172 7z",
        fill: "currentColor"
      },
      null,
      -1
      /* HOISTED */
    )
  ]));
}
_sfc_main$w.__file = "src/components/TextEditor/icons/arrow-go-forward-line.vue";
const ArrowGoForward = /* @__PURE__ */ _export_sfc(_sfc_main$w, [["render", _sfc_render$q], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/TextEditor/icons/arrow-go-forward-line.vue"]]);
const _sfc_main$v = {};
const _hoisted_1$w = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  width: "24",
  height: "24"
};
function _sfc_render$p(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$w, _cache[0] || (_cache[0] = [
    createBaseVNode(
      "path",
      {
        fill: "none",
        d: "M0 0h24v24H0z"
      },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      {
        d: "M2 11h2v2H2v-2zm4 0h12v2H6v-2zm14 0h2v2h-2v-2z",
        fill: "currentColor"
      },
      null,
      -1
      /* HOISTED */
    )
  ]));
}
_sfc_main$v.__file = "src/components/TextEditor/icons/separator.vue";
const Separator = /* @__PURE__ */ _export_sfc(_sfc_main$v, [["render", _sfc_render$p], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/TextEditor/icons/separator.vue"]]);
const _sfc_main$u = {};
const _hoisted_1$v = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  width: "24",
  height: "24"
};
function _sfc_render$o(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$v, _cache[0] || (_cache[0] = [
    createBaseVNode(
      "path",
      {
        fill: "none",
        d: "M0 0h24v24H0z"
      },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      {
        d: "M13 10v4h6v-4h-6zm-2 0H5v4h6v-4zm2 9h6v-3h-6v3zm-2 0v-3H5v3h6zm2-14v3h6V5h-6zm-2 0H5v3h6V5zM4 3h16a1 1 0 0 1 1 1v16a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1z",
        fill: "currentColor"
      },
      null,
      -1
      /* HOISTED */
    )
  ]));
}
_sfc_main$u.__file = "src/components/TextEditor/icons/table-2.vue";
const Table$1 = /* @__PURE__ */ _export_sfc(_sfc_main$u, [["render", _sfc_render$o], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/TextEditor/icons/table-2.vue"]]);
const commands = {
  Paragraph: {
    label: "Paragraph",
    icon: Text,
    action: (editor) => editor.chain().focus().setParagraph().run(),
    isActive: (editor) => editor.isActive("paragraph")
  },
  "Heading 1": {
    label: "Heading 1",
    text: "H1",
    icon: H1,
    action: (editor) => editor.chain().focus().toggleHeading({ level: 1 }).run(),
    isActive: (editor) => editor.isActive("heading", { level: 1 })
  },
  "Heading 2": {
    label: "Heading 2",
    text: "H2",
    icon: H2,
    action: (editor) => editor.chain().focus().toggleHeading({ level: 2 }).run(),
    isActive: (editor) => editor.isActive("heading", { level: 2 })
  },
  "Heading 3": {
    label: "Heading 3",
    text: "H3",
    icon: H3,
    action: (editor) => editor.chain().focus().toggleHeading({ level: 3 }).run(),
    isActive: (editor) => editor.isActive("heading", { level: 3 })
  },
  "Heading 4": {
    label: "Heading 4",
    text: "H4",
    icon: H4,
    action: (editor) => editor.chain().focus().toggleHeading({ level: 4 }).run(),
    isActive: (editor) => editor.isActive("heading", { level: 4 })
  },
  "Heading 5": {
    label: "Heading 5",
    text: "H5",
    icon: H5,
    action: (editor) => editor.chain().focus().toggleHeading({ level: 5 }).run(),
    isActive: (editor) => editor.isActive("heading", { level: 5 })
  },
  "Heading 6": {
    label: "Heading 6",
    text: "H6",
    icon: H6,
    action: (editor) => editor.chain().focus().toggleHeading({ level: 6 }).run(),
    isActive: (editor) => editor.isActive("heading", { level: 6 })
  },
  Bold: {
    label: "Bold",
    icon: Bold,
    action: (editor) => editor.chain().focus().toggleBold().run(),
    isActive: (editor) => editor.isActive("bold")
  },
  Italic: {
    label: "Italic",
    icon: Italic,
    action: (editor) => editor.chain().focus().toggleItalic().run(),
    isActive: (editor) => editor.isActive("italic")
  },
  Underline: {
    label: "Underline",
    icon: Underline,
    action: (editor) => editor.chain().focus().toggleUnderline().run(),
    isActive: (editor) => editor.isActive("underline")
  },
  Strikethrough: {
    label: "Strikethrough",
    icon: Strikethrough,
    action: (editor) => editor.chain().focus().toggleStrike().run(),
    isActive: (editor) => editor.isActive("strike")
  },
  "Bullet List": {
    label: "Bullet List",
    icon: ListUnordered,
    action: (editor) => editor.chain().focus().toggleBulletList().run(),
    isActive: (editor) => editor.isActive("bulletList")
  },
  "Numbered List": {
    label: "Numbered List",
    icon: ListOrdered$1,
    action: (editor) => editor.chain().focus().toggleOrderedList().run(),
    isActive: (editor) => editor.isActive("orderedList")
  },
  "Task List": {
    label: "Task List",
    icon: ListTask$1,
    action: (editor) => editor.chain().focus().toggleTaskList().run(),
    isActive: (editor) => editor.isActive("taskList")
  },
  "Align Center": {
    label: "Align Center",
    icon: AlignCenter,
    action: (editor) => editor.chain().focus().setTextAlign("center").run(),
    isActive: (editor) => editor.isActive({ textAlign: "center" })
  },
  "Align Left": {
    label: "Align Left",
    icon: AlignLeft,
    action: (editor) => editor.chain().focus().setTextAlign("left").run(),
    isActive: (editor) => editor.isActive({ textAlign: "left" })
  },
  "Align Right": {
    label: "Align Right",
    icon: AlignRight,
    action: (editor) => editor.chain().focus().setTextAlign("right").run(),
    isActive: (editor) => editor.isActive({ textAlign: "right" })
  },
  FontColor: {
    label: "Font Color",
    icon: FontColor,
    isActive: (editor) => editor.isActive("textStyle") || editor.isActive("highlight"),
    component: defineAsyncComponent(() => __vitePreload(() => import("./FontColor-BLTHJ7ns.js"), true ? __vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38]) : void 0))
  },
  Blockquote: {
    label: "Blockquote",
    icon: DoubleQuotes,
    action: (editor) => editor.chain().focus().toggleBlockquote().run(),
    isActive: (editor) => editor.isActive("blockquote")
  },
  Code: {
    label: "Code",
    icon: CodeView,
    action: (editor) => editor.chain().focus().toggleCodeBlock().run(),
    isActive: (editor) => editor.isActive("codeBlock")
  },
  "Horizontal Rule": {
    label: "Horizontal Rule",
    icon: Separator,
    action: (editor) => editor.chain().focus().setHorizontalRule().run(),
    isActive: (editor) => false
  },
  Link: {
    label: "Link",
    icon: Link,
    isActive: (editor) => editor.isActive("link"),
    component: defineAsyncComponent(() => __vitePreload(() => import("./InsertLink-BgAo4EQb.js"), true ? __vite__mapDeps([39,2,3]) : void 0))
  },
  Image: {
    label: "Image",
    icon: Image$2,
    isActive: (editor) => false,
    component: defineAsyncComponent(() => __vitePreload(() => import("./InsertImage-Df_MQcjt.js"), true ? __vite__mapDeps([40,2,3,15,12,6,1,4,5,7,8,9,10,11,13,14,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38]) : void 0))
  },
  Video: {
    label: "Video",
    icon: Video$1,
    isActive: (editor) => false,
    component: defineAsyncComponent(() => __vitePreload(() => import("./InsertVideo-kPXpE6eQ.js"), true ? __vite__mapDeps([41,2,3]) : void 0))
  },
  Iframe: {
    label: "Embed",
    icon: GalleryVertical,
    isActive: (editor) => editor.isActive("iframe"),
    component: defineAsyncComponent(() => __vitePreload(() => import("./InsertIframe-v8LshaTo.js"), true ? __vite__mapDeps([42,2,6,1,3,4,5,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38]) : void 0))
  },
  Undo: {
    label: "Undo",
    icon: ArrowGoBack,
    action: (editor) => editor.chain().focus().undo().run(),
    isActive: (editor) => false
  },
  Redo: {
    label: "Redo",
    icon: ArrowGoForward,
    action: (editor) => editor.chain().focus().redo().run(),
    isActive: (editor) => false
  },
  InsertTable: {
    label: "Insert Table",
    icon: Table$1,
    action: (editor) => editor.chain().focus().insertTable({ rows: 3, cols: 3, withHeaderRow: true }).run(),
    isActive: (editor) => false
  },
  AddColumnBefore: {
    label: "Add Column Before",
    action: (editor) => editor.chain().focus().addColumnBefore().run(),
    isActive: (editor) => false,
    isDisabled: (editor) => !editor.can().addColumnBefore()
  },
  AddColumnAfter: {
    label: "Add Column After",
    action: (editor) => editor.chain().focus().addColumnAfter().run(),
    isActive: (editor) => false,
    isDisabled: (editor) => !editor.can().addColumnAfter()
  },
  DeleteColumn: {
    label: "Delete Column",
    action: (editor) => editor.chain().focus().deleteColumn().run(),
    isActive: (editor) => false,
    isDisabled: (editor) => !editor.can().deleteColumn()
  },
  AddRowBefore: {
    label: "Add Row Before",
    action: (editor) => editor.chain().focus().addRowBefore().run(),
    isActive: (editor) => false,
    isDisabled: (editor) => !editor.can().addRowBefore()
  },
  AddRowAfter: {
    label: "Add Row After",
    action: (editor) => editor.chain().focus().addRowAfter().run(),
    isActive: (editor) => false,
    isDisabled: (editor) => !editor.can().addRowAfter()
  },
  DeleteRow: {
    label: "Delete Row",
    action: (editor) => editor.chain().focus().deleteRow().run(),
    isActive: (editor) => false,
    isDisabled: (editor) => !editor.can().deleteRow()
  },
  DeleteTable: {
    label: "Delete Table",
    action: (editor) => editor.chain().focus().deleteTable().run(),
    isActive: (editor) => false,
    isDisabled: (editor) => !editor.can().deleteTable()
  },
  MergeCells: {
    label: "Merge Cells",
    action: (editor) => editor.chain().focus().mergeCells().run(),
    isActive: (editor) => false,
    isDisabled: (editor) => !editor.can().mergeCells()
  },
  SplitCell: {
    label: "Split Cell",
    action: (editor) => editor.chain().focus().splitCell().run(),
    isActive: (editor) => false,
    isDisabled: (editor) => !editor.can().splitCell()
  },
  ToggleHeaderColumn: {
    label: "Toggle Header Column",
    action: (editor) => editor.chain().focus().toggleHeaderColumn().run(),
    isActive: (editor) => false,
    isDisabled: (editor) => !editor.can().toggleHeaderColumn()
  },
  ToggleHeaderRow: {
    label: "Toggle Header Row",
    action: (editor) => editor.chain().focus().toggleHeaderRow().run(),
    isActive: (editor) => false,
    isDisabled: (editor) => !editor.can().toggleHeaderRow()
  },
  ToggleHeaderCell: {
    label: "Toggle Header Cell",
    action: (editor) => editor.chain().focus().toggleHeaderCell().run(),
    isActive: (editor) => false,
    isDisabled: (editor) => !editor.can().toggleHeaderCell()
  },
  Separator: {
    type: "separator"
  }
};
function createEditorButton(option) {
  if (option instanceof Array) {
    return option.map(createEditorButton);
  }
  if (typeof option == "object") {
    return option;
  }
  return commands[option];
}
const _sfc_main$t = {
  name: "TextEditorFixedMenu",
  props: ["buttons"],
  components: { Menu: __unplugin_components_0 },
  inject: ["editor"],
  computed: {
    fixedMenuButtons() {
      if (!this.buttons) return false;
      let buttons;
      if (Array.isArray(this.buttons)) {
        buttons = this.buttons;
      } else {
        buttons = [
          [
            "Heading 1",
            "Heading 2",
            "Heading 3",
            "Heading 4",
            "Heading 5",
            "Heading 6"
          ],
          "Paragraph",
          "Separator",
          "Bold",
          "Italic",
          "Separator",
          "Bullet List",
          "Numbered List",
          "Task List",
          "Separator",
          "Align Left",
          "Align Center",
          "Align Right",
          "FontColor",
          "Separator",
          "Image",
          "Video",
          "Iframe",
          "Link",
          "Blockquote",
          "Code",
          "Horizontal Rule",
          [
            "InsertTable",
            "AddColumnBefore",
            "AddColumnAfter",
            "DeleteColumn",
            "AddRowBefore",
            "AddRowAfter",
            "DeleteRow",
            "MergeCells",
            "SplitCell",
            "ToggleHeaderColumn",
            "ToggleHeaderRow",
            "ToggleHeaderCell",
            "DeleteTable"
          ],
          "Separator",
          "Undo",
          "Redo"
        ];
      }
      return buttons.map(createEditorButton);
    }
  }
};
function _sfc_render$n(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Menu = __unplugin_components_0;
  return $options.fixedMenuButtons ? (openBlock(), createBlock(_component_Menu, {
    key: 0,
    buttons: $options.fixedMenuButtons
  }, null, 8, ["buttons"])) : createCommentVNode("v-if", true);
}
_sfc_main$t.__file = "src/components/TextEditor/TextEditorFixedMenu.vue";
const TextEditorFixedMenu = /* @__PURE__ */ _export_sfc(_sfc_main$t, [["render", _sfc_render$n], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/TextEditor/TextEditorFixedMenu.vue"]]);
const _sfc_main$s = {
  name: "TextEditorBubbleMenu",
  props: ["buttons", "options"],
  components: { BubbleMenu, Menu: __unplugin_components_0 },
  inject: ["editor"],
  computed: {
    bubbleMenuButtons() {
      if (!this.buttons) return false;
      let buttons;
      if (Array.isArray(this.buttons)) {
        buttons = this.buttons;
      } else {
        buttons = [
          "Paragraph",
          "Heading 2",
          "Heading 3",
          "Separator",
          "Bold",
          "Italic",
          "Strikethrough",
          "FontColor",
          "Link",
          "Separator",
          "Bullet List",
          "Numbered List",
          "Task List",
          "Separator",
          "Align Left",
          "Align Center",
          "Align Right",
          "Separator",
          "Image",
          "Video",
          "Blockquote",
          "Code",
          [
            "InsertTable",
            "AddColumnBefore",
            "AddColumnAfter",
            "DeleteColumn",
            "AddRowBefore",
            "AddRowAfter",
            "DeleteRow",
            "MergeCells",
            "SplitCell",
            "ToggleHeaderColumn",
            "ToggleHeaderRow",
            "ToggleHeaderCell",
            "DeleteTable"
          ]
        ];
      }
      return buttons.map(createEditorButton);
    }
  }
};
function _sfc_render$m(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Menu = __unplugin_components_0;
  const _component_BubbleMenu = resolveComponent("BubbleMenu");
  return $options.bubbleMenuButtons ? (openBlock(), createBlock(_component_BubbleMenu, mergeProps({
    key: 0,
    class: "bubble-menu rounded-md shadow-sm",
    "tippy-options": { duration: 100 },
    editor: $options.editor
  }, $props.options), {
    default: withCtx(() => [
      createVNode(_component_Menu, {
        class: "rounded-md border-gray-100 shadow-lg",
        buttons: $options.bubbleMenuButtons
      }, null, 8, ["buttons"])
    ]),
    _: 1
    /* STABLE */
  }, 16, ["editor"])) : createCommentVNode("v-if", true);
}
_sfc_main$s.__file = "src/components/TextEditor/TextEditorBubbleMenu.vue";
const TextEditorBubbleMenu = /* @__PURE__ */ _export_sfc(_sfc_main$s, [["render", _sfc_render$m], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/TextEditor/TextEditorBubbleMenu.vue"]]);
const _sfc_main$r = {
  name: "TextEditorFloatingMenu",
  props: ["buttons"],
  components: { FloatingMenu },
  inject: ["editor"],
  computed: {
    floatingMenuButtons() {
      if (!this.buttons) return false;
      let buttons;
      if (Array.isArray(this.buttons)) {
        buttons = this.buttons;
      } else {
        buttons = [
          "Paragraph",
          "Heading 2",
          "Heading 3",
          "Bullet List",
          "Numbered List",
          "Task List",
          "Blockquote",
          "Code",
          "Horizontal Rule"
        ];
      }
      return buttons.map(createEditorButton);
    }
  }
};
const _hoisted_1$u = ["onClick", "title"];
const _hoisted_2$6 = {
  key: 1,
  class: "inline-block h-4 min-w-[1rem] text-sm leading-4"
};
function _sfc_render$l(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_FloatingMenu = resolveComponent("FloatingMenu");
  return $options.floatingMenuButtons ? (openBlock(), createBlock(_component_FloatingMenu, {
    key: 0,
    "tippy-options": { duration: 100 },
    editor: $options.editor,
    class: "flex"
  }, {
    default: withCtx(() => [
      (openBlock(true), createElementBlock(
        Fragment,
        null,
        renderList($options.floatingMenuButtons, (button) => {
          return openBlock(), createElementBlock("button", {
            key: button.label,
            class: normalizeClass([
              "flex rounded p-1 text-ink-gray-8 transition-colors",
              button.isActive($options.editor) ? "bg-surface-gray-2" : "hover:bg-surface-gray-2"
            ]),
            onClick: () => button.action($options.editor),
            title: button.label
          }, [
            button.icon ? (openBlock(), createBlock(resolveDynamicComponent(button.icon), {
              key: 0,
              class: "h-4 w-4"
            })) : (openBlock(), createElementBlock(
              "span",
              _hoisted_2$6,
              toDisplayString(button.text),
              1
              /* TEXT */
            ))
          ], 10, _hoisted_1$u);
        }),
        128
        /* KEYED_FRAGMENT */
      ))
    ]),
    _: 1
    /* STABLE */
  }, 8, ["editor"])) : createCommentVNode("v-if", true);
}
_sfc_main$r.__file = "src/components/TextEditor/TextEditorFloatingMenu.vue";
const TextEditorFloatingMenu = /* @__PURE__ */ _export_sfc(_sfc_main$r, [["render", _sfc_render$l], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/TextEditor/TextEditorFloatingMenu.vue"]]);
const _sfc_main$q = /* @__PURE__ */ defineComponent({
  __name: "EmojiList",
  props: {
    items: {
      type: Array,
      required: true
    },
    editor: {
      type: Object,
      required: true
    },
    range: {
      type: Object,
      required: true
    },
    command: {
      type: Function,
      required: true
    }
  },
  setup(__props, { expose: __expose }) {
    const props = __props;
    const suggestionList = ref(null);
    const onItemSelect = (item) => {
      if (item) {
        props.command(item);
      }
    };
    const onKeyDown = ({ event }) => {
      var _a;
      return ((_a = suggestionList.value) == null ? void 0 : _a.onKeyDown({ event })) ?? false;
    };
    __expose({
      onKeyDown
    });
    const __returned__ = { props, suggestionList, onItemSelect, onKeyDown, SuggestionList };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$t = { class: "mr-2" };
function _sfc_render$k(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock($setup["SuggestionList"], {
    ref: "suggestionList",
    items: $props.items,
    command: (item) => $setup.onItemSelect(item),
    "item-class": "py-2"
  }, {
    default: withCtx(({ item }) => [
      createBaseVNode(
        "span",
        _hoisted_1$t,
        toDisplayString(item.emoji),
        1
        /* TEXT */
      ),
      createBaseVNode(
        "span",
        null,
        toDisplayString(item.name),
        1
        /* TEXT */
      )
    ]),
    _: 1
    /* STABLE */
  }, 8, ["items", "command"]);
}
_sfc_main$q.__file = "src/components/TextEditor/extensions/emoji/EmojiList.vue";
const EmojiList = /* @__PURE__ */ _export_sfc(_sfc_main$q, [["render", _sfc_render$k], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/TextEditor/extensions/emoji/EmojiList.vue"]]);
const _EMOJIS = [
  {
    name: "grinning",
    emoji: "😀"
  },
  {
    name: "grimacing",
    emoji: "😬"
  },
  {
    name: "grin",
    emoji: "😁"
  },
  {
    name: "joy",
    emoji: "😂"
  },
  {
    name: "rofl",
    emoji: "🤣"
  },
  {
    name: "smiley",
    emoji: "😃"
  },
  {
    name: "smile",
    emoji: "😄"
  },
  {
    name: "sweat_smile",
    emoji: "😅"
  },
  {
    name: "laughing",
    emoji: "😆"
  },
  {
    name: "innocent",
    emoji: "😇"
  },
  {
    name: "wink",
    emoji: "😉"
  },
  {
    name: "blush",
    emoji: "😊"
  },
  {
    name: "slightly_smiling_face",
    emoji: "🙂"
  },
  {
    name: "upside_down_face",
    emoji: "🙃"
  },
  {
    name: "relaxed",
    emoji: "☺"
  },
  {
    name: "yum",
    emoji: "😋"
  },
  {
    name: "relieved",
    emoji: "😌"
  },
  {
    name: "heart_eyes",
    emoji: "😍"
  },
  {
    name: "kissing_heart",
    emoji: "😘"
  },
  {
    name: "kissing",
    emoji: "😗"
  },
  {
    name: "kissing_smiling_eyes",
    emoji: "😙"
  },
  {
    name: "kissing_closed_eyes",
    emoji: "😚"
  },
  {
    name: "stuck_out_tongue_winking_eye",
    emoji: "😜"
  },
  {
    name: "stuck_out_tongue_closed_eyes",
    emoji: "😝"
  },
  {
    name: "stuck_out_tongue",
    emoji: "😛"
  },
  {
    name: "money_mouth_face",
    emoji: "🤑"
  },
  {
    name: "nerd_face",
    emoji: "🤓"
  },
  {
    name: "sunglasses",
    emoji: "😎"
  },
  {
    name: "clown_face",
    emoji: "🤡"
  },
  {
    name: "cowboy_hat_face",
    emoji: "🤠"
  },
  {
    name: "hugs",
    emoji: "🤗"
  },
  {
    name: "smirk",
    emoji: "😏"
  },
  {
    name: "no_mouth",
    emoji: "😶"
  },
  {
    name: "neutral_face",
    emoji: "😐"
  },
  {
    name: "expressionless",
    emoji: "😑"
  },
  {
    name: "unamused",
    emoji: "😒"
  },
  {
    name: "roll_eyes",
    emoji: "🙄"
  },
  {
    name: "thinking",
    emoji: "🤔"
  },
  {
    name: "lying_face",
    emoji: "🤥"
  },
  {
    name: "flushed",
    emoji: "😳"
  },
  {
    name: "disappointed",
    emoji: "😞"
  },
  {
    name: "worried",
    emoji: "😟"
  },
  {
    name: "angry",
    emoji: "😠"
  },
  {
    name: "rage",
    emoji: "😡"
  },
  {
    name: "pensive",
    emoji: "😔"
  },
  {
    name: "confused",
    emoji: "😕"
  },
  {
    name: "slightly_frowning_face",
    emoji: "🙁"
  },
  {
    name: "frowning_face",
    emoji: "☹"
  },
  {
    name: "persevere",
    emoji: "😣"
  },
  {
    name: "confounded",
    emoji: "😖"
  },
  {
    name: "tired_face",
    emoji: "😫"
  },
  {
    name: "weary",
    emoji: "😩"
  },
  {
    name: "triumph",
    emoji: "😤"
  },
  {
    name: "open_mouth",
    emoji: "😮"
  },
  {
    name: "scream",
    emoji: "😱"
  },
  {
    name: "fearful",
    emoji: "😨"
  },
  {
    name: "cold_sweat",
    emoji: "😰"
  },
  {
    name: "hushed",
    emoji: "😯"
  },
  {
    name: "frowning_with_open_mouth",
    emoji: "😦"
  },
  {
    name: "anguished",
    emoji: "😧"
  },
  {
    name: "cry",
    emoji: "😢"
  },
  {
    name: "disappointed_relieved",
    emoji: "😥"
  },
  {
    name: "drooling_face",
    emoji: "🤤"
  },
  {
    name: "sleepy",
    emoji: "😪"
  },
  {
    name: "sweat",
    emoji: "😓"
  },
  {
    name: "sob",
    emoji: "😭"
  },
  {
    name: "dizzy_face",
    emoji: "😵"
  },
  {
    name: "astonished",
    emoji: "😲"
  },
  {
    name: "zipper_mouth_face",
    emoji: "🤐"
  },
  {
    name: "nauseated_face",
    emoji: "🤢"
  },
  {
    name: "sneezing_face",
    emoji: "🤧"
  },
  {
    name: "mask",
    emoji: "😷"
  },
  {
    name: "face_with_thermometer",
    emoji: "🤒"
  },
  {
    name: "face_with_head_bandage",
    emoji: "🤕"
  },
  {
    name: "sleeping",
    emoji: "😴"
  },
  {
    name: "zzz",
    emoji: "💤"
  },
  {
    name: "poop",
    emoji: "💩"
  },
  {
    name: "smiling_imp",
    emoji: "😈"
  },
  {
    name: "imp",
    emoji: "👿"
  },
  {
    name: "japanese_ogre",
    emoji: "👹"
  },
  {
    name: "japanese_goblin",
    emoji: "👺"
  },
  {
    name: "skull",
    emoji: "💀"
  },
  {
    name: "ghost",
    emoji: "👻"
  },
  {
    name: "alien",
    emoji: "👽"
  },
  {
    name: "robot",
    emoji: "🤖"
  },
  {
    name: "smiley_cat",
    emoji: "😺"
  },
  {
    name: "smile_cat",
    emoji: "😸"
  },
  {
    name: "joy_cat",
    emoji: "😹"
  },
  {
    name: "heart_eyes_cat",
    emoji: "😻"
  },
  {
    name: "smirk_cat",
    emoji: "😼"
  },
  {
    name: "kissing_cat",
    emoji: "😽"
  },
  {
    name: "scream_cat",
    emoji: "🙀"
  },
  {
    name: "crying_cat_face",
    emoji: "😿"
  },
  {
    name: "pouting_cat",
    emoji: "😾"
  },
  {
    name: "raised_hands",
    emoji: "🙌"
  },
  {
    name: "clap",
    emoji: "👏"
  },
  {
    name: "wave",
    emoji: "👋"
  },
  {
    name: "call_me_hand",
    emoji: "🤙"
  },
  {
    name: "+1",
    emoji: "👍"
  },
  {
    name: "-1",
    emoji: "👎"
  },
  {
    name: "facepunch",
    emoji: "👊"
  },
  {
    name: "fist",
    emoji: "✊"
  },
  {
    name: "fist_left",
    emoji: "🤛"
  },
  {
    name: "fist_right",
    emoji: "🤜"
  },
  {
    name: "v",
    emoji: "✌"
  },
  {
    name: "ok_hand",
    emoji: "👌"
  },
  {
    name: "raised_hand",
    emoji: "✋"
  },
  {
    name: "raised_back_of_hand",
    emoji: "🤚"
  },
  {
    name: "open_hands",
    emoji: "👐"
  },
  {
    name: "muscle",
    emoji: "💪"
  },
  {
    name: "pray",
    emoji: "🙏"
  },
  {
    name: "handshake",
    emoji: "🤝"
  },
  {
    name: "point_up",
    emoji: "☝"
  },
  {
    name: "point_up_2",
    emoji: "👆"
  },
  {
    name: "point_down",
    emoji: "👇"
  },
  {
    name: "point_left",
    emoji: "👈"
  },
  {
    name: "point_right",
    emoji: "👉"
  },
  {
    name: "fu",
    emoji: "🖕"
  },
  {
    name: "raised_hand_with_fingers_splayed",
    emoji: "🖐"
  },
  {
    name: "metal",
    emoji: "🤘"
  },
  {
    name: "crossed_fingers",
    emoji: "🤞"
  },
  {
    name: "vulcan_salute",
    emoji: "🖖"
  },
  {
    name: "writing_hand",
    emoji: "✍"
  },
  {
    name: "selfie",
    emoji: "🤳"
  },
  {
    name: "nail_care",
    emoji: "💅"
  },
  {
    name: "lips",
    emoji: "👄"
  },
  {
    name: "tongue",
    emoji: "👅"
  },
  {
    name: "ear",
    emoji: "👂"
  },
  {
    name: "nose",
    emoji: "👃"
  },
  {
    name: "eye",
    emoji: "👁"
  },
  {
    name: "eyes",
    emoji: "👀"
  },
  {
    name: "bust_in_silhouette",
    emoji: "👤"
  },
  {
    name: "busts_in_silhouette",
    emoji: "👥"
  },
  {
    name: "speaking_head",
    emoji: "🗣"
  },
  {
    name: "baby",
    emoji: "👶"
  },
  {
    name: "boy",
    emoji: "👦"
  },
  {
    name: "girl",
    emoji: "👧"
  },
  {
    name: "man",
    emoji: "👨"
  },
  {
    name: "woman",
    emoji: "👩"
  },
  {
    name: "blonde_woman",
    emoji: "👱‍♀️"
  },
  {
    name: "blonde_man",
    emoji: "👱"
  },
  {
    name: "older_man",
    emoji: "👴"
  },
  {
    name: "older_woman",
    emoji: "👵"
  },
  {
    name: "man_with_gua_pi_mao",
    emoji: "👲"
  },
  {
    name: "woman_with_turban",
    emoji: "👳‍♀️"
  },
  {
    name: "man_with_turban",
    emoji: "👳"
  },
  {
    name: "policewoman",
    emoji: "👮‍♀️"
  },
  {
    name: "policeman",
    emoji: "👮"
  },
  {
    name: "construction_worker_woman",
    emoji: "👷‍♀️"
  },
  {
    name: "construction_worker_man",
    emoji: "👷"
  },
  {
    name: "guardswoman",
    emoji: "💂‍♀️"
  },
  {
    name: "guardsman",
    emoji: "💂"
  },
  {
    name: "female_detective",
    emoji: "🕵️‍♀"
  },
  {
    name: "male_detective",
    emoji: "🕵"
  },
  {
    name: "woman_health_worker",
    emoji: "👩‍⚕️"
  },
  {
    name: "man_health_worker",
    emoji: "👨‍⚕️"
  },
  {
    name: "woman_farmer",
    emoji: "👩‍🌾"
  },
  {
    name: "man_farmer",
    emoji: "👨‍🌾"
  },
  {
    name: "woman_cook",
    emoji: "👩‍🍳"
  },
  {
    name: "man_cook",
    emoji: "👨‍🍳"
  },
  {
    name: "woman_student",
    emoji: "👩‍🎓"
  },
  {
    name: "man_student",
    emoji: "👨‍🎓"
  },
  {
    name: "woman_singer",
    emoji: "👩‍🎤"
  },
  {
    name: "man_singer",
    emoji: "👨‍🎤"
  },
  {
    name: "woman_teacher",
    emoji: "👩‍🏫"
  },
  {
    name: "man_teacher",
    emoji: "👨‍🏫"
  },
  {
    name: "woman_factory_worker",
    emoji: "👩‍🏭"
  },
  {
    name: "man_factory_worker",
    emoji: "👨‍🏭"
  },
  {
    name: "woman_technologist",
    emoji: "👩‍💻"
  },
  {
    name: "man_technologist",
    emoji: "👨‍💻"
  },
  {
    name: "woman_office_worker",
    emoji: "👩‍💼"
  },
  {
    name: "man_office_worker",
    emoji: "👨‍💼"
  },
  {
    name: "woman_mechanic",
    emoji: "👩‍🔧"
  },
  {
    name: "man_mechanic",
    emoji: "👨‍🔧"
  },
  {
    name: "woman_scientist",
    emoji: "👩‍🔬"
  },
  {
    name: "man_scientist",
    emoji: "👨‍🔬"
  },
  {
    name: "woman_artist",
    emoji: "👩‍🎨"
  },
  {
    name: "man_artist",
    emoji: "👨‍🎨"
  },
  {
    name: "woman_firefighter",
    emoji: "👩‍🚒"
  },
  {
    name: "man_firefighter",
    emoji: "👨‍🚒"
  },
  {
    name: "woman_pilot",
    emoji: "👩‍✈️"
  },
  {
    name: "man_pilot",
    emoji: "👨‍✈️"
  },
  {
    name: "woman_astronaut",
    emoji: "👩‍🚀"
  },
  {
    name: "man_astronaut",
    emoji: "👨‍🚀"
  },
  {
    name: "woman_judge",
    emoji: "👩‍⚖️"
  },
  {
    name: "man_judge",
    emoji: "👨‍⚖️"
  },
  {
    name: "mrs_claus",
    emoji: "🤶"
  },
  {
    name: "santa",
    emoji: "🎅"
  },
  {
    name: "angel",
    emoji: "👼"
  },
  {
    name: "pregnant_woman",
    emoji: "🤰"
  },
  {
    name: "princess",
    emoji: "👸"
  },
  {
    name: "prince",
    emoji: "🤴"
  },
  {
    name: "bride_with_veil",
    emoji: "👰"
  },
  {
    name: "person_in_tuxedo",
    emoji: "🤵"
  },
  {
    name: "running_woman",
    emoji: "🏃‍♀️"
  },
  {
    name: "running_man",
    emoji: "🏃"
  },
  {
    name: "walking_woman",
    emoji: "🚶‍♀️"
  },
  {
    name: "walking_man",
    emoji: "🚶"
  },
  {
    name: "dancer",
    emoji: "💃"
  },
  {
    name: "man_dancing",
    emoji: "🕺"
  },
  {
    name: "dancing_women",
    emoji: "👯"
  },
  {
    name: "dancing_men",
    emoji: "👯‍♂"
  },
  {
    name: "couple",
    emoji: "👫"
  },
  {
    name: "two_men_holding_hands",
    emoji: "👬"
  },
  {
    name: "two_women_holding_hands",
    emoji: "👭"
  },
  {
    name: "bowing_woman",
    emoji: "🙇‍♀️"
  },
  {
    name: "bowing_man",
    emoji: "🙇"
  },
  {
    name: "man_facepalming",
    emoji: "🤦‍♂️"
  },
  {
    name: "woman_facepalming",
    emoji: "🤦‍♀️"
  },
  {
    name: "woman_shrugging",
    emoji: "🤷‍♀️"
  },
  {
    name: "man_shrugging",
    emoji: "🤷‍♂️"
  },
  {
    name: "tipping_hand_woman",
    emoji: "💁‍♀️"
  },
  {
    name: "tipping_hand_man",
    emoji: "💁‍♂️"
  },
  {
    name: "no_good_woman",
    emoji: "🙅‍♀️"
  },
  {
    name: "no_good_man",
    emoji: "🙅‍♂️"
  },
  {
    name: "ok_woman",
    emoji: "🙆‍♀️"
  },
  {
    name: "ok_man",
    emoji: "🙆‍♂️"
  },
  {
    name: "raising_hand_woman",
    emoji: "🙋‍♀️"
  },
  {
    name: "raising_hand_man",
    emoji: "🙋‍♂️"
  },
  {
    name: "pouting_woman",
    emoji: "🙎‍♀️"
  },
  {
    name: "pouting_man",
    emoji: "🙎‍♂️"
  },
  {
    name: "frowning_woman",
    emoji: "🙍‍♀️"
  },
  {
    name: "frowning_man",
    emoji: "🙍‍♂️"
  },
  {
    name: "haircut_woman",
    emoji: "💇‍♀️"
  },
  {
    name: "haircut_man",
    emoji: "💇‍♂️"
  },
  {
    name: "massage_woman",
    emoji: "💆‍♀️"
  },
  {
    name: "massage_man",
    emoji: "💆‍♂️"
  },
  {
    name: "couple_with_heart",
    emoji: "💑"
  },
  {
    name: "couple_with_heart_woman_woman",
    emoji: "👩‍❤️‍👩"
  },
  {
    name: "couple_with_heart_man_man",
    emoji: "👨‍❤️‍👨"
  },
  {
    name: "couplekiss_man_woman",
    emoji: "💏"
  },
  {
    name: "couplekiss_woman_woman",
    emoji: "👩‍❤️‍💋‍👩"
  },
  {
    name: "couplekiss_man_man",
    emoji: "👨‍❤️‍💋‍👨"
  },
  {
    name: "family",
    emoji: "👪"
  },
  {
    name: "family_man_woman_girl",
    emoji: "👨‍👩‍👧"
  },
  {
    name: "family_man_woman_girl_boy",
    emoji: "👨‍👩‍👧‍👦"
  },
  {
    name: "family_man_woman_boy_boy",
    emoji: "👨‍👩‍👦‍👦"
  },
  {
    name: "family_man_woman_girl_girl",
    emoji: "👨‍👩‍👧‍👧"
  },
  {
    name: "family_woman_woman_boy",
    emoji: "👩‍👩‍👦"
  },
  {
    name: "family_woman_woman_girl",
    emoji: "👩‍👩‍👧"
  },
  {
    name: "family_woman_woman_girl_boy",
    emoji: "👩‍👩‍👧‍👦"
  },
  {
    name: "family_woman_woman_boy_boy",
    emoji: "👩‍👩‍👦‍👦"
  },
  {
    name: "family_woman_woman_girl_girl",
    emoji: "👩‍👩‍👧‍👧"
  },
  {
    name: "family_man_man_boy",
    emoji: "👨‍👨‍👦"
  },
  {
    name: "family_man_man_girl",
    emoji: "👨‍👨‍👧"
  },
  {
    name: "family_man_man_girl_boy",
    emoji: "👨‍👨‍👧‍👦"
  },
  {
    name: "family_man_man_boy_boy",
    emoji: "👨‍👨‍👦‍👦"
  },
  {
    name: "family_man_man_girl_girl",
    emoji: "👨‍👨‍👧‍👧"
  },
  {
    name: "family_woman_boy",
    emoji: "👩‍👦"
  },
  {
    name: "family_woman_girl",
    emoji: "👩‍👧"
  },
  {
    name: "family_woman_girl_boy",
    emoji: "👩‍👧‍👦"
  },
  {
    name: "family_woman_boy_boy",
    emoji: "👩‍👦‍👦"
  },
  {
    name: "family_woman_girl_girl",
    emoji: "👩‍👧‍👧"
  },
  {
    name: "family_man_boy",
    emoji: "👨‍👦"
  },
  {
    name: "family_man_girl",
    emoji: "👨‍👧"
  },
  {
    name: "family_man_girl_boy",
    emoji: "👨‍👧‍👦"
  },
  {
    name: "family_man_boy_boy",
    emoji: "👨‍👦‍👦"
  },
  {
    name: "family_man_girl_girl",
    emoji: "👨‍👧‍👧"
  },
  {
    name: "womans_clothes",
    emoji: "👚"
  },
  {
    name: "tshirt",
    emoji: "👕"
  },
  {
    name: "jeans",
    emoji: "👖"
  },
  {
    name: "necktie",
    emoji: "👔"
  },
  {
    name: "dress",
    emoji: "👗"
  },
  {
    name: "bikini",
    emoji: "👙"
  },
  {
    name: "kimono",
    emoji: "👘"
  },
  {
    name: "lipstick",
    emoji: "💄"
  },
  {
    name: "kiss",
    emoji: "💋"
  },
  {
    name: "footprints",
    emoji: "👣"
  },
  {
    name: "high_heel",
    emoji: "👠"
  },
  {
    name: "sandal",
    emoji: "👡"
  },
  {
    name: "boot",
    emoji: "👢"
  },
  {
    name: "mans_shoe",
    emoji: "👞"
  },
  {
    name: "athletic_shoe",
    emoji: "👟"
  },
  {
    name: "womans_hat",
    emoji: "👒"
  },
  {
    name: "tophat",
    emoji: "🎩"
  },
  {
    name: "rescue_worker_helmet",
    emoji: "⛑"
  },
  {
    name: "mortar_board",
    emoji: "🎓"
  },
  {
    name: "crown",
    emoji: "👑"
  },
  {
    name: "school_satchel",
    emoji: "🎒"
  },
  {
    name: "pouch",
    emoji: "👝"
  },
  {
    name: "purse",
    emoji: "👛"
  },
  {
    name: "handbag",
    emoji: "👜"
  },
  {
    name: "briefcase",
    emoji: "💼"
  },
  {
    name: "eyeglasses",
    emoji: "👓"
  },
  {
    name: "dark_sunglasses",
    emoji: "🕶"
  },
  {
    name: "ring",
    emoji: "💍"
  },
  {
    name: "closed_umbrella",
    emoji: "🌂"
  },
  {
    name: "dog",
    emoji: "🐶"
  },
  {
    name: "cat",
    emoji: "🐱"
  },
  {
    name: "mouse",
    emoji: "🐭"
  },
  {
    name: "hamster",
    emoji: "🐹"
  },
  {
    name: "rabbit",
    emoji: "🐰"
  },
  {
    name: "fox_face",
    emoji: "🦊"
  },
  {
    name: "bear",
    emoji: "🐻"
  },
  {
    name: "panda_face",
    emoji: "🐼"
  },
  {
    name: "koala",
    emoji: "🐨"
  },
  {
    name: "tiger",
    emoji: "🐯"
  },
  {
    name: "lion",
    emoji: "🦁"
  },
  {
    name: "cow",
    emoji: "🐮"
  },
  {
    name: "pig",
    emoji: "🐷"
  },
  {
    name: "pig_nose",
    emoji: "🐽"
  },
  {
    name: "frog",
    emoji: "🐸"
  },
  {
    name: "squid",
    emoji: "🦑"
  },
  {
    name: "octopus",
    emoji: "🐙"
  },
  {
    name: "shrimp",
    emoji: "🦐"
  },
  {
    name: "monkey_face",
    emoji: "🐵"
  },
  {
    name: "gorilla",
    emoji: "🦍"
  },
  {
    name: "see_no_evil",
    emoji: "🙈"
  },
  {
    name: "hear_no_evil",
    emoji: "🙉"
  },
  {
    name: "speak_no_evil",
    emoji: "🙊"
  },
  {
    name: "monkey",
    emoji: "🐒"
  },
  {
    name: "chicken",
    emoji: "🐔"
  },
  {
    name: "penguin",
    emoji: "🐧"
  },
  {
    name: "bird",
    emoji: "🐦"
  },
  {
    name: "baby_chick",
    emoji: "🐤"
  },
  {
    name: "hatching_chick",
    emoji: "🐣"
  },
  {
    name: "hatched_chick",
    emoji: "🐥"
  },
  {
    name: "duck",
    emoji: "🦆"
  },
  {
    name: "eagle",
    emoji: "🦅"
  },
  {
    name: "owl",
    emoji: "🦉"
  },
  {
    name: "bat",
    emoji: "🦇"
  },
  {
    name: "wolf",
    emoji: "🐺"
  },
  {
    name: "boar",
    emoji: "🐗"
  },
  {
    name: "horse",
    emoji: "🐴"
  },
  {
    name: "unicorn",
    emoji: "🦄"
  },
  {
    name: "honeybee",
    emoji: "🐝"
  },
  {
    name: "bug",
    emoji: "🐛"
  },
  {
    name: "butterfly",
    emoji: "🦋"
  },
  {
    name: "snail",
    emoji: "🐌"
  },
  {
    name: "lady_beetle",
    emoji: "🐞"
  },
  {
    name: "ant",
    emoji: "🐜"
  },
  {
    name: "spider",
    emoji: "🕷"
  },
  {
    name: "scorpion",
    emoji: "🦂"
  },
  {
    name: "crab",
    emoji: "🦀"
  },
  {
    name: "snake",
    emoji: "🐍"
  },
  {
    name: "lizard",
    emoji: "🦎"
  },
  {
    name: "turtle",
    emoji: "🐢"
  },
  {
    name: "tropical_fish",
    emoji: "🐠"
  },
  {
    name: "fish",
    emoji: "🐟"
  },
  {
    name: "blowfish",
    emoji: "🐡"
  },
  {
    name: "dolphin",
    emoji: "🐬"
  },
  {
    name: "shark",
    emoji: "🦈"
  },
  {
    name: "whale",
    emoji: "🐳"
  },
  {
    name: "whale2",
    emoji: "🐋"
  },
  {
    name: "crocodile",
    emoji: "🐊"
  },
  {
    name: "leopard",
    emoji: "🐆"
  },
  {
    name: "tiger2",
    emoji: "🐅"
  },
  {
    name: "water_buffalo",
    emoji: "🐃"
  },
  {
    name: "ox",
    emoji: "🐂"
  },
  {
    name: "cow2",
    emoji: "🐄"
  },
  {
    name: "deer",
    emoji: "🦌"
  },
  {
    name: "dromedary_camel",
    emoji: "🐪"
  },
  {
    name: "camel",
    emoji: "🐫"
  },
  {
    name: "elephant",
    emoji: "🐘"
  },
  {
    name: "rhinoceros",
    emoji: "🦏"
  },
  {
    name: "goat",
    emoji: "🐐"
  },
  {
    name: "ram",
    emoji: "🐏"
  },
  {
    name: "sheep",
    emoji: "🐑"
  },
  {
    name: "racehorse",
    emoji: "🐎"
  },
  {
    name: "pig2",
    emoji: "🐖"
  },
  {
    name: "rat",
    emoji: "🐀"
  },
  {
    name: "mouse2",
    emoji: "🐁"
  },
  {
    name: "rooster",
    emoji: "🐓"
  },
  {
    name: "turkey",
    emoji: "🦃"
  },
  {
    name: "dove",
    emoji: "🕊"
  },
  {
    name: "dog2",
    emoji: "🐕"
  },
  {
    name: "poodle",
    emoji: "🐩"
  },
  {
    name: "cat2",
    emoji: "🐈"
  },
  {
    name: "rabbit2",
    emoji: "🐇"
  },
  {
    name: "chipmunk",
    emoji: "🐿"
  },
  {
    name: "paw_prints",
    emoji: "🐾"
  },
  {
    name: "dragon",
    emoji: "🐉"
  },
  {
    name: "dragon_face",
    emoji: "🐲"
  },
  {
    name: "cactus",
    emoji: "🌵"
  },
  {
    name: "christmas_tree",
    emoji: "🎄"
  },
  {
    name: "evergreen_tree",
    emoji: "🌲"
  },
  {
    name: "deciduous_tree",
    emoji: "🌳"
  },
  {
    name: "palm_tree",
    emoji: "🌴"
  },
  {
    name: "seedling",
    emoji: "🌱"
  },
  {
    name: "herb",
    emoji: "🌿"
  },
  {
    name: "shamrock",
    emoji: "☘"
  },
  {
    name: "four_leaf_clover",
    emoji: "🍀"
  },
  {
    name: "bamboo",
    emoji: "🎍"
  },
  {
    name: "tanabata_tree",
    emoji: "🎋"
  },
  {
    name: "leaves",
    emoji: "🍃"
  },
  {
    name: "fallen_leaf",
    emoji: "🍂"
  },
  {
    name: "maple_leaf",
    emoji: "🍁"
  },
  {
    name: "ear_of_rice",
    emoji: "🌾"
  },
  {
    name: "hibiscus",
    emoji: "🌺"
  },
  {
    name: "sunflower",
    emoji: "🌻"
  },
  {
    name: "rose",
    emoji: "🌹"
  },
  {
    name: "wilted_flower",
    emoji: "🥀"
  },
  {
    name: "tulip",
    emoji: "🌷"
  },
  {
    name: "blossom",
    emoji: "🌼"
  },
  {
    name: "cherry_blossom",
    emoji: "🌸"
  },
  {
    name: "bouquet",
    emoji: "💐"
  },
  {
    name: "mushroom",
    emoji: "🍄"
  },
  {
    name: "chestnut",
    emoji: "🌰"
  },
  {
    name: "jack_o_lantern",
    emoji: "🎃"
  },
  {
    name: "shell",
    emoji: "🐚"
  },
  {
    name: "spider_web",
    emoji: "🕸"
  },
  {
    name: "earth_americas",
    emoji: "🌎"
  },
  {
    name: "earth_africa",
    emoji: "🌍"
  },
  {
    name: "earth_asia",
    emoji: "🌏"
  },
  {
    name: "full_moon",
    emoji: "🌕"
  },
  {
    name: "waning_gibbous_moon",
    emoji: "🌖"
  },
  {
    name: "last_quarter_moon",
    emoji: "🌗"
  },
  {
    name: "waning_crescent_moon",
    emoji: "🌘"
  },
  {
    name: "new_moon",
    emoji: "🌑"
  },
  {
    name: "waxing_crescent_moon",
    emoji: "🌒"
  },
  {
    name: "first_quarter_moon",
    emoji: "🌓"
  },
  {
    name: "waxing_gibbous_moon",
    emoji: "🌔"
  },
  {
    name: "new_moon_with_face",
    emoji: "🌚"
  },
  {
    name: "full_moon_with_face",
    emoji: "🌝"
  },
  {
    name: "first_quarter_moon_with_face",
    emoji: "🌛"
  },
  {
    name: "last_quarter_moon_with_face",
    emoji: "🌜"
  },
  {
    name: "sun_with_face",
    emoji: "🌞"
  },
  {
    name: "crescent_moon",
    emoji: "🌙"
  },
  {
    name: "star",
    emoji: "⭐"
  },
  {
    name: "star2",
    emoji: "🌟"
  },
  {
    name: "dizzy",
    emoji: "💫"
  },
  {
    name: "sparkles",
    emoji: "✨"
  },
  {
    name: "comet",
    emoji: "☄"
  },
  {
    name: "sunny",
    emoji: "☀"
  },
  {
    name: "sun_behind_small_cloud",
    emoji: "🌤"
  },
  {
    name: "partly_sunny",
    emoji: "⛅"
  },
  {
    name: "sun_behind_large_cloud",
    emoji: "🌥"
  },
  {
    name: "sun_behind_rain_cloud",
    emoji: "🌦"
  },
  {
    name: "cloud",
    emoji: "☁"
  },
  {
    name: "cloud_with_rain",
    emoji: "🌧"
  },
  {
    name: "cloud_with_lightning_and_rain",
    emoji: "⛈"
  },
  {
    name: "cloud_with_lightning",
    emoji: "🌩"
  },
  {
    name: "zap",
    emoji: "⚡"
  },
  {
    name: "fire",
    emoji: "🔥"
  },
  {
    name: "boom",
    emoji: "💥"
  },
  {
    name: "snowflake",
    emoji: "❄"
  },
  {
    name: "cloud_with_snow",
    emoji: "🌨"
  },
  {
    name: "snowman",
    emoji: "⛄"
  },
  {
    name: "snowman_with_snow",
    emoji: "☃"
  },
  {
    name: "wind_face",
    emoji: "🌬"
  },
  {
    name: "dash",
    emoji: "💨"
  },
  {
    name: "tornado",
    emoji: "🌪"
  },
  {
    name: "fog",
    emoji: "🌫"
  },
  {
    name: "open_umbrella",
    emoji: "☂"
  },
  {
    name: "umbrella",
    emoji: "☔"
  },
  {
    name: "droplet",
    emoji: "💧"
  },
  {
    name: "sweat_drops",
    emoji: "💦"
  },
  {
    name: "ocean",
    emoji: "🌊"
  },
  {
    name: "green_apple",
    emoji: "🍏"
  },
  {
    name: "apple",
    emoji: "🍎"
  },
  {
    name: "pear",
    emoji: "🍐"
  },
  {
    name: "tangerine",
    emoji: "🍊"
  },
  {
    name: "lemon",
    emoji: "🍋"
  },
  {
    name: "banana",
    emoji: "🍌"
  },
  {
    name: "watermelon",
    emoji: "🍉"
  },
  {
    name: "grapes",
    emoji: "🍇"
  },
  {
    name: "strawberry",
    emoji: "🍓"
  },
  {
    name: "melon",
    emoji: "🍈"
  },
  {
    name: "cherries",
    emoji: "🍒"
  },
  {
    name: "peach",
    emoji: "🍑"
  },
  {
    name: "pineapple",
    emoji: "🍍"
  },
  {
    name: "kiwi_fruit",
    emoji: "🥝"
  },
  {
    name: "avocado",
    emoji: "🥑"
  },
  {
    name: "tomato",
    emoji: "🍅"
  },
  {
    name: "eggplant",
    emoji: "🍆"
  },
  {
    name: "cucumber",
    emoji: "🥒"
  },
  {
    name: "carrot",
    emoji: "🥕"
  },
  {
    name: "hot_pepper",
    emoji: "🌶"
  },
  {
    name: "potato",
    emoji: "🥔"
  },
  {
    name: "corn",
    emoji: "🌽"
  },
  {
    name: "sweet_potato",
    emoji: "🍠"
  },
  {
    name: "peanuts",
    emoji: "🥜"
  },
  {
    name: "honey_pot",
    emoji: "🍯"
  },
  {
    name: "croissant",
    emoji: "🥐"
  },
  {
    name: "bread",
    emoji: "🍞"
  },
  {
    name: "baguette_bread",
    emoji: "🥖"
  },
  {
    name: "cheese",
    emoji: "🧀"
  },
  {
    name: "egg",
    emoji: "🥚"
  },
  {
    name: "bacon",
    emoji: "🥓"
  },
  {
    name: "pancakes",
    emoji: "🥞"
  },
  {
    name: "poultry_leg",
    emoji: "🍗"
  },
  {
    name: "meat_on_bone",
    emoji: "🍖"
  },
  {
    name: "fried_shrimp",
    emoji: "🍤"
  },
  {
    name: "fried_egg",
    emoji: "🍳"
  },
  {
    name: "hamburger",
    emoji: "🍔"
  },
  {
    name: "fries",
    emoji: "🍟"
  },
  {
    name: "stuffed_flatbread",
    emoji: "🥙"
  },
  {
    name: "hotdog",
    emoji: "🌭"
  },
  {
    name: "pizza",
    emoji: "🍕"
  },
  {
    name: "spaghetti",
    emoji: "🍝"
  },
  {
    name: "taco",
    emoji: "🌮"
  },
  {
    name: "burrito",
    emoji: "🌯"
  },
  {
    name: "green_salad",
    emoji: "🥗"
  },
  {
    name: "shallow_pan_of_food",
    emoji: "🥘"
  },
  {
    name: "ramen",
    emoji: "🍜"
  },
  {
    name: "stew",
    emoji: "🍲"
  },
  {
    name: "fish_cake",
    emoji: "🍥"
  },
  {
    name: "sushi",
    emoji: "🍣"
  },
  {
    name: "bento",
    emoji: "🍱"
  },
  {
    name: "curry",
    emoji: "🍛"
  },
  {
    name: "rice_ball",
    emoji: "🍙"
  },
  {
    name: "rice",
    emoji: "🍚"
  },
  {
    name: "rice_cracker",
    emoji: "🍘"
  },
  {
    name: "oden",
    emoji: "🍢"
  },
  {
    name: "dango",
    emoji: "🍡"
  },
  {
    name: "shaved_ice",
    emoji: "🍧"
  },
  {
    name: "ice_cream",
    emoji: "🍨"
  },
  {
    name: "icecream",
    emoji: "🍦"
  },
  {
    name: "cake",
    emoji: "🍰"
  },
  {
    name: "birthday",
    emoji: "🎂"
  },
  {
    name: "custard",
    emoji: "🍮"
  },
  {
    name: "candy",
    emoji: "🍬"
  },
  {
    name: "lollipop",
    emoji: "🍭"
  },
  {
    name: "chocolate_bar",
    emoji: "🍫"
  },
  {
    name: "popcorn",
    emoji: "🍿"
  },
  {
    name: "doughnut",
    emoji: "🍩"
  },
  {
    name: "cookie",
    emoji: "🍪"
  },
  {
    name: "milk_glass",
    emoji: "🥛"
  },
  {
    name: "beer",
    emoji: "🍺"
  },
  {
    name: "beers",
    emoji: "🍻"
  },
  {
    name: "clinking_glasses",
    emoji: "🥂"
  },
  {
    name: "wine_glass",
    emoji: "🍷"
  },
  {
    name: "tumbler_glass",
    emoji: "🥃"
  },
  {
    name: "cocktail",
    emoji: "🍸"
  },
  {
    name: "tropical_drink",
    emoji: "🍹"
  },
  {
    name: "champagne",
    emoji: "🍾"
  },
  {
    name: "sake",
    emoji: "🍶"
  },
  {
    name: "tea",
    emoji: "🍵"
  },
  {
    name: "coffee",
    emoji: "☕"
  },
  {
    name: "baby_bottle",
    emoji: "🍼"
  },
  {
    name: "spoon",
    emoji: "🥄"
  },
  {
    name: "fork_and_knife",
    emoji: "🍴"
  },
  {
    name: "plate_with_cutlery",
    emoji: "🍽"
  },
  {
    name: "soccer",
    emoji: "⚽"
  },
  {
    name: "basketball",
    emoji: "🏀"
  },
  {
    name: "football",
    emoji: "🏈"
  },
  {
    name: "baseball",
    emoji: "⚾"
  },
  {
    name: "tennis",
    emoji: "🎾"
  },
  {
    name: "volleyball",
    emoji: "🏐"
  },
  {
    name: "rugby_football",
    emoji: "🏉"
  },
  {
    name: "8ball",
    emoji: "🎱"
  },
  {
    name: "golf",
    emoji: "⛳"
  },
  {
    name: "golfing_woman",
    emoji: "🏌️‍♀"
  },
  {
    name: "golfing_man",
    emoji: "🏌"
  },
  {
    name: "ping_pong",
    emoji: "🏓"
  },
  {
    name: "badminton",
    emoji: "🏸"
  },
  {
    name: "goal_net",
    emoji: "🥅"
  },
  {
    name: "ice_hockey",
    emoji: "🏒"
  },
  {
    name: "field_hockey",
    emoji: "🏑"
  },
  {
    name: "cricket_bat_and_ball",
    emoji: "🏏"
  },
  {
    name: "ski",
    emoji: "🎿"
  },
  {
    name: "skier",
    emoji: "⛷"
  },
  {
    name: "snowboarder",
    emoji: "🏂"
  },
  {
    name: "person_fencing",
    emoji: "🤺"
  },
  {
    name: "women_wrestling",
    emoji: "🤼‍♀"
  },
  {
    name: "men_wrestling",
    emoji: "🤼‍♂"
  },
  {
    name: "woman_cartwheeling",
    emoji: "🤸‍♀️"
  },
  {
    name: "man_cartwheeling",
    emoji: "🤸‍♂️"
  },
  {
    name: "woman_playing_handball",
    emoji: "🤾‍♀️"
  },
  {
    name: "man_playing_handball",
    emoji: "🤾‍♂️"
  },
  {
    name: "ice_skate",
    emoji: "⛸"
  },
  {
    name: "bow_and_arrow",
    emoji: "🏹"
  },
  {
    name: "fishing_pole_and_fish",
    emoji: "🎣"
  },
  {
    name: "boxing_glove",
    emoji: "🥊"
  },
  {
    name: "martial_arts_uniform",
    emoji: "🥋"
  },
  {
    name: "rowing_woman",
    emoji: "🚣‍♀️"
  },
  {
    name: "rowing_man",
    emoji: "🚣"
  },
  {
    name: "swimming_woman",
    emoji: "🏊‍♀️"
  },
  {
    name: "swimming_man",
    emoji: "🏊"
  },
  {
    name: "woman_playing_water_polo",
    emoji: "🤽‍♀️"
  },
  {
    name: "man_playing_water_polo",
    emoji: "🤽‍♂️"
  },
  {
    name: "surfing_woman",
    emoji: "🏄‍♀️"
  },
  {
    name: "surfing_man",
    emoji: "🏄"
  },
  {
    name: "bath",
    emoji: "🛀"
  },
  {
    name: "basketball_woman",
    emoji: "⛹️‍♀"
  },
  {
    name: "basketball_man",
    emoji: "⛹"
  },
  {
    name: "weight_lifting_woman",
    emoji: "🏋️‍♀"
  },
  {
    name: "weight_lifting_man",
    emoji: "🏋"
  },
  {
    name: "biking_woman",
    emoji: "🚴‍♀️"
  },
  {
    name: "biking_man",
    emoji: "🚴"
  },
  {
    name: "mountain_biking_woman",
    emoji: "🚵‍♀️"
  },
  {
    name: "mountain_biking_man",
    emoji: "🚵"
  },
  {
    name: "horse_racing",
    emoji: "🏇"
  },
  {
    name: "business_suit_levitating",
    emoji: "🕴"
  },
  {
    name: "trophy",
    emoji: "🏆"
  },
  {
    name: "running_shirt_with_sash",
    emoji: "🎽"
  },
  {
    name: "medal_sports",
    emoji: "🏅"
  },
  {
    name: "medal_military",
    emoji: "🎖"
  },
  {
    name: "1st_place_medal",
    emoji: "🥇"
  },
  {
    name: "2nd_place_medal",
    emoji: "🥈"
  },
  {
    name: "3rd_place_medal",
    emoji: "🥉"
  },
  {
    name: "reminder_ribbon",
    emoji: "🎗"
  },
  {
    name: "rosette",
    emoji: "🏵"
  },
  {
    name: "ticket",
    emoji: "🎫"
  },
  {
    name: "tickets",
    emoji: "🎟"
  },
  {
    name: "performing_arts",
    emoji: "🎭"
  },
  {
    name: "art",
    emoji: "🎨"
  },
  {
    name: "circus_tent",
    emoji: "🎪"
  },
  {
    name: "woman_juggling",
    emoji: "🤹‍♀️"
  },
  {
    name: "man_juggling",
    emoji: "🤹‍♂️"
  },
  {
    name: "microphone",
    emoji: "🎤"
  },
  {
    name: "headphones",
    emoji: "🎧"
  },
  {
    name: "musical_score",
    emoji: "🎼"
  },
  {
    name: "musical_keyboard",
    emoji: "🎹"
  },
  {
    name: "drum",
    emoji: "🥁"
  },
  {
    name: "saxophone",
    emoji: "🎷"
  },
  {
    name: "trumpet",
    emoji: "🎺"
  },
  {
    name: "guitar",
    emoji: "🎸"
  },
  {
    name: "violin",
    emoji: "🎻"
  },
  {
    name: "clapper",
    emoji: "🎬"
  },
  {
    name: "video_game",
    emoji: "🎮"
  },
  {
    name: "space_invader",
    emoji: "👾"
  },
  {
    name: "dart",
    emoji: "🎯"
  },
  {
    name: "game_die",
    emoji: "🎲"
  },
  {
    name: "slot_machine",
    emoji: "🎰"
  },
  {
    name: "bowling",
    emoji: "🎳"
  },
  {
    name: "red_car",
    emoji: "🚗"
  },
  {
    name: "taxi",
    emoji: "🚕"
  },
  {
    name: "blue_car",
    emoji: "🚙"
  },
  {
    name: "bus",
    emoji: "🚌"
  },
  {
    name: "trolleybus",
    emoji: "🚎"
  },
  {
    name: "racing_car",
    emoji: "🏎"
  },
  {
    name: "police_car",
    emoji: "🚓"
  },
  {
    name: "ambulance",
    emoji: "🚑"
  },
  {
    name: "fire_engine",
    emoji: "🚒"
  },
  {
    name: "minibus",
    emoji: "🚐"
  },
  {
    name: "truck",
    emoji: "🚚"
  },
  {
    name: "articulated_lorry",
    emoji: "🚛"
  },
  {
    name: "tractor",
    emoji: "🚜"
  },
  {
    name: "kick_scooter",
    emoji: "🛴"
  },
  {
    name: "motorcycle",
    emoji: "🏍"
  },
  {
    name: "bike",
    emoji: "🚲"
  },
  {
    name: "motor_scooter",
    emoji: "🛵"
  },
  {
    name: "rotating_light",
    emoji: "🚨"
  },
  {
    name: "oncoming_police_car",
    emoji: "🚔"
  },
  {
    name: "oncoming_bus",
    emoji: "🚍"
  },
  {
    name: "oncoming_automobile",
    emoji: "🚘"
  },
  {
    name: "oncoming_taxi",
    emoji: "🚖"
  },
  {
    name: "aerial_tramway",
    emoji: "🚡"
  },
  {
    name: "mountain_cableway",
    emoji: "🚠"
  },
  {
    name: "suspension_railway",
    emoji: "🚟"
  },
  {
    name: "railway_car",
    emoji: "🚃"
  },
  {
    name: "train",
    emoji: "🚋"
  },
  {
    name: "monorail",
    emoji: "🚝"
  },
  {
    name: "bullettrain_side",
    emoji: "🚄"
  },
  {
    name: "bullettrain_front",
    emoji: "🚅"
  },
  {
    name: "light_rail",
    emoji: "🚈"
  },
  {
    name: "mountain_railway",
    emoji: "🚞"
  },
  {
    name: "steam_locomotive",
    emoji: "🚂"
  },
  {
    name: "train2",
    emoji: "🚆"
  },
  {
    name: "metro",
    emoji: "🚇"
  },
  {
    name: "tram",
    emoji: "🚊"
  },
  {
    name: "station",
    emoji: "🚉"
  },
  {
    name: "helicopter",
    emoji: "🚁"
  },
  {
    name: "small_airplane",
    emoji: "🛩"
  },
  {
    name: "airplane",
    emoji: "✈"
  },
  {
    name: "flight_departure",
    emoji: "🛫"
  },
  {
    name: "flight_arrival",
    emoji: "🛬"
  },
  {
    name: "sailboat",
    emoji: "⛵"
  },
  {
    name: "motor_boat",
    emoji: "🛥"
  },
  {
    name: "speedboat",
    emoji: "🚤"
  },
  {
    name: "ferry",
    emoji: "⛴"
  },
  {
    name: "passenger_ship",
    emoji: "🛳"
  },
  {
    name: "rocket",
    emoji: "🚀"
  },
  {
    name: "artificial_satellite",
    emoji: "🛰"
  },
  {
    name: "seat",
    emoji: "💺"
  },
  {
    name: "canoe",
    emoji: "🛶"
  },
  {
    name: "anchor",
    emoji: "⚓"
  },
  {
    name: "construction",
    emoji: "🚧"
  },
  {
    name: "fuelpump",
    emoji: "⛽"
  },
  {
    name: "busstop",
    emoji: "🚏"
  },
  {
    name: "vertical_traffic_light",
    emoji: "🚦"
  },
  {
    name: "traffic_light",
    emoji: "🚥"
  },
  {
    name: "checkered_flag",
    emoji: "🏁"
  },
  {
    name: "ship",
    emoji: "🚢"
  },
  {
    name: "ferris_wheel",
    emoji: "🎡"
  },
  {
    name: "roller_coaster",
    emoji: "🎢"
  },
  {
    name: "carousel_horse",
    emoji: "🎠"
  },
  {
    name: "building_construction",
    emoji: "🏗"
  },
  {
    name: "foggy",
    emoji: "🌁"
  },
  {
    name: "tokyo_tower",
    emoji: "🗼"
  },
  {
    name: "factory",
    emoji: "🏭"
  },
  {
    name: "fountain",
    emoji: "⛲"
  },
  {
    name: "rice_scene",
    emoji: "🎑"
  },
  {
    name: "mountain",
    emoji: "⛰"
  },
  {
    name: "mountain_snow",
    emoji: "🏔"
  },
  {
    name: "mount_fuji",
    emoji: "🗻"
  },
  {
    name: "volcano",
    emoji: "🌋"
  },
  {
    name: "japan",
    emoji: "🗾"
  },
  {
    name: "camping",
    emoji: "🏕"
  },
  {
    name: "tent",
    emoji: "⛺"
  },
  {
    name: "national_park",
    emoji: "🏞"
  },
  {
    name: "motorway",
    emoji: "🛣"
  },
  {
    name: "railway_track",
    emoji: "🛤"
  },
  {
    name: "sunrise",
    emoji: "🌅"
  },
  {
    name: "sunrise_over_mountains",
    emoji: "🌄"
  },
  {
    name: "desert",
    emoji: "🏜"
  },
  {
    name: "beach_umbrella",
    emoji: "🏖"
  },
  {
    name: "desert_island",
    emoji: "🏝"
  },
  {
    name: "city_sunrise",
    emoji: "🌇"
  },
  {
    name: "city_sunset",
    emoji: "🌆"
  },
  {
    name: "cityscape",
    emoji: "🏙"
  },
  {
    name: "night_with_stars",
    emoji: "🌃"
  },
  {
    name: "bridge_at_night",
    emoji: "🌉"
  },
  {
    name: "milky_way",
    emoji: "🌌"
  },
  {
    name: "stars",
    emoji: "🌠"
  },
  {
    name: "sparkler",
    emoji: "🎇"
  },
  {
    name: "fireworks",
    emoji: "🎆"
  },
  {
    name: "rainbow",
    emoji: "🌈"
  },
  {
    name: "houses",
    emoji: "🏘"
  },
  {
    name: "european_castle",
    emoji: "🏰"
  },
  {
    name: "japanese_castle",
    emoji: "🏯"
  },
  {
    name: "stadium",
    emoji: "🏟"
  },
  {
    name: "statue_of_liberty",
    emoji: "🗽"
  },
  {
    name: "house",
    emoji: "🏠"
  },
  {
    name: "house_with_garden",
    emoji: "🏡"
  },
  {
    name: "derelict_house",
    emoji: "🏚"
  },
  {
    name: "office",
    emoji: "🏢"
  },
  {
    name: "department_store",
    emoji: "🏬"
  },
  {
    name: "post_office",
    emoji: "🏣"
  },
  {
    name: "european_post_office",
    emoji: "🏤"
  },
  {
    name: "hospital",
    emoji: "🏥"
  },
  {
    name: "bank",
    emoji: "🏦"
  },
  {
    name: "hotel",
    emoji: "🏨"
  },
  {
    name: "convenience_store",
    emoji: "🏪"
  },
  {
    name: "school",
    emoji: "🏫"
  },
  {
    name: "love_hotel",
    emoji: "🏩"
  },
  {
    name: "wedding",
    emoji: "💒"
  },
  {
    name: "classical_building",
    emoji: "🏛"
  },
  {
    name: "church",
    emoji: "⛪"
  },
  {
    name: "mosque",
    emoji: "🕌"
  },
  {
    name: "synagogue",
    emoji: "🕍"
  },
  {
    name: "kaaba",
    emoji: "🕋"
  },
  {
    name: "shinto_shrine",
    emoji: "⛩"
  },
  {
    name: "watch",
    emoji: "⌚"
  },
  {
    name: "iphone",
    emoji: "📱"
  },
  {
    name: "calling",
    emoji: "📲"
  },
  {
    name: "computer",
    emoji: "💻"
  },
  {
    name: "keyboard",
    emoji: "⌨"
  },
  {
    name: "desktop_computer",
    emoji: "🖥"
  },
  {
    name: "printer",
    emoji: "🖨"
  },
  {
    name: "computer_mouse",
    emoji: "🖱"
  },
  {
    name: "trackball",
    emoji: "🖲"
  },
  {
    name: "joystick",
    emoji: "🕹"
  },
  {
    name: "clamp",
    emoji: "🗜"
  },
  {
    name: "minidisc",
    emoji: "💽"
  },
  {
    name: "floppy_disk",
    emoji: "💾"
  },
  {
    name: "cd",
    emoji: "💿"
  },
  {
    name: "dvd",
    emoji: "📀"
  },
  {
    name: "vhs",
    emoji: "📼"
  },
  {
    name: "camera",
    emoji: "📷"
  },
  {
    name: "camera_flash",
    emoji: "📸"
  },
  {
    name: "video_camera",
    emoji: "📹"
  },
  {
    name: "movie_camera",
    emoji: "🎥"
  },
  {
    name: "film_projector",
    emoji: "📽"
  },
  {
    name: "film_strip",
    emoji: "🎞"
  },
  {
    name: "telephone_receiver",
    emoji: "📞"
  },
  {
    name: "phone",
    emoji: "☎"
  },
  {
    name: "pager",
    emoji: "📟"
  },
  {
    name: "fax",
    emoji: "📠"
  },
  {
    name: "tv",
    emoji: "📺"
  },
  {
    name: "radio",
    emoji: "📻"
  },
  {
    name: "studio_microphone",
    emoji: "🎙"
  },
  {
    name: "level_slider",
    emoji: "🎚"
  },
  {
    name: "control_knobs",
    emoji: "🎛"
  },
  {
    name: "stopwatch",
    emoji: "⏱"
  },
  {
    name: "timer_clock",
    emoji: "⏲"
  },
  {
    name: "alarm_clock",
    emoji: "⏰"
  },
  {
    name: "mantelpiece_clock",
    emoji: "🕰"
  },
  {
    name: "hourglass_flowing_sand",
    emoji: "⏳"
  },
  {
    name: "hourglass",
    emoji: "⌛"
  },
  {
    name: "satellite",
    emoji: "📡"
  },
  {
    name: "battery",
    emoji: "🔋"
  },
  {
    name: "electric_plug",
    emoji: "🔌"
  },
  {
    name: "bulb",
    emoji: "💡"
  },
  {
    name: "flashlight",
    emoji: "🔦"
  },
  {
    name: "candle",
    emoji: "🕯"
  },
  {
    name: "wastebasket",
    emoji: "🗑"
  },
  {
    name: "oil_drum",
    emoji: "🛢"
  },
  {
    name: "money_with_wings",
    emoji: "💸"
  },
  {
    name: "dollar",
    emoji: "💵"
  },
  {
    name: "yen",
    emoji: "💴"
  },
  {
    name: "euro",
    emoji: "💶"
  },
  {
    name: "pound",
    emoji: "💷"
  },
  {
    name: "moneybag",
    emoji: "💰"
  },
  {
    name: "credit_card",
    emoji: "💳"
  },
  {
    name: "gem",
    emoji: "💎"
  },
  {
    name: "balance_scale",
    emoji: "⚖"
  },
  {
    name: "wrench",
    emoji: "🔧"
  },
  {
    name: "hammer",
    emoji: "🔨"
  },
  {
    name: "hammer_and_pick",
    emoji: "⚒"
  },
  {
    name: "hammer_and_wrench",
    emoji: "🛠"
  },
  {
    name: "pick",
    emoji: "⛏"
  },
  {
    name: "nut_and_bolt",
    emoji: "🔩"
  },
  {
    name: "gear",
    emoji: "⚙"
  },
  {
    name: "chains",
    emoji: "⛓"
  },
  {
    name: "gun",
    emoji: "🔫"
  },
  {
    name: "bomb",
    emoji: "💣"
  },
  {
    name: "hocho",
    emoji: "🔪"
  },
  {
    name: "dagger",
    emoji: "🗡"
  },
  {
    name: "crossed_swords",
    emoji: "⚔"
  },
  {
    name: "shield",
    emoji: "🛡"
  },
  {
    name: "smoking",
    emoji: "🚬"
  },
  {
    name: "skull_and_crossbones",
    emoji: "☠"
  },
  {
    name: "coffin",
    emoji: "⚰"
  },
  {
    name: "funeral_urn",
    emoji: "⚱"
  },
  {
    name: "amphora",
    emoji: "🏺"
  },
  {
    name: "crystal_ball",
    emoji: "🔮"
  },
  {
    name: "prayer_beads",
    emoji: "📿"
  },
  {
    name: "barber",
    emoji: "💈"
  },
  {
    name: "alembic",
    emoji: "⚗"
  },
  {
    name: "telescope",
    emoji: "🔭"
  },
  {
    name: "microscope",
    emoji: "🔬"
  },
  {
    name: "hole",
    emoji: "🕳"
  },
  {
    name: "pill",
    emoji: "💊"
  },
  {
    name: "syringe",
    emoji: "💉"
  },
  {
    name: "thermometer",
    emoji: "🌡"
  },
  {
    name: "label",
    emoji: "🏷"
  },
  {
    name: "bookmark",
    emoji: "🔖"
  },
  {
    name: "toilet",
    emoji: "🚽"
  },
  {
    name: "shower",
    emoji: "🚿"
  },
  {
    name: "bathtub",
    emoji: "🛁"
  },
  {
    name: "key",
    emoji: "🔑"
  },
  {
    name: "old_key",
    emoji: "🗝"
  },
  {
    name: "couch_and_lamp",
    emoji: "🛋"
  },
  {
    name: "sleeping_bed",
    emoji: "🛌"
  },
  {
    name: "bed",
    emoji: "🛏"
  },
  {
    name: "door",
    emoji: "🚪"
  },
  {
    name: "bellhop_bell",
    emoji: "🛎"
  },
  {
    name: "framed_picture",
    emoji: "🖼"
  },
  {
    name: "world_map",
    emoji: "🗺"
  },
  {
    name: "parasol_on_ground",
    emoji: "⛱"
  },
  {
    name: "moyai",
    emoji: "🗿"
  },
  {
    name: "shopping",
    emoji: "🛍"
  },
  {
    name: "shopping_cart",
    emoji: "🛒"
  },
  {
    name: "balloon",
    emoji: "🎈"
  },
  {
    name: "flags",
    emoji: "🎏"
  },
  {
    name: "ribbon",
    emoji: "🎀"
  },
  {
    name: "gift",
    emoji: "🎁"
  },
  {
    name: "confetti_ball",
    emoji: "🎊"
  },
  {
    name: "tada",
    emoji: "🎉"
  },
  {
    name: "dolls",
    emoji: "🎎"
  },
  {
    name: "wind_chime",
    emoji: "🎐"
  },
  {
    name: "crossed_flags",
    emoji: "🎌"
  },
  {
    name: "izakaya_lantern",
    emoji: "🏮"
  },
  {
    name: "email",
    emoji: "✉"
  },
  {
    name: "envelope_with_arrow",
    emoji: "📩"
  },
  {
    name: "incoming_envelope",
    emoji: "📨"
  },
  {
    name: "e-mail",
    emoji: "📧"
  },
  {
    name: "love_letter",
    emoji: "💌"
  },
  {
    name: "postbox",
    emoji: "📮"
  },
  {
    name: "mailbox_closed",
    emoji: "📪"
  },
  {
    name: "mailbox",
    emoji: "📫"
  },
  {
    name: "mailbox_with_mail",
    emoji: "📬"
  },
  {
    name: "mailbox_with_no_mail",
    emoji: "📭"
  },
  {
    name: "package",
    emoji: "📦"
  },
  {
    name: "postal_horn",
    emoji: "📯"
  },
  {
    name: "inbox_tray",
    emoji: "📥"
  },
  {
    name: "outbox_tray",
    emoji: "📤"
  },
  {
    name: "scroll",
    emoji: "📜"
  },
  {
    name: "page_with_curl",
    emoji: "📃"
  },
  {
    name: "bookmark_tabs",
    emoji: "📑"
  },
  {
    name: "bar_chart",
    emoji: "📊"
  },
  {
    name: "chart_with_upwards_trend",
    emoji: "📈"
  },
  {
    name: "chart_with_downwards_trend",
    emoji: "📉"
  },
  {
    name: "page_facing_up",
    emoji: "📄"
  },
  {
    name: "date",
    emoji: "📅"
  },
  {
    name: "calendar",
    emoji: "📆"
  },
  {
    name: "spiral_calendar",
    emoji: "🗓"
  },
  {
    name: "card_index",
    emoji: "📇"
  },
  {
    name: "card_file_box",
    emoji: "🗃"
  },
  {
    name: "ballot_box",
    emoji: "🗳"
  },
  {
    name: "file_cabinet",
    emoji: "🗄"
  },
  {
    name: "clipboard",
    emoji: "📋"
  },
  {
    name: "spiral_notepad",
    emoji: "🗒"
  },
  {
    name: "file_folder",
    emoji: "📁"
  },
  {
    name: "open_file_folder",
    emoji: "📂"
  },
  {
    name: "card_index_dividers",
    emoji: "🗂"
  },
  {
    name: "newspaper_roll",
    emoji: "🗞"
  },
  {
    name: "newspaper",
    emoji: "📰"
  },
  {
    name: "notebook",
    emoji: "📓"
  },
  {
    name: "closed_book",
    emoji: "📕"
  },
  {
    name: "green_book",
    emoji: "📗"
  },
  {
    name: "blue_book",
    emoji: "📘"
  },
  {
    name: "orange_book",
    emoji: "📙"
  },
  {
    name: "notebook_with_decorative_cover",
    emoji: "📔"
  },
  {
    name: "ledger",
    emoji: "📒"
  },
  {
    name: "books",
    emoji: "📚"
  },
  {
    name: "open_book",
    emoji: "📖"
  },
  {
    name: "link",
    emoji: "🔗"
  },
  {
    name: "paperclip",
    emoji: "📎"
  },
  {
    name: "paperclips",
    emoji: "🖇"
  },
  {
    name: "scissors",
    emoji: "✂"
  },
  {
    name: "triangular_ruler",
    emoji: "📐"
  },
  {
    name: "straight_ruler",
    emoji: "📏"
  },
  {
    name: "pushpin",
    emoji: "📌"
  },
  {
    name: "round_pushpin",
    emoji: "📍"
  },
  {
    name: "triangular_flag_on_post",
    emoji: "🚩"
  },
  {
    name: "white_flag",
    emoji: "🏳"
  },
  {
    name: "black_flag",
    emoji: "🏴"
  },
  {
    name: "rainbow_flag",
    emoji: "🏳️‍🌈"
  },
  {
    name: "closed_lock_with_key",
    emoji: "🔐"
  },
  {
    name: "lock",
    emoji: "🔒"
  },
  {
    name: "unlock",
    emoji: "🔓"
  },
  {
    name: "lock_with_ink_pen",
    emoji: "🔏"
  },
  {
    name: "pen",
    emoji: "🖊"
  },
  {
    name: "fountain_pen",
    emoji: "🖋"
  },
  {
    name: "black_nib",
    emoji: "✒"
  },
  {
    name: "memo",
    emoji: "📝"
  },
  {
    name: "pencil2",
    emoji: "✏"
  },
  {
    name: "crayon",
    emoji: "🖍"
  },
  {
    name: "paintbrush",
    emoji: "🖌"
  },
  {
    name: "mag",
    emoji: "🔍"
  },
  {
    name: "mag_right",
    emoji: "🔎"
  },
  {
    name: "heart",
    emoji: "❤"
  },
  {
    name: "yellow_heart",
    emoji: "💛"
  },
  {
    name: "green_heart",
    emoji: "💚"
  },
  {
    name: "blue_heart",
    emoji: "💙"
  },
  {
    name: "purple_heart",
    emoji: "💜"
  },
  {
    name: "black_heart",
    emoji: "🖤"
  },
  {
    name: "broken_heart",
    emoji: "💔"
  },
  {
    name: "heavy_heart_exclamation",
    emoji: "❣"
  },
  {
    name: "two_hearts",
    emoji: "💕"
  },
  {
    name: "revolving_hearts",
    emoji: "💞"
  },
  {
    name: "heartbeat",
    emoji: "💓"
  },
  {
    name: "heartpulse",
    emoji: "💗"
  },
  {
    name: "sparkling_heart",
    emoji: "💖"
  },
  {
    name: "cupid",
    emoji: "💘"
  },
  {
    name: "gift_heart",
    emoji: "💝"
  },
  {
    name: "heart_decoration",
    emoji: "💟"
  },
  {
    name: "peace_symbol",
    emoji: "☮"
  },
  {
    name: "latin_cross",
    emoji: "✝"
  },
  {
    name: "star_and_crescent",
    emoji: "☪"
  },
  {
    name: "om",
    emoji: "🕉"
  },
  {
    name: "wheel_of_dharma",
    emoji: "☸"
  },
  {
    name: "star_of_david",
    emoji: "✡"
  },
  {
    name: "six_pointed_star",
    emoji: "🔯"
  },
  {
    name: "menorah",
    emoji: "🕎"
  },
  {
    name: "yin_yang",
    emoji: "☯"
  },
  {
    name: "orthodox_cross",
    emoji: "☦"
  },
  {
    name: "place_of_worship",
    emoji: "🛐"
  },
  {
    name: "ophiuchus",
    emoji: "⛎"
  },
  {
    name: "aries",
    emoji: "♈"
  },
  {
    name: "taurus",
    emoji: "♉"
  },
  {
    name: "gemini",
    emoji: "♊"
  },
  {
    name: "cancer",
    emoji: "♋"
  },
  {
    name: "leo",
    emoji: "♌"
  },
  {
    name: "virgo",
    emoji: "♍"
  },
  {
    name: "libra",
    emoji: "♎"
  },
  {
    name: "scorpius",
    emoji: "♏"
  },
  {
    name: "sagittarius",
    emoji: "♐"
  },
  {
    name: "capricorn",
    emoji: "♑"
  },
  {
    name: "aquarius",
    emoji: "♒"
  },
  {
    name: "pisces",
    emoji: "♓"
  },
  {
    name: "id",
    emoji: "🆔"
  },
  {
    name: "atom_symbol",
    emoji: "⚛"
  },
  {
    name: "u7a7a",
    emoji: "🈳"
  },
  {
    name: "u5272",
    emoji: "🈹"
  },
  {
    name: "radioactive",
    emoji: "☢"
  },
  {
    name: "biohazard",
    emoji: "☣"
  },
  {
    name: "mobile_phone_off",
    emoji: "📴"
  },
  {
    name: "vibration_mode",
    emoji: "📳"
  },
  {
    name: "u6709",
    emoji: "🈶"
  },
  {
    name: "u7121",
    emoji: "🈚"
  },
  {
    name: "u7533",
    emoji: "🈸"
  },
  {
    name: "u55b6",
    emoji: "🈺"
  },
  {
    name: "u6708",
    emoji: "🈷"
  },
  {
    name: "eight_pointed_black_star",
    emoji: "✴"
  },
  {
    name: "vs",
    emoji: "🆚"
  },
  {
    name: "accept",
    emoji: "🉑"
  },
  {
    name: "white_flower",
    emoji: "💮"
  },
  {
    name: "ideograph_advantage",
    emoji: "🉐"
  },
  {
    name: "secret",
    emoji: "㊙"
  },
  {
    name: "congratulations",
    emoji: "㊗"
  },
  {
    name: "u5408",
    emoji: "🈴"
  },
  {
    name: "u6e80",
    emoji: "🈵"
  },
  {
    name: "u7981",
    emoji: "🈲"
  },
  {
    name: "a",
    emoji: "🅰"
  },
  {
    name: "b",
    emoji: "🅱"
  },
  {
    name: "ab",
    emoji: "🆎"
  },
  {
    name: "cl",
    emoji: "🆑"
  },
  {
    name: "o2",
    emoji: "🅾"
  },
  {
    name: "sos",
    emoji: "🆘"
  },
  {
    name: "no_entry",
    emoji: "⛔"
  },
  {
    name: "name_badge",
    emoji: "📛"
  },
  {
    name: "no_entry_sign",
    emoji: "🚫"
  },
  {
    name: "x",
    emoji: "❌"
  },
  {
    name: "o",
    emoji: "⭕"
  },
  {
    name: "stop_sign",
    emoji: "🛑"
  },
  {
    name: "anger",
    emoji: "💢"
  },
  {
    name: "hotsprings",
    emoji: "♨"
  },
  {
    name: "no_pedestrians",
    emoji: "🚷"
  },
  {
    name: "do_not_litter",
    emoji: "🚯"
  },
  {
    name: "no_bicycles",
    emoji: "🚳"
  },
  {
    name: "non-potable_water",
    emoji: "🚱"
  },
  {
    name: "underage",
    emoji: "🔞"
  },
  {
    name: "no_mobile_phones",
    emoji: "📵"
  },
  {
    name: "exclamation",
    emoji: "❗"
  },
  {
    name: "grey_exclamation",
    emoji: "❕"
  },
  {
    name: "question",
    emoji: "❓"
  },
  {
    name: "grey_question",
    emoji: "❔"
  },
  {
    name: "bangbang",
    emoji: "‼"
  },
  {
    name: "interrobang",
    emoji: "⁉"
  },
  {
    name: "100",
    emoji: "💯"
  },
  {
    name: "low_brightness",
    emoji: "🔅"
  },
  {
    name: "high_brightness",
    emoji: "🔆"
  },
  {
    name: "trident",
    emoji: "🔱"
  },
  {
    name: "fleur_de_lis",
    emoji: "⚜"
  },
  {
    name: "part_alternation_mark",
    emoji: "〽"
  },
  {
    name: "warning",
    emoji: "⚠"
  },
  {
    name: "children_crossing",
    emoji: "🚸"
  },
  {
    name: "beginner",
    emoji: "🔰"
  },
  {
    name: "recycle",
    emoji: "♻"
  },
  {
    name: "u6307",
    emoji: "🈯"
  },
  {
    name: "chart",
    emoji: "💹"
  },
  {
    name: "sparkle",
    emoji: "❇"
  },
  {
    name: "eight_spoked_asterisk",
    emoji: "✳"
  },
  {
    name: "negative_squared_cross_mark",
    emoji: "❎"
  },
  {
    name: "white_check_mark",
    emoji: "✅"
  },
  {
    name: "diamond_shape_with_a_dot_inside",
    emoji: "💠"
  },
  {
    name: "cyclone",
    emoji: "🌀"
  },
  {
    name: "loop",
    emoji: "➿"
  },
  {
    name: "globe_with_meridians",
    emoji: "🌐"
  },
  {
    name: "m",
    emoji: "Ⓜ"
  },
  {
    name: "atm",
    emoji: "🏧"
  },
  {
    name: "sa",
    emoji: "🈂"
  },
  {
    name: "passport_control",
    emoji: "🛂"
  },
  {
    name: "customs",
    emoji: "🛃"
  },
  {
    name: "baggage_claim",
    emoji: "🛄"
  },
  {
    name: "left_luggage",
    emoji: "🛅"
  },
  {
    name: "wheelchair",
    emoji: "♿"
  },
  {
    name: "no_smoking",
    emoji: "🚭"
  },
  {
    name: "wc",
    emoji: "🚾"
  },
  {
    name: "parking",
    emoji: "🅿"
  },
  {
    name: "potable_water",
    emoji: "🚰"
  },
  {
    name: "mens",
    emoji: "🚹"
  },
  {
    name: "womens",
    emoji: "🚺"
  },
  {
    name: "baby_symbol",
    emoji: "🚼"
  },
  {
    name: "restroom",
    emoji: "🚻"
  },
  {
    name: "put_litter_in_its_place",
    emoji: "🚮"
  },
  {
    name: "cinema",
    emoji: "🎦"
  },
  {
    name: "signal_strength",
    emoji: "📶"
  },
  {
    name: "koko",
    emoji: "🈁"
  },
  {
    name: "ng",
    emoji: "🆖"
  },
  {
    name: "ok",
    emoji: "🆗"
  },
  {
    name: "up",
    emoji: "🆙"
  },
  {
    name: "cool",
    emoji: "🆒"
  },
  {
    name: "new",
    emoji: "🆕"
  },
  {
    name: "free",
    emoji: "🆓"
  },
  {
    name: "zero",
    emoji: "0️⃣"
  },
  {
    name: "one",
    emoji: "1️⃣"
  },
  {
    name: "two",
    emoji: "2️⃣"
  },
  {
    name: "three",
    emoji: "3️⃣"
  },
  {
    name: "four",
    emoji: "4️⃣"
  },
  {
    name: "five",
    emoji: "5️⃣"
  },
  {
    name: "six",
    emoji: "6️⃣"
  },
  {
    name: "seven",
    emoji: "7️⃣"
  },
  {
    name: "eight",
    emoji: "8️⃣"
  },
  {
    name: "nine",
    emoji: "9️⃣"
  },
  {
    name: "keycap_ten",
    emoji: "🔟"
  },
  {
    name: "asterisk",
    emoji: "*️⃣"
  },
  {
    name: "1234",
    emoji: "🔢"
  },
  {
    name: "arrow_forward",
    emoji: "▶"
  },
  {
    name: "pause_button",
    emoji: "⏸"
  },
  {
    name: "next_track_button",
    emoji: "⏭"
  },
  {
    name: "stop_button",
    emoji: "⏹"
  },
  {
    name: "record_button",
    emoji: "⏺"
  },
  {
    name: "play_or_pause_button",
    emoji: "⏯"
  },
  {
    name: "previous_track_button",
    emoji: "⏮"
  },
  {
    name: "fast_forward",
    emoji: "⏩"
  },
  {
    name: "rewind",
    emoji: "⏪"
  },
  {
    name: "twisted_rightwards_arrows",
    emoji: "🔀"
  },
  {
    name: "repeat",
    emoji: "🔁"
  },
  {
    name: "repeat_one",
    emoji: "🔂"
  },
  {
    name: "arrow_backward",
    emoji: "◀"
  },
  {
    name: "arrow_up_small",
    emoji: "🔼"
  },
  {
    name: "arrow_down_small",
    emoji: "🔽"
  },
  {
    name: "arrow_double_up",
    emoji: "⏫"
  },
  {
    name: "arrow_double_down",
    emoji: "⏬"
  },
  {
    name: "arrow_right",
    emoji: "➡"
  },
  {
    name: "arrow_left",
    emoji: "⬅"
  },
  {
    name: "arrow_up",
    emoji: "⬆"
  },
  {
    name: "arrow_down",
    emoji: "⬇"
  },
  {
    name: "arrow_upper_right",
    emoji: "↗"
  },
  {
    name: "arrow_lower_right",
    emoji: "↘"
  },
  {
    name: "arrow_lower_left",
    emoji: "↙"
  },
  {
    name: "arrow_upper_left",
    emoji: "↖"
  },
  {
    name: "arrow_up_down",
    emoji: "↕"
  },
  {
    name: "left_right_arrow",
    emoji: "↔"
  },
  {
    name: "arrows_counterclockwise",
    emoji: "🔄"
  },
  {
    name: "arrow_right_hook",
    emoji: "↪"
  },
  {
    name: "leftwards_arrow_with_hook",
    emoji: "↩"
  },
  {
    name: "arrow_heading_up",
    emoji: "⤴"
  },
  {
    name: "arrow_heading_down",
    emoji: "⤵"
  },
  {
    name: "hash",
    emoji: "#️⃣"
  },
  {
    name: "information_source",
    emoji: "ℹ"
  },
  {
    name: "abc",
    emoji: "🔤"
  },
  {
    name: "abcd",
    emoji: "🔡"
  },
  {
    name: "capital_abcd",
    emoji: "🔠"
  },
  {
    name: "symbols",
    emoji: "🔣"
  },
  {
    name: "musical_note",
    emoji: "🎵"
  },
  {
    name: "notes",
    emoji: "🎶"
  },
  {
    name: "wavy_dash",
    emoji: "〰"
  },
  {
    name: "curly_loop",
    emoji: "➰"
  },
  {
    name: "heavy_check_mark",
    emoji: "✔"
  },
  {
    name: "arrows_clockwise",
    emoji: "🔃"
  },
  {
    name: "heavy_plus_sign",
    emoji: "➕"
  },
  {
    name: "heavy_minus_sign",
    emoji: "➖"
  },
  {
    name: "heavy_division_sign",
    emoji: "➗"
  },
  {
    name: "heavy_multiplication_x",
    emoji: "✖"
  },
  {
    name: "heavy_dollar_sign",
    emoji: "💲"
  },
  {
    name: "currency_exchange",
    emoji: "💱"
  },
  {
    name: "copyright",
    emoji: "©"
  },
  {
    name: "registered",
    emoji: "®"
  },
  {
    name: "tm",
    emoji: "™"
  },
  {
    name: "end",
    emoji: "🔚"
  },
  {
    name: "back",
    emoji: "🔙"
  },
  {
    name: "on",
    emoji: "🔛"
  },
  {
    name: "top",
    emoji: "🔝"
  },
  {
    name: "soon",
    emoji: "🔜"
  },
  {
    name: "ballot_box_with_check",
    emoji: "☑"
  },
  {
    name: "radio_button",
    emoji: "🔘"
  },
  {
    name: "white_circle",
    emoji: "⚪"
  },
  {
    name: "black_circle",
    emoji: "⚫"
  },
  {
    name: "red_circle",
    emoji: "🔴"
  },
  {
    name: "large_blue_circle",
    emoji: "🔵"
  },
  {
    name: "small_orange_diamond",
    emoji: "🔸"
  },
  {
    name: "small_blue_diamond",
    emoji: "🔹"
  },
  {
    name: "large_orange_diamond",
    emoji: "🔶"
  },
  {
    name: "large_blue_diamond",
    emoji: "🔷"
  },
  {
    name: "small_red_triangle",
    emoji: "🔺"
  },
  {
    name: "black_small_square",
    emoji: "▪"
  },
  {
    name: "white_small_square",
    emoji: "▫"
  },
  {
    name: "black_large_square",
    emoji: "⬛"
  },
  {
    name: "white_large_square",
    emoji: "⬜"
  },
  {
    name: "small_red_triangle_down",
    emoji: "🔻"
  },
  {
    name: "black_medium_square",
    emoji: "◼"
  },
  {
    name: "white_medium_square",
    emoji: "◻"
  },
  {
    name: "black_medium_small_square",
    emoji: "◾"
  },
  {
    name: "white_medium_small_square",
    emoji: "◽"
  },
  {
    name: "black_square_button",
    emoji: "🔲"
  },
  {
    name: "white_square_button",
    emoji: "🔳"
  },
  {
    name: "speaker",
    emoji: "🔈"
  },
  {
    name: "sound",
    emoji: "🔉"
  },
  {
    name: "loud_sound",
    emoji: "🔊"
  },
  {
    name: "mute",
    emoji: "🔇"
  },
  {
    name: "mega",
    emoji: "📣"
  },
  {
    name: "loudspeaker",
    emoji: "📢"
  },
  {
    name: "bell",
    emoji: "🔔"
  },
  {
    name: "no_bell",
    emoji: "🔕"
  },
  {
    name: "black_joker",
    emoji: "🃏"
  },
  {
    name: "mahjong",
    emoji: "🀄"
  },
  {
    name: "spades",
    emoji: "♠"
  },
  {
    name: "clubs",
    emoji: "♣"
  },
  {
    name: "hearts",
    emoji: "♥"
  },
  {
    name: "diamonds",
    emoji: "♦"
  },
  {
    name: "flower_playing_cards",
    emoji: "🎴"
  },
  {
    name: "thought_balloon",
    emoji: "💭"
  },
  {
    name: "right_anger_bubble",
    emoji: "🗯"
  },
  {
    name: "speech_balloon",
    emoji: "💬"
  },
  {
    name: "left_speech_bubble",
    emoji: "🗨"
  },
  {
    name: "clock1",
    emoji: "🕐"
  },
  {
    name: "clock2",
    emoji: "🕑"
  },
  {
    name: "clock3",
    emoji: "🕒"
  },
  {
    name: "clock4",
    emoji: "🕓"
  },
  {
    name: "clock5",
    emoji: "🕔"
  },
  {
    name: "clock6",
    emoji: "🕕"
  },
  {
    name: "clock7",
    emoji: "🕖"
  },
  {
    name: "clock8",
    emoji: "🕗"
  },
  {
    name: "clock9",
    emoji: "🕘"
  },
  {
    name: "clock10",
    emoji: "🕙"
  },
  {
    name: "clock11",
    emoji: "🕚"
  },
  {
    name: "clock12",
    emoji: "🕛"
  },
  {
    name: "clock130",
    emoji: "🕜"
  },
  {
    name: "clock230",
    emoji: "🕝"
  },
  {
    name: "clock330",
    emoji: "🕞"
  },
  {
    name: "clock430",
    emoji: "🕟"
  },
  {
    name: "clock530",
    emoji: "🕠"
  },
  {
    name: "clock630",
    emoji: "🕡"
  },
  {
    name: "clock730",
    emoji: "🕢"
  },
  {
    name: "clock830",
    emoji: "🕣"
  },
  {
    name: "clock930",
    emoji: "🕤"
  },
  {
    name: "clock1030",
    emoji: "🕥"
  },
  {
    name: "clock1130",
    emoji: "🕦"
  },
  {
    name: "clock1230",
    emoji: "🕧"
  },
  {
    name: "afghanistan",
    emoji: "🇦🇫"
  },
  {
    name: "aland_islands",
    emoji: "🇦🇽"
  },
  {
    name: "albania",
    emoji: "🇦🇱"
  },
  {
    name: "algeria",
    emoji: "🇩🇿"
  },
  {
    name: "american_samoa",
    emoji: "🇦🇸"
  },
  {
    name: "andorra",
    emoji: "🇦🇩"
  },
  {
    name: "angola",
    emoji: "🇦🇴"
  },
  {
    name: "anguilla",
    emoji: "🇦🇮"
  },
  {
    name: "antarctica",
    emoji: "🇦🇶"
  },
  {
    name: "antigua_barbuda",
    emoji: "🇦🇬"
  },
  {
    name: "argentina",
    emoji: "🇦🇷"
  },
  {
    name: "armenia",
    emoji: "🇦🇲"
  },
  {
    name: "aruba",
    emoji: "🇦🇼"
  },
  {
    name: "australia",
    emoji: "🇦🇺"
  },
  {
    name: "austria",
    emoji: "🇦🇹"
  },
  {
    name: "azerbaijan",
    emoji: "🇦🇿"
  },
  {
    name: "bahamas",
    emoji: "🇧🇸"
  },
  {
    name: "bahrain",
    emoji: "🇧🇭"
  },
  {
    name: "bangladesh",
    emoji: "🇧🇩"
  },
  {
    name: "barbados",
    emoji: "🇧🇧"
  },
  {
    name: "belarus",
    emoji: "🇧🇾"
  },
  {
    name: "belgium",
    emoji: "🇧🇪"
  },
  {
    name: "belize",
    emoji: "🇧🇿"
  },
  {
    name: "benin",
    emoji: "🇧🇯"
  },
  {
    name: "bermuda",
    emoji: "🇧🇲"
  },
  {
    name: "bhutan",
    emoji: "🇧🇹"
  },
  {
    name: "bolivia",
    emoji: "🇧🇴"
  },
  {
    name: "caribbean_netherlands",
    emoji: "🇧🇶"
  },
  {
    name: "bosnia_herzegovina",
    emoji: "🇧🇦"
  },
  {
    name: "botswana",
    emoji: "🇧🇼"
  },
  {
    name: "brazil",
    emoji: "🇧🇷"
  },
  {
    name: "british_indian_ocean_territory",
    emoji: "🇮🇴"
  },
  {
    name: "british_virgin_islands",
    emoji: "🇻🇬"
  },
  {
    name: "brunei",
    emoji: "🇧🇳"
  },
  {
    name: "bulgaria",
    emoji: "🇧🇬"
  },
  {
    name: "burkina_faso",
    emoji: "🇧🇫"
  },
  {
    name: "burundi",
    emoji: "🇧🇮"
  },
  {
    name: "cape_verde",
    emoji: "🇨🇻"
  },
  {
    name: "cambodia",
    emoji: "🇰🇭"
  },
  {
    name: "cameroon",
    emoji: "🇨🇲"
  },
  {
    name: "canada",
    emoji: "🇨🇦"
  },
  {
    name: "canary_islands",
    emoji: "🇮🇨"
  },
  {
    name: "cayman_islands",
    emoji: "🇰🇾"
  },
  {
    name: "central_african_republic",
    emoji: "🇨🇫"
  },
  {
    name: "chad",
    emoji: "🇹🇩"
  },
  {
    name: "chile",
    emoji: "🇨🇱"
  },
  {
    name: "cn",
    emoji: "🇨🇳"
  },
  {
    name: "christmas_island",
    emoji: "🇨🇽"
  },
  {
    name: "cocos_islands",
    emoji: "🇨🇨"
  },
  {
    name: "colombia",
    emoji: "🇨🇴"
  },
  {
    name: "comoros",
    emoji: "🇰🇲"
  },
  {
    name: "congo_brazzaville",
    emoji: "🇨🇬"
  },
  {
    name: "congo_kinshasa",
    emoji: "🇨🇩"
  },
  {
    name: "cook_islands",
    emoji: "🇨🇰"
  },
  {
    name: "costa_rica",
    emoji: "🇨🇷"
  },
  {
    name: "croatia",
    emoji: "🇭🇷"
  },
  {
    name: "cuba",
    emoji: "🇨🇺"
  },
  {
    name: "curacao",
    emoji: "🇨🇼"
  },
  {
    name: "cyprus",
    emoji: "🇨🇾"
  },
  {
    name: "czech_republic",
    emoji: "🇨🇿"
  },
  {
    name: "denmark",
    emoji: "🇩🇰"
  },
  {
    name: "djibouti",
    emoji: "🇩🇯"
  },
  {
    name: "dominica",
    emoji: "🇩🇲"
  },
  {
    name: "dominican_republic",
    emoji: "🇩🇴"
  },
  {
    name: "ecuador",
    emoji: "🇪🇨"
  },
  {
    name: "egypt",
    emoji: "🇪🇬"
  },
  {
    name: "el_salvador",
    emoji: "🇸🇻"
  },
  {
    name: "equatorial_guinea",
    emoji: "🇬🇶"
  },
  {
    name: "eritrea",
    emoji: "🇪🇷"
  },
  {
    name: "estonia",
    emoji: "🇪🇪"
  },
  {
    name: "ethiopia",
    emoji: "🇪🇹"
  },
  {
    name: "eu",
    emoji: "🇪🇺"
  },
  {
    name: "falkland_islands",
    emoji: "🇫🇰"
  },
  {
    name: "faroe_islands",
    emoji: "🇫🇴"
  },
  {
    name: "fiji",
    emoji: "🇫🇯"
  },
  {
    name: "finland",
    emoji: "🇫🇮"
  },
  {
    name: "fr",
    emoji: "🇫🇷"
  },
  {
    name: "french_guiana",
    emoji: "🇬🇫"
  },
  {
    name: "french_polynesia",
    emoji: "🇵🇫"
  },
  {
    name: "french_southern_territories",
    emoji: "🇹🇫"
  },
  {
    name: "gabon",
    emoji: "🇬🇦"
  },
  {
    name: "gambia",
    emoji: "🇬🇲"
  },
  {
    name: "georgia",
    emoji: "🇬🇪"
  },
  {
    name: "de",
    emoji: "🇩🇪"
  },
  {
    name: "ghana",
    emoji: "🇬🇭"
  },
  {
    name: "gibraltar",
    emoji: "🇬🇮"
  },
  {
    name: "greece",
    emoji: "🇬🇷"
  },
  {
    name: "greenland",
    emoji: "🇬🇱"
  },
  {
    name: "grenada",
    emoji: "🇬🇩"
  },
  {
    name: "guadeloupe",
    emoji: "🇬🇵"
  },
  {
    name: "guam",
    emoji: "🇬🇺"
  },
  {
    name: "guatemala",
    emoji: "🇬🇹"
  },
  {
    name: "guernsey",
    emoji: "🇬🇬"
  },
  {
    name: "guinea",
    emoji: "🇬🇳"
  },
  {
    name: "guinea_bissau",
    emoji: "🇬🇼"
  },
  {
    name: "guyana",
    emoji: "🇬🇾"
  },
  {
    name: "haiti",
    emoji: "🇭🇹"
  },
  {
    name: "honduras",
    emoji: "🇭🇳"
  },
  {
    name: "hong_kong",
    emoji: "🇭🇰"
  },
  {
    name: "hungary",
    emoji: "🇭🇺"
  },
  {
    name: "iceland",
    emoji: "🇮🇸"
  },
  {
    name: "india",
    emoji: "🇮🇳"
  },
  {
    name: "indonesia",
    emoji: "🇮🇩"
  },
  {
    name: "iran",
    emoji: "🇮🇷"
  },
  {
    name: "iraq",
    emoji: "🇮🇶"
  },
  {
    name: "ireland",
    emoji: "🇮🇪"
  },
  {
    name: "isle_of_man",
    emoji: "🇮🇲"
  },
  {
    name: "israel",
    emoji: "🇮🇱"
  },
  {
    name: "it",
    emoji: "🇮🇹"
  },
  {
    name: "cote_divoire",
    emoji: "🇨🇮"
  },
  {
    name: "jamaica",
    emoji: "🇯🇲"
  },
  {
    name: "jp",
    emoji: "🇯🇵"
  },
  {
    name: "jersey",
    emoji: "🇯🇪"
  },
  {
    name: "jordan",
    emoji: "🇯🇴"
  },
  {
    name: "kazakhstan",
    emoji: "🇰🇿"
  },
  {
    name: "kenya",
    emoji: "🇰🇪"
  },
  {
    name: "kiribati",
    emoji: "🇰🇮"
  },
  {
    name: "kosovo",
    emoji: "🇽🇰"
  },
  {
    name: "kuwait",
    emoji: "🇰🇼"
  },
  {
    name: "kyrgyzstan",
    emoji: "🇰🇬"
  },
  {
    name: "laos",
    emoji: "🇱🇦"
  },
  {
    name: "latvia",
    emoji: "🇱🇻"
  },
  {
    name: "lebanon",
    emoji: "🇱🇧"
  },
  {
    name: "lesotho",
    emoji: "🇱🇸"
  },
  {
    name: "liberia",
    emoji: "🇱🇷"
  },
  {
    name: "libya",
    emoji: "🇱🇾"
  },
  {
    name: "liechtenstein",
    emoji: "🇱🇮"
  },
  {
    name: "lithuania",
    emoji: "🇱🇹"
  },
  {
    name: "luxembourg",
    emoji: "🇱🇺"
  },
  {
    name: "macau",
    emoji: "🇲🇴"
  },
  {
    name: "macedonia",
    emoji: "🇲🇰"
  },
  {
    name: "madagascar",
    emoji: "🇲🇬"
  },
  {
    name: "malawi",
    emoji: "🇲🇼"
  },
  {
    name: "malaysia",
    emoji: "🇲🇾"
  },
  {
    name: "maldives",
    emoji: "🇲🇻"
  },
  {
    name: "mali",
    emoji: "🇲🇱"
  },
  {
    name: "malta",
    emoji: "🇲🇹"
  },
  {
    name: "marshall_islands",
    emoji: "🇲🇭"
  },
  {
    name: "martinique",
    emoji: "🇲🇶"
  },
  {
    name: "mauritania",
    emoji: "🇲🇷"
  },
  {
    name: "mauritius",
    emoji: "🇲🇺"
  },
  {
    name: "mayotte",
    emoji: "🇾🇹"
  },
  {
    name: "mexico",
    emoji: "🇲🇽"
  },
  {
    name: "micronesia",
    emoji: "🇫🇲"
  },
  {
    name: "moldova",
    emoji: "🇲🇩"
  },
  {
    name: "monaco",
    emoji: "🇲🇨"
  },
  {
    name: "mongolia",
    emoji: "🇲🇳"
  },
  {
    name: "montenegro",
    emoji: "🇲🇪"
  },
  {
    name: "montserrat",
    emoji: "🇲🇸"
  },
  {
    name: "morocco",
    emoji: "🇲🇦"
  },
  {
    name: "mozambique",
    emoji: "🇲🇿"
  },
  {
    name: "myanmar",
    emoji: "🇲🇲"
  },
  {
    name: "namibia",
    emoji: "🇳🇦"
  },
  {
    name: "nauru",
    emoji: "🇳🇷"
  },
  {
    name: "nepal",
    emoji: "🇳🇵"
  },
  {
    name: "netherlands",
    emoji: "🇳🇱"
  },
  {
    name: "new_caledonia",
    emoji: "🇳🇨"
  },
  {
    name: "new_zealand",
    emoji: "🇳🇿"
  },
  {
    name: "nicaragua",
    emoji: "🇳🇮"
  },
  {
    name: "niger",
    emoji: "🇳🇪"
  },
  {
    name: "nigeria",
    emoji: "🇳🇬"
  },
  {
    name: "niue",
    emoji: "🇳🇺"
  },
  {
    name: "norfolk_island",
    emoji: "🇳🇫"
  },
  {
    name: "northern_mariana_islands",
    emoji: "🇲🇵"
  },
  {
    name: "north_korea",
    emoji: "🇰🇵"
  },
  {
    name: "norway",
    emoji: "🇳🇴"
  },
  {
    name: "oman",
    emoji: "🇴🇲"
  },
  {
    name: "pakistan",
    emoji: "🇵🇰"
  },
  {
    name: "palau",
    emoji: "🇵🇼"
  },
  {
    name: "palestinian_territories",
    emoji: "🇵🇸"
  },
  {
    name: "panama",
    emoji: "🇵🇦"
  },
  {
    name: "papua_new_guinea",
    emoji: "🇵🇬"
  },
  {
    name: "paraguay",
    emoji: "🇵🇾"
  },
  {
    name: "peru",
    emoji: "🇵🇪"
  },
  {
    name: "philippines",
    emoji: "🇵🇭"
  },
  {
    name: "pitcairn_islands",
    emoji: "🇵🇳"
  },
  {
    name: "poland",
    emoji: "🇵🇱"
  },
  {
    name: "portugal",
    emoji: "🇵🇹"
  },
  {
    name: "puerto_rico",
    emoji: "🇵🇷"
  },
  {
    name: "qatar",
    emoji: "🇶🇦"
  },
  {
    name: "reunion",
    emoji: "🇷🇪"
  },
  {
    name: "romania",
    emoji: "🇷🇴"
  },
  {
    name: "ru",
    emoji: "🇷🇺"
  },
  {
    name: "rwanda",
    emoji: "🇷🇼"
  },
  {
    name: "st_barthelemy",
    emoji: "🇧🇱"
  },
  {
    name: "st_helena",
    emoji: "🇸🇭"
  },
  {
    name: "st_kitts_nevis",
    emoji: "🇰🇳"
  },
  {
    name: "st_lucia",
    emoji: "🇱🇨"
  },
  {
    name: "st_pierre_miquelon",
    emoji: "🇵🇲"
  },
  {
    name: "st_vincent_grenadines",
    emoji: "🇻🇨"
  },
  {
    name: "samoa",
    emoji: "🇼🇸"
  },
  {
    name: "san_marino",
    emoji: "🇸🇲"
  },
  {
    name: "sao_tome_principe",
    emoji: "🇸🇹"
  },
  {
    name: "saudi_arabia",
    emoji: "🇸🇦"
  },
  {
    name: "senegal",
    emoji: "🇸🇳"
  },
  {
    name: "serbia",
    emoji: "🇷🇸"
  },
  {
    name: "seychelles",
    emoji: "🇸🇨"
  },
  {
    name: "sierra_leone",
    emoji: "🇸🇱"
  },
  {
    name: "singapore",
    emoji: "🇸🇬"
  },
  {
    name: "sint_maarten",
    emoji: "🇸🇽"
  },
  {
    name: "slovakia",
    emoji: "🇸🇰"
  },
  {
    name: "slovenia",
    emoji: "🇸🇮"
  },
  {
    name: "solomon_islands",
    emoji: "🇸🇧"
  },
  {
    name: "somalia",
    emoji: "🇸🇴"
  },
  {
    name: "south_africa",
    emoji: "🇿🇦"
  },
  {
    name: "south_georgia_south_sandwich_islands",
    emoji: "🇬🇸"
  },
  {
    name: "kr",
    emoji: "🇰🇷"
  },
  {
    name: "south_sudan",
    emoji: "🇸🇸"
  },
  {
    name: "es",
    emoji: "🇪🇸"
  },
  {
    name: "sri_lanka",
    emoji: "🇱🇰"
  },
  {
    name: "sudan",
    emoji: "🇸🇩"
  },
  {
    name: "suriname",
    emoji: "🇸🇷"
  },
  {
    name: "swaziland",
    emoji: "🇸🇿"
  },
  {
    name: "sweden",
    emoji: "🇸🇪"
  },
  {
    name: "switzerland",
    emoji: "🇨🇭"
  },
  {
    name: "syria",
    emoji: "🇸🇾"
  },
  {
    name: "taiwan",
    emoji: "🇹🇼"
  },
  {
    name: "tajikistan",
    emoji: "🇹🇯"
  },
  {
    name: "tanzania",
    emoji: "🇹🇿"
  },
  {
    name: "thailand",
    emoji: "🇹🇭"
  },
  {
    name: "timor_leste",
    emoji: "🇹🇱"
  },
  {
    name: "togo",
    emoji: "🇹🇬"
  },
  {
    name: "tokelau",
    emoji: "🇹🇰"
  },
  {
    name: "tonga",
    emoji: "🇹🇴"
  },
  {
    name: "trinidad_tobago",
    emoji: "🇹🇹"
  },
  {
    name: "tunisia",
    emoji: "🇹🇳"
  },
  {
    name: "tr",
    emoji: "🇹🇷"
  },
  {
    name: "turkmenistan",
    emoji: "🇹🇲"
  },
  {
    name: "turks_caicos_islands",
    emoji: "🇹🇨"
  },
  {
    name: "tuvalu",
    emoji: "🇹🇻"
  },
  {
    name: "uganda",
    emoji: "🇺🇬"
  },
  {
    name: "ukraine",
    emoji: "🇺🇦"
  },
  {
    name: "united_arab_emirates",
    emoji: "🇦🇪"
  },
  {
    name: "uk",
    emoji: "🇬🇧"
  },
  {
    name: "us",
    emoji: "🇺🇸"
  },
  {
    name: "us_virgin_islands",
    emoji: "🇻🇮"
  },
  {
    name: "uruguay",
    emoji: "🇺🇾"
  },
  {
    name: "uzbekistan",
    emoji: "🇺🇿"
  },
  {
    name: "vanuatu",
    emoji: "🇻🇺"
  },
  {
    name: "vatican_city",
    emoji: "🇻🇦"
  },
  {
    name: "venezuela",
    emoji: "🇻🇪"
  },
  {
    name: "vietnam",
    emoji: "🇻🇳"
  },
  {
    name: "wallis_futuna",
    emoji: "🇼🇫"
  },
  {
    name: "western_sahara",
    emoji: "🇪🇭"
  },
  {
    name: "yemen",
    emoji: "🇾🇪"
  },
  {
    name: "zambia",
    emoji: "🇿🇲"
  },
  {
    name: "zimbabwe",
    emoji: "🇿🇼"
  },
  {
    name: "star_struck",
    emoji: "🤩"
  },
  {
    name: "face_with_raised_eyebrow",
    emoji: "🤨"
  },
  {
    name: "exploding_head",
    emoji: "🤯"
  },
  {
    name: "crazy_face",
    emoji: "🤪"
  },
  {
    name: "face_with_symbols_over_mouth",
    emoji: "🤬"
  },
  {
    name: "face_vomiting",
    emoji: "🤮"
  },
  {
    name: "shushing_face",
    emoji: "🤫"
  },
  {
    name: "face_with_hand_over_mouth",
    emoji: "🤭"
  },
  {
    name: "face_with_monocle",
    emoji: "🧐"
  },
  {
    name: "child",
    emoji: "🧒"
  },
  {
    name: "adult",
    emoji: "🧑"
  },
  {
    name: "older_adult",
    emoji: "🧓"
  },
  {
    name: "woman_with_headscarf",
    emoji: "🧕"
  },
  {
    name: "bearded_person",
    emoji: "🧔"
  },
  {
    name: "breast_feeding",
    emoji: "🤱"
  },
  {
    name: "mage",
    emoji: "🧙"
  },
  {
    name: "woman_mage",
    emoji: "🧙‍♀️"
  },
  {
    name: "fairy",
    emoji: "🧚"
  },
  {
    name: "vampire",
    emoji: "🧛"
  },
  {
    name: "merperson",
    emoji: "🧜"
  },
  {
    name: "merman",
    emoji: "🧜‍♂️"
  },
  {
    name: "elf",
    emoji: "🧝"
  },
  {
    name: "genie",
    emoji: "🧞"
  },
  {
    name: "woman_genie",
    emoji: "🧞‍♀"
  },
  {
    name: "zombie",
    emoji: "🧟"
  },
  {
    name: "woman_zombie",
    emoji: "🧟‍♀"
  },
  {
    name: "person_in_steamy_room",
    emoji: "🧖"
  },
  {
    name: "woman_in_steamy_room",
    emoji: "🧖‍♀️"
  },
  {
    name: "person_climbing",
    emoji: "🧗"
  },
  {
    name: "woman_climbing",
    emoji: "🧗‍♀️"
  },
  {
    name: "person_in_lotus_position",
    emoji: "🧘"
  },
  {
    name: "woman_in_lotus_position",
    emoji: "🧘‍♀️"
  },
  {
    name: "love_you_gesture",
    emoji: "🤟"
  },
  {
    name: "palms_up_together",
    emoji: "🤲"
  },
  {
    name: "brain",
    emoji: "🧠"
  },
  {
    name: "orange_heart",
    emoji: "🧡"
  },
  {
    name: "scarf",
    emoji: "🧣"
  },
  {
    name: "gloves",
    emoji: "🧤"
  },
  {
    name: "coat",
    emoji: "🧥"
  },
  {
    name: "socks",
    emoji: "🧦"
  },
  {
    name: "billed_cap",
    emoji: "🧢"
  },
  {
    name: "zebra",
    emoji: "🦓"
  },
  {
    name: "giraffe",
    emoji: "🦒"
  },
  {
    name: "hedgehog",
    emoji: "🦔"
  },
  {
    name: "sauropod",
    emoji: "🦕"
  },
  {
    name: "t_rex",
    emoji: "🦖"
  },
  {
    name: "cricket",
    emoji: "🦗"
  },
  {
    name: "coconut",
    emoji: "🥥"
  },
  {
    name: "broccoli",
    emoji: "🥦"
  },
  {
    name: "pretzel",
    emoji: "🥨"
  },
  {
    name: "cut_of_meat",
    emoji: "🥩"
  },
  {
    name: "sandwich",
    emoji: "🥪"
  },
  {
    name: "bowl_with_spoon",
    emoji: "🥣"
  },
  {
    name: "canned_food",
    emoji: "🥫"
  },
  {
    name: "dumpling",
    emoji: "🥟"
  },
  {
    name: "fortune_cookie",
    emoji: "🥠"
  },
  {
    name: "takeout_box",
    emoji: "🥡"
  },
  {
    name: "pie",
    emoji: "🥧"
  },
  {
    name: "cup_with_straw",
    emoji: "🥤"
  },
  {
    name: "chopsticks",
    emoji: "🥢"
  },
  {
    name: "flying_saucer",
    emoji: "🛸"
  },
  {
    name: "sled",
    emoji: "🛷"
  },
  {
    name: "curling_stone",
    emoji: "🥌"
  },
  {
    name: "svalbard_and_jan_mayen",
    emoji: "🇸🇯"
  },
  {
    name: "st_martin",
    emoji: "🇲🇫"
  },
  {
    name: "us_outlying_islands",
    emoji: "🇺🇲"
  },
  {
    name: "tristan_da_cunha",
    emoji: "🇹🇦"
  },
  {
    name: "heard_and_mc_donald_islands",
    emoji: "🇭🇲"
  },
  {
    name: "ceuta_and_melilla",
    emoji: "🇪🇦"
  },
  {
    name: "diego_garcia",
    emoji: "🇩🇬"
  },
  {
    name: "ascension_island",
    emoji: "🇦🇨"
  },
  {
    name: "bouvet_island",
    emoji: "🇧🇻"
  },
  {
    name: "clipperton_island",
    emoji: "🇨🇵"
  },
  {
    name: "united_nations",
    emoji: "🇺🇳"
  },
  {
    name: "smiling_face_with_three_hearts",
    emoji: "🥰"
  },
  {
    name: "hot_face",
    emoji: "🥵"
  },
  {
    name: "cold_face",
    emoji: "🥶"
  },
  {
    name: "partying_face",
    emoji: "🥳"
  },
  {
    name: "woozy_face",
    emoji: "🥴"
  },
  {
    name: "pleading_face",
    emoji: "🥺"
  },
  {
    name: "man_red_haired",
    emoji: "👨‍🦰"
  },
  {
    name: "man_curly_haired",
    emoji: "👨‍🦱"
  },
  {
    name: "man_white_haired",
    emoji: "👨‍🦳"
  },
  {
    name: "man_bald",
    emoji: "👨‍🦲"
  },
  {
    name: "woman_red_haired",
    emoji: "👩‍🦰"
  },
  {
    name: "woman_curly_haired",
    emoji: "👩‍🦱"
  },
  {
    name: "woman_white_haired",
    emoji: "👩‍🦳"
  },
  {
    name: "woman_bald",
    emoji: "👩‍🦲"
  },
  {
    name: "superhero",
    emoji: "🦸"
  },
  {
    name: "man_superhero",
    emoji: "🦸‍♂️"
  },
  {
    name: "woman_superhero",
    emoji: "🦸‍♀️"
  },
  {
    name: "supervillain",
    emoji: "🦹"
  },
  {
    name: "woman_supervillain",
    emoji: "🦹‍♀️"
  },
  {
    name: "man_supervillain",
    emoji: "🦹‍♂️"
  },
  {
    name: "leg",
    emoji: "🦵"
  },
  {
    name: "foot",
    emoji: "🦶"
  },
  {
    name: "bone",
    emoji: "🦴"
  },
  {
    name: "tooth",
    emoji: "🦷"
  },
  {
    name: "goggles",
    emoji: "🥽"
  },
  {
    name: "lab_coat",
    emoji: "🥼"
  },
  {
    name: "hiking_boot",
    emoji: "🥾"
  },
  {
    name: "flat_shoe",
    emoji: "🥿"
  },
  {
    name: "raccoon",
    emoji: "🦝"
  },
  {
    name: "llama",
    emoji: "🦙"
  },
  {
    name: "hippopotamus",
    emoji: "🦛"
  },
  {
    name: "kangaroo",
    emoji: "🦘"
  },
  {
    name: "badger",
    emoji: "🦡"
  },
  {
    name: "swan",
    emoji: "🦢"
  },
  {
    name: "peacock",
    emoji: "🦚"
  },
  {
    name: "parrot",
    emoji: "🦜"
  },
  {
    name: "lobster",
    emoji: "🦞"
  },
  {
    name: "mosquito",
    emoji: "🦟"
  },
  {
    name: "microbe",
    emoji: "🦠"
  },
  {
    name: "mango",
    emoji: "🥭"
  },
  {
    name: "leafy_green",
    emoji: "🥬"
  },
  {
    name: "bagel",
    emoji: "🥯"
  },
  {
    name: "salt",
    emoji: "🧂"
  },
  {
    name: "moon_cake",
    emoji: "🥮"
  },
  {
    name: "cupcake",
    emoji: "🧁"
  },
  {
    name: "compass",
    emoji: "🧭"
  },
  {
    name: "brick",
    emoji: "🧱"
  },
  {
    name: "skateboard",
    emoji: "🛹"
  },
  {
    name: "luggage",
    emoji: "🧳"
  },
  {
    name: "firecracker",
    emoji: "🧨"
  },
  {
    name: "red_gift_envelope",
    emoji: "🧧"
  },
  {
    name: "softball",
    emoji: "🥎"
  },
  {
    name: "flying_disc",
    emoji: "🥏"
  },
  {
    name: "lacrosse",
    emoji: "🥍"
  },
  {
    name: "nazar_amulet",
    emoji: "🧿"
  },
  {
    name: "jigsaw",
    emoji: "🧩"
  },
  {
    name: "teddy_bear",
    emoji: "🧸"
  },
  {
    name: "chess_pawn",
    emoji: "♟"
  },
  {
    name: "thread",
    emoji: "🧵"
  },
  {
    name: "yarn",
    emoji: "🧶"
  },
  {
    name: "abacus",
    emoji: "🧮"
  },
  {
    name: "receipt",
    emoji: "🧾"
  },
  {
    name: "toolbox",
    emoji: "🧰"
  },
  {
    name: "magnet",
    emoji: "🧲"
  },
  {
    name: "test_tube",
    emoji: "🧪"
  },
  {
    name: "petri_dish",
    emoji: "🧫"
  },
  {
    name: "dna",
    emoji: "🧬"
  },
  {
    name: "lotion_bottle",
    emoji: "🧴"
  },
  {
    name: "safety_pin",
    emoji: "🧷"
  },
  {
    name: "broom",
    emoji: "🧹"
  },
  {
    name: "basket",
    emoji: "🧺"
  },
  {
    name: "roll_of_toilet_paper",
    emoji: "🧻"
  },
  {
    name: "soap",
    emoji: "🧼"
  },
  {
    name: "sponge",
    emoji: "🧽"
  },
  {
    name: "fire_extinguisher",
    emoji: "🧯"
  },
  {
    name: "infinity",
    emoji: "♾"
  },
  {
    name: "pirate_flag",
    emoji: "🏴‍☠"
  },
  {
    name: "waffle",
    emoji: "🧇"
  },
  {
    name: "otter",
    emoji: "🦦"
  },
  {
    name: "sloth",
    emoji: "🦥"
  },
  {
    name: "ice_cube",
    emoji: "🧊"
  },
  {
    name: "ringer_planet",
    emoji: "🪐"
  },
  {
    name: "flamingo",
    emoji: "🦩"
  },
  {
    name: "yawning_face",
    emoji: "🥱"
  },
  {
    name: "pinching_hand",
    emoji: "🤏"
  },
  {
    name: "service_dog",
    emoji: "🐕‍🦺"
  },
  {
    name: "orangutan",
    emoji: "🦧"
  },
  {
    name: "auto_rickshaw",
    emoji: "🛺"
  },
  {
    name: "parachute",
    emoji: "🪂"
  },
  {
    name: "yo-yo",
    emoji: "🪀"
  },
  {
    name: "kite",
    emoji: "🪁"
  },
  {
    name: "brown_square",
    emoji: "🟫"
  },
  {
    name: "purple_square",
    emoji: "🟪"
  },
  {
    name: "blue_square",
    emoji: "🟦"
  },
  {
    name: "green_square",
    emoji: "🟩"
  },
  {
    name: "yellow_square",
    emoji: "🟨"
  },
  {
    name: "orange_square",
    emoji: "🟧"
  },
  {
    name: "red_square",
    emoji: "🟥"
  },
  {
    name: "brown_circle",
    emoji: "🟤"
  },
  {
    name: "purple_circle",
    emoji: "🟣"
  },
  {
    name: "green_circle",
    emoji: "🟢"
  },
  {
    name: "yellow_circle",
    emoji: "🟡"
  },
  {
    name: "orange_circle",
    emoji: "🟠"
  },
  {
    name: "razor",
    emoji: "🪒"
  },
  {
    name: "chair",
    emoji: "🪑"
  },
  {
    name: "stethoscope",
    emoji: "🩺"
  },
  {
    name: "adhesive_bandage",
    emoji: "🩹"
  },
  {
    name: "drop_of_blood",
    emoji: "🩸"
  },
  {
    name: "probing_cane",
    emoji: "🦯"
  },
  {
    name: "axe",
    emoji: "🪓"
  },
  {
    name: "diya_lamp",
    emoji: "🪔"
  },
  {
    name: "banjo",
    emoji: "🪕"
  },
  {
    name: "ballet_shoes",
    emoji: "🩰"
  },
  {
    name: "shorts",
    emoji: "🩳"
  },
  {
    name: "briefs",
    emoji: "🩲"
  },
  {
    name: "one_piece_swimsuit",
    emoji: "🩱"
  },
  {
    name: "sari",
    emoji: "🥻"
  },
  {
    name: "safety_vest",
    emoji: "🦺"
  },
  {
    name: "diving_mask",
    emoji: "🤿"
  },
  {
    name: "motorized_wheelchair",
    emoji: "🦼"
  },
  {
    name: "manual_wheelchair",
    emoji: "🦽"
  },
  {
    name: "hindu_temple",
    emoji: "🛕"
  },
  {
    name: "maté",
    emoji: "🧉"
  },
  {
    name: "beverage_box",
    emoji: "🧃"
  },
  {
    name: "oyster",
    emoji: "🦪"
  },
  {
    name: "butter",
    emoji: "🧈"
  },
  {
    name: "falafel",
    emoji: "🧆"
  },
  {
    name: "onion",
    emoji: "🧅"
  },
  {
    name: "garlic",
    emoji: "🧄"
  },
  {
    name: "skunk",
    emoji: "🦨"
  },
  {
    name: "guide_dog",
    emoji: "🦮"
  },
  {
    name: "people_holding_hands",
    emoji: "🧑‍🤝‍🧑"
  },
  {
    name: "woman_in_manual_wheelchair",
    emoji: "👩‍🦽"
  },
  {
    name: "man_in_manual_wheelchair",
    emoji: "👨‍🦽"
  },
  {
    name: "woman_in_motorized_wheelchair",
    emoji: "👩‍🦼"
  },
  {
    name: "man_in_motorized_wheelchair",
    emoji: "👨‍🦼"
  },
  {
    name: "woman_with_probing_cane",
    emoji: "👩‍🦯"
  },
  {
    name: "man_with_probing_cane",
    emoji: "👨‍🦯"
  },
  {
    name: "woman_kneeling",
    emoji: "🧎‍♀️"
  },
  {
    name: "man_kneeling",
    emoji: "🧎‍♂️"
  },
  {
    name: "man_standing",
    emoji: "🧍‍♂️"
  },
  {
    name: "woman_standing",
    emoji: "🧍‍♀️"
  },
  {
    name: "deaf_woman",
    emoji: "🧏‍♀️"
  },
  {
    name: "deaf_man",
    emoji: "🧏‍♂️"
  },
  {
    name: "hear_with_hearing_aid",
    emoji: "🦻"
  },
  {
    name: "mechanical_leg",
    emoji: "🦿"
  },
  {
    name: "mechanical_arm",
    emoji: "🦾"
  },
  {
    name: "white_heart",
    emoji: "🤍"
  },
  {
    name: "brown_heart",
    emoji: "🤎"
  },
  {
    name: "transgender_flag",
    emoji: "🏳️‍⚧"
  },
  {
    name: "smiling_face_with_tear",
    emoji: "🥲"
  },
  {
    name: "disguised_face",
    emoji: "🥸"
  },
  {
    name: "pinched_fingers",
    emoji: "🤌"
  },
  {
    name: "anatomical_heart",
    emoji: "🫀"
  },
  {
    name: "lungs",
    emoji: "🫁"
  },
  {
    name: "ninja",
    emoji: "🥷"
  },
  {
    name: "mx_claus",
    emoji: "🧑‍🎄"
  },
  {
    name: "people_hugging",
    emoji: "🫂"
  },
  {
    name: "black_cat",
    emoji: "🐈‍⬛"
  },
  {
    name: "bison",
    emoji: "🦬"
  },
  {
    name: "mammoth",
    emoji: "🦣"
  },
  {
    name: "beaver",
    emoji: "🦫"
  },
  {
    name: "dodo",
    emoji: "🦤"
  },
  {
    name: "feather",
    emoji: "🪶"
  },
  {
    name: "seal",
    emoji: "🦭"
  },
  {
    name: "beetle",
    emoji: "🪲"
  },
  {
    name: "cockroach",
    emoji: "🪳"
  },
  {
    name: "fly",
    emoji: "🪰"
  },
  {
    name: "worm",
    emoji: "🪱"
  },
  {
    name: "potted_plant",
    emoji: "🪴"
  },
  {
    name: "blueberries",
    emoji: "🫐"
  },
  {
    name: "olive",
    emoji: "🫒"
  },
  {
    name: "bell_pepper",
    emoji: "🫑"
  },
  {
    name: "flatbread",
    emoji: "🫓"
  },
  {
    name: "tamale",
    emoji: "🫔"
  },
  {
    name: "fondue",
    emoji: "🫕"
  },
  {
    name: "teapot",
    emoji: "🫖"
  },
  {
    name: "bubble_tea",
    emoji: "🧋"
  },
  {
    name: "rock",
    emoji: "🪨"
  },
  {
    name: "wood",
    emoji: "🪵"
  },
  {
    name: "hut",
    emoji: "🛖"
  },
  {
    name: "pickup_truck",
    emoji: "🛻"
  },
  {
    name: "roller_skate",
    emoji: "🛼"
  },
  {
    name: "magic_wand",
    emoji: "🪄"
  },
  {
    name: "piñata",
    emoji: "🪅"
  },
  {
    name: "nesting_dolls",
    emoji: "🪆"
  },
  {
    name: "sewing_needle",
    emoji: "🪡"
  },
  {
    name: "knot",
    emoji: "🪢"
  },
  {
    name: "thong_sandal",
    emoji: "🩴"
  },
  {
    name: "military_helmet",
    emoji: "🪖"
  },
  {
    name: "accordion",
    emoji: "🪗"
  },
  {
    name: "long_drum",
    emoji: "🪘"
  },
  {
    name: "coin",
    emoji: "🪙"
  },
  {
    name: "boomerang",
    emoji: "🪃"
  },
  {
    name: "carpentry_saw",
    emoji: "🪚"
  },
  {
    name: "screwdriver",
    emoji: "🪛"
  },
  {
    name: "hook",
    emoji: "🪝"
  },
  {
    name: "ladder",
    emoji: "🪜"
  },
  {
    name: "mirror",
    emoji: "🪞"
  },
  {
    name: "window",
    emoji: "🪟"
  },
  {
    name: "plunger",
    emoji: "🪠"
  },
  {
    name: "mouse_trap",
    emoji: "🪤"
  },
  {
    name: "bucket",
    emoji: "🪣"
  },
  {
    name: "toothbrush",
    emoji: "🪥"
  },
  {
    name: "headstone",
    emoji: "🪦"
  },
  {
    name: "placard",
    emoji: "🪧"
  },
  {
    name: "transgender_symbol",
    emoji: "⚧"
  },
  {
    name: "man_feeding_baby",
    emoji: "👨‍🍼"
  },
  {
    name: "person_feeding_baby",
    emoji: "🧑‍🍼"
  },
  {
    name: "polar_bear",
    emoji: "🐻‍❄"
  },
  {
    name: "melting_face",
    emoji: "🫠"
  },
  {
    name: "smiling_face",
    emoji: "☺"
  },
  {
    name: "face_with_open_eyes_and_hand_over_mouth",
    emoji: "🫢"
  },
  {
    name: "face_with_peeking_eye",
    emoji: "🫣"
  },
  {
    name: "saluting_face",
    emoji: "🫡"
  },
  {
    name: "dotted_line_face",
    emoji: "🫥"
  },
  {
    name: "face_in_clouds",
    emoji: "😶‍🌫"
  },
  {
    name: "face_exhaling",
    emoji: "😮‍💨"
  },
  {
    name: "face_with_spiral_eyes",
    emoji: "😵‍💫"
  },
  {
    name: "face_with_diagonal_mouth",
    emoji: "🫤"
  },
  {
    name: "frowning_face",
    emoji: "☹"
  },
  {
    name: "face_holding_back_tears",
    emoji: "🥹"
  },
  {
    name: "heart_on_fire",
    emoji: "❤️‍🔥"
  },
  {
    name: "mending_heart",
    emoji: "❤️‍🩹"
  },
  {
    name: "eye_in_speech_bubble",
    emoji: "👁️‍🗨"
  },
  {
    name: "rightwards_hand",
    emoji: "🫱"
  },
  {
    name: "leftwards_hand",
    emoji: "🫲"
  },
  {
    name: "palm_down_hand",
    emoji: "🫳"
  },
  {
    name: "palm_up_hand",
    emoji: "🫴"
  },
  {
    name: "hand_with_index_finger_and_thumb_crossed",
    emoji: "🫰"
  },
  {
    name: "index_pointing_at_the_viewer",
    emoji: "🫵"
  },
  {
    name: "heart_hands",
    emoji: "🫶"
  },
  {
    name: "biting_lip",
    emoji: "🫦"
  },
  {
    name: "man_beard",
    emoji: "🧔‍♂"
  },
  {
    name: "woman_beard",
    emoji: "🧔‍♀"
  },
  {
    name: "person_red_hair",
    emoji: "🧑‍🦰"
  },
  {
    name: "person_curly_hair",
    emoji: "🧑‍🦱"
  },
  {
    name: "person_white_hair",
    emoji: "🧑‍🦳"
  },
  {
    name: "person_bald",
    emoji: "🧑‍🦲"
  },
  {
    name: "man_blond_hair",
    emoji: "👱‍♂️"
  },
  {
    name: "person_frowning",
    emoji: "🙍"
  },
  {
    name: "person_pouting",
    emoji: "🙎"
  },
  {
    name: "person_gesturing_no",
    emoji: "🙅"
  },
  {
    name: "person_gesturing_ok",
    emoji: "🙆"
  },
  {
    name: "person_tipping_hand",
    emoji: "💁"
  },
  {
    name: "person_raising_hand",
    emoji: "🙋"
  },
  {
    name: "deaf_person",
    emoji: "🧏"
  },
  {
    name: "man_bowing",
    emoji: "🙇‍♂️"
  },
  {
    name: "person_facepalming",
    emoji: "🤦"
  },
  {
    name: "person_shrugging",
    emoji: "🤷"
  },
  {
    name: "health_worker",
    emoji: "🧑‍⚕️"
  },
  {
    name: "student",
    emoji: "🧑‍🎓"
  },
  {
    name: "teacher",
    emoji: "🧑‍🏫"
  },
  {
    name: "judge",
    emoji: "🧑‍⚖️"
  },
  {
    name: "farmer",
    emoji: "🧑‍🌾"
  },
  {
    name: "cook",
    emoji: "🧑‍🍳"
  },
  {
    name: "mechanic",
    emoji: "🧑‍🔧"
  },
  {
    name: "factory_worker",
    emoji: "🧑‍🏭"
  },
  {
    name: "office_worker",
    emoji: "🧑‍💼"
  },
  {
    name: "scientist",
    emoji: "🧑‍🔬"
  },
  {
    name: "technologist",
    emoji: "🧑‍💻"
  },
  {
    name: "singer",
    emoji: "🧑‍🎤"
  },
  {
    name: "artist",
    emoji: "🧑‍🎨"
  },
  {
    name: "pilot",
    emoji: "🧑‍✈️"
  },
  {
    name: "astronaut",
    emoji: "🧑‍🚀"
  },
  {
    name: "firefighter",
    emoji: "🧑‍🚒"
  },
  {
    name: "man_police_officer",
    emoji: "👮‍♂️"
  },
  {
    name: "man_detective",
    emoji: "🕵️‍♂️"
  },
  {
    name: "man_guard",
    emoji: "💂‍♂️"
  },
  {
    name: "man_construction_worker",
    emoji: "👷‍♂️"
  },
  {
    name: "person_with_crown",
    emoji: "🫅"
  },
  {
    name: "man_wearing_turban",
    emoji: "👳‍♂️"
  },
  {
    name: "man_in_tuxedo",
    emoji: "🤵‍♂️"
  },
  {
    name: "woman_in_tuxedo",
    emoji: "🤵‍♀️"
  },
  {
    name: "man_with_veil",
    emoji: "👰‍♂️"
  },
  {
    name: "woman_with_veil",
    emoji: "👰‍♀️"
  },
  {
    name: "pregnant_man",
    emoji: "🫃"
  },
  {
    name: "pregnant_person",
    emoji: "🫄"
  },
  {
    name: "woman_feeding_baby",
    emoji: "👩‍🍼"
  },
  {
    name: "man_mage",
    emoji: "🧙‍♂️"
  },
  {
    name: "man_fairy",
    emoji: "🧚‍♂️"
  },
  {
    name: "woman_fairy",
    emoji: "🧚‍♀️"
  },
  {
    name: "man_vampire",
    emoji: "🧛‍♂️"
  },
  {
    name: "woman_vampire",
    emoji: "🧛‍♀️"
  },
  {
    name: "mermaid",
    emoji: "🧜‍♀️"
  },
  {
    name: "man_elf",
    emoji: "🧝‍♂️"
  },
  {
    name: "woman_elf",
    emoji: "🧝‍♀️"
  },
  {
    name: "man_genie",
    emoji: "🧞‍♂"
  },
  {
    name: "man_zombie",
    emoji: "🧟‍♂"
  },
  {
    name: "troll",
    emoji: "🧌"
  },
  {
    name: "person_getting_massage",
    emoji: "💆"
  },
  {
    name: "person_getting_haircut",
    emoji: "💇"
  },
  {
    name: "man_walking",
    emoji: "🚶‍♂️"
  },
  {
    name: "person_standing",
    emoji: "🧍"
  },
  {
    name: "person_kneeling",
    emoji: "🧎"
  },
  {
    name: "person_with_white_cane",
    emoji: "🧑‍🦯"
  },
  {
    name: "person_in_motorized_wheelchair",
    emoji: "🧑‍🦼"
  },
  {
    name: "person_in_manual_wheelchair",
    emoji: "🧑‍🦽"
  },
  {
    name: "man_running",
    emoji: "🏃‍♂️"
  },
  {
    name: "women_with_bunny_ears",
    emoji: "👯‍♀"
  },
  {
    name: "man_in_steamy_room",
    emoji: "🧖‍♂️"
  },
  {
    name: "man_climbing",
    emoji: "🧗‍♂️"
  },
  {
    name: "man_golfing",
    emoji: "🏌️‍♂️"
  },
  {
    name: "man_surfing",
    emoji: "🏄‍♂️"
  },
  {
    name: "man_rowing_boat",
    emoji: "🚣‍♂️"
  },
  {
    name: "man_swimming",
    emoji: "🏊‍♂️"
  },
  {
    name: "man_bouncing_ball",
    emoji: "⛹️‍♂️"
  },
  {
    name: "man_lifting_weights",
    emoji: "🏋️‍♂️"
  },
  {
    name: "man_biking",
    emoji: "🚴‍♂️"
  },
  {
    name: "man_mountain_biking",
    emoji: "🚵‍♂️"
  },
  {
    name: "person_cartwheeling",
    emoji: "🤸"
  },
  {
    name: "people_wrestling",
    emoji: "🤼"
  },
  {
    name: "person_playing_water_polo",
    emoji: "🤽"
  },
  {
    name: "person_playing_handball",
    emoji: "🤾"
  },
  {
    name: "person_juggling",
    emoji: "🤹"
  },
  {
    name: "man_in_lotus_position",
    emoji: "🧘‍♂️"
  },
  {
    name: "kiss_woman_man",
    emoji: "👩‍❤️‍💋‍👨"
  },
  {
    name: "couple_with_heart_woman_man",
    emoji: "👩‍❤️‍👨"
  },
  {
    name: "family_man_woman_boy",
    emoji: "👨‍👩‍👦"
  },
  {
    name: "red_hair",
    emoji: "🦰"
  },
  {
    name: "curly_hair",
    emoji: "🦱"
  },
  {
    name: "white_hair",
    emoji: "🦳"
  },
  {
    name: "bald",
    emoji: "🦲"
  },
  {
    name: "coral",
    emoji: "🪸"
  },
  {
    name: "lotus",
    emoji: "🪷"
  },
  {
    name: "empty_nest",
    emoji: "🪹"
  },
  {
    name: "nest_with_eggs",
    emoji: "🪺"
  },
  {
    name: "beans",
    emoji: "🫘"
  },
  {
    name: "pouring_liquid",
    emoji: "🫗"
  },
  {
    name: "jar",
    emoji: "🫙"
  },
  {
    name: "playground_slide",
    emoji: "🛝"
  },
  {
    name: "wheel",
    emoji: "🛞"
  },
  {
    name: "ring_buoy",
    emoji: "🛟"
  },
  {
    name: "hamsa",
    emoji: "🪬"
  },
  {
    name: "mirror_ball",
    emoji: "🪩"
  },
  {
    name: "low_battery",
    emoji: "🪫"
  },
  {
    name: "crutch",
    emoji: "🩼"
  },
  {
    name: "xray",
    emoji: "🩻"
  },
  {
    name: "elevator",
    emoji: "🛗"
  },
  {
    name: "bubbles",
    emoji: "🫧"
  },
  {
    name: "identification_card",
    emoji: "🪪"
  },
  {
    name: "eject_button",
    emoji: "⏏"
  },
  {
    name: "female_sign",
    emoji: "♀"
  },
  {
    name: "male_sign",
    emoji: "♂"
  },
  {
    name: "heavy_equals_sign",
    emoji: "🟰"
  },
  {
    name: "medical_symbol",
    emoji: "⚕"
  },
  {
    name: "england",
    emoji: "🏴󠁧󠁢󠁥󠁮󠁧󠁿"
  },
  {
    name: "scotland",
    emoji: "🏴󠁧󠁢󠁳󠁣󠁴󠁿"
  },
  {
    name: "wales",
    emoji: "🏴󠁧󠁢󠁷󠁬󠁳󠁿"
  }
];
const EMOJIS = _EMOJIS;
const EmojiExtension = createSuggestionExtension({
  name: "emoji",
  char: ":",
  pluginKey: new PluginKey("emojiSuggestion"),
  items: ({ query }) => {
    return EMOJIS.filter(
      (item) => item.name.toLowerCase().includes(query.toLowerCase())
    ).sort((a, b) => {
      const aName = a.name.toLowerCase();
      const bName = b.name.toLowerCase();
      const queryLower = query.toLowerCase();
      if (aName === queryLower && bName !== queryLower) return -1;
      if (bName === queryLower && aName !== queryLower) return 1;
      if (aName.startsWith(queryLower) && !bName.startsWith(queryLower))
        return -1;
      if (bName.startsWith(queryLower) && !aName.startsWith(queryLower))
        return 1;
      return aName.length - bName.length;
    }).slice(0, 5);
  },
  command: ({ editor, range, props: item }) => {
    if (item && item.emoji) {
      editor.chain().focus().deleteRange(range).insertContent(item.emoji).run();
    } else {
      console.error(
        "Emoji command execution error: emoji property not found on selected item or item is invalid.",
        item
      );
    }
  },
  component: EmojiList
});
const _sfc_main$p = /* @__PURE__ */ defineComponent({
  __name: "SlashCommandsList",
  props: {
    items: {
      type: Array,
      required: true
    },
    editor: {
      type: Object,
      required: true
    },
    range: {
      type: Object,
      required: true
    },
    command: {
      type: Function,
      required: true
    },
    query: String
  },
  setup(__props, { expose: __expose }) {
    const props = __props;
    const suggestionList = ref(null);
    const onItemSelect = (item) => {
      if (item) {
        props.command(item);
      }
    };
    const onKeyDown = ({ event }) => {
      var _a;
      return ((_a = suggestionList.value) == null ? void 0 : _a.onKeyDown({ event })) ?? false;
    };
    __expose({
      onKeyDown
    });
    const __returned__ = { props, suggestionList, onItemSelect, onKeyDown, SuggestionList };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$s = {
  key: 1,
  class: "mr-2 h-4 w-4"
};
function _sfc_render$j(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock($setup["SuggestionList"], {
    ref: "suggestionList",
    items: $setup.props.items,
    command: (item) => $setup.onItemSelect(item),
    "container-class": "min-w-48",
    "item-class": "h-7",
    "show-no-results": true
  }, {
    default: withCtx(({ item }) => [
      item.icon ? (openBlock(), createBlock(resolveDynamicComponent(item.icon), {
        key: 0,
        class: "mr-2 h-4 w-4"
      })) : (openBlock(), createElementBlock("div", _hoisted_1$s)),
      createBaseVNode(
        "span",
        null,
        toDisplayString(item.title),
        1
        /* TEXT */
      )
    ]),
    _: 1
    /* STABLE */
  }, 8, ["items", "command"]);
}
_sfc_main$p.__file = "src/components/TextEditor/extensions/slash-commands/SlashCommandsList.vue";
const SlashCommandsList = /* @__PURE__ */ _export_sfc(_sfc_main$p, [["render", _sfc_render$j], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/TextEditor/extensions/slash-commands/SlashCommandsList.vue"]]);
const _hoisted_1$r = {
  class: "lucide lucide-heading-2",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function render$d(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$r, _cache[0] || (_cache[0] = [
    createBaseVNode(
      "path",
      { d: "M4 12h8" },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      { d: "M4 18V6" },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      { d: "M12 18V6" },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      { d: "M21 18h-4c0-4 4-3 4-6 0-1.5-2-2.5-4-1" },
      null,
      -1
      /* HOISTED */
    )
  ]));
}
const Heading2 = markRaw({ name: "lucide-heading-2", render: render$d });
const _hoisted_1$q = {
  class: "lucide lucide-heading-3",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function render$c(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$q, _cache[0] || (_cache[0] = [
    createStaticVNode('<path d="M4 12h8"></path><path d="M4 18V6"></path><path d="M12 18V6"></path><path d="M17.5 10.5c1.7-1 3.5 0 3.5 1.5a2 2 0 0 1-2 2"></path><path d="M17 17.5c2 1.5 4 .3 4-1.5a2 2 0 0 0-2-2"></path>', 5)
  ]));
}
const Heading3 = markRaw({ name: "lucide-heading-3", render: render$c });
const _hoisted_1$p = {
  class: "lucide lucide-list",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function render$b(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$p, _cache[0] || (_cache[0] = [
    createStaticVNode('<path d="M3 12h.01"></path><path d="M3 18h.01"></path><path d="M3 6h.01"></path><path d="M8 12h13"></path><path d="M8 18h13"></path><path d="M8 6h13"></path>', 6)
  ]));
}
const List = markRaw({ name: "lucide-list", render: render$b });
const _hoisted_1$o = {
  class: "lucide lucide-list-ordered",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function render$a(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$o, _cache[0] || (_cache[0] = [
    createStaticVNode('<path d="M10 12h11"></path><path d="M10 18h11"></path><path d="M10 6h11"></path><path d="M4 10h2"></path><path d="M4 6h1v4"></path><path d="M6 18H4c0-1 2-2 2-3s-1-1.5-2-1"></path>', 6)
  ]));
}
const ListOrdered = markRaw({ name: "lucide-list-ordered", render: render$a });
const _hoisted_1$n = {
  class: "lucide lucide-list-checks",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function render$9(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$n, _cache[0] || (_cache[0] = [
    createStaticVNode('<path d="m3 17 2 2 4-4"></path><path d="m3 7 2 2 4-4"></path><path d="M13 6h8"></path><path d="M13 12h8"></path><path d="M13 18h8"></path>', 5)
  ]));
}
const ListTask = markRaw({ name: "lucide-list-checks", render: render$9 });
const _hoisted_1$m = {
  class: "lucide lucide-code",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function render$8(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$m, _cache[0] || (_cache[0] = [
    createBaseVNode(
      "path",
      { d: "m16 18 6-6-6-6" },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      { d: "m8 6-6 6 6 6" },
      null,
      -1
      /* HOISTED */
    )
  ]));
}
const Code = markRaw({ name: "lucide-code", render: render$8 });
const _hoisted_1$l = {
  class: "lucide lucide-quote",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function render$7(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$l, _cache[0] || (_cache[0] = [
    createBaseVNode(
      "path",
      { d: "M16 3a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2 1 1 0 0 1 1 1v1a2 2 0 0 1-2 2 1 1 0 0 0-1 1v2a1 1 0 0 0 1 1 6 6 0 0 0 6-6V5a2 2 0 0 0-2-2z" },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      { d: "M5 3a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2 1 1 0 0 1 1 1v1a2 2 0 0 1-2 2 1 1 0 0 0-1 1v2a1 1 0 0 0 1 1 6 6 0 0 0 6-6V5a2 2 0 0 0-2-2z" },
      null,
      -1
      /* HOISTED */
    )
  ]));
}
const Quote = markRaw({ name: "lucide-quote", render: render$7 });
const _hoisted_1$k = {
  class: "lucide lucide-image",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function render$6(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$k, _cache[0] || (_cache[0] = [
    createBaseVNode(
      "rect",
      {
        width: "18",
        height: "18",
        x: "3",
        y: "3",
        rx: "2",
        ry: "2"
      },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "circle",
      {
        cx: "9",
        cy: "9",
        r: "2"
      },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      { d: "m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21" },
      null,
      -1
      /* HOISTED */
    )
  ]));
}
const Image$1 = markRaw({ name: "lucide-image", render: render$6 });
const _hoisted_1$j = {
  class: "lucide lucide-video",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function render$5(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$j, _cache[0] || (_cache[0] = [
    createBaseVNode(
      "path",
      { d: "m16 13 5.223 3.482a.5.5 0 0 0 .777-.416V7.87a.5.5 0 0 0-.752-.432L16 10.5" },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "rect",
      {
        x: "2",
        y: "6",
        width: "14",
        height: "12",
        rx: "2"
      },
      null,
      -1
      /* HOISTED */
    )
  ]));
}
const Video = markRaw({ name: "lucide-video", render: render$5 });
const _hoisted_1$i = {
  class: "lucide lucide-table-2",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function render$4(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$i, _cache[0] || (_cache[0] = [
    createBaseVNode(
      "path",
      { d: "M9 3H5a2 2 0 0 0-2 2v4m6-6h10a2 2 0 0 1 2 2v4M9 3v18m0 0h10a2 2 0 0 0 2-2V9M9 21H5a2 2 0 0 1-2-2V9m0 0h18" },
      null,
      -1
      /* HOISTED */
    )
  ]));
}
const Table = markRaw({ name: "lucide-table-2", render: render$4 });
const SlashCommandSuggestionKey = new PluginKey(
  "slashCommandSuggestion"
);
const getCommands = () => [
  {
    title: "Heading 2",
    icon: Heading2,
    command: ({ editor, range }) => {
      editor.chain().focus().deleteRange(range).setNode("heading", { level: 2 }).run();
    }
  },
  {
    title: "Heading 3",
    icon: Heading3,
    command: ({ editor, range }) => {
      editor.chain().focus().deleteRange(range).setNode("heading", { level: 3 }).run();
    }
  },
  {
    title: "Bullet List",
    icon: List,
    command: ({ editor, range }) => {
      editor.chain().focus().deleteRange(range).toggleBulletList().run();
    }
  },
  {
    title: "Numbered List",
    icon: ListOrdered,
    command: ({ editor, range }) => {
      editor.chain().focus().deleteRange(range).toggleOrderedList().run();
    }
  },
  {
    title: "Task List",
    icon: ListTask,
    command: ({ editor, range }) => {
      editor.chain().focus().deleteRange(range).toggleTaskList().run();
    }
  },
  {
    title: "Code Block",
    icon: Code,
    command: ({ editor, range }) => {
      editor.chain().focus().deleteRange(range).toggleCodeBlock().run();
    }
  },
  {
    title: "Blockquote",
    icon: Quote,
    command: ({ editor, range }) => {
      editor.chain().focus().deleteRange(range).toggleBlockquote().run();
    }
  },
  {
    title: "Image",
    icon: Image$1,
    command: ({ editor, range }) => {
      editor.chain().focus().deleteRange(range).selectAndUploadImage().run();
    }
  },
  {
    title: "Video",
    icon: Video,
    command: ({ editor, range }) => {
      editor.chain().focus().deleteRange(range).selectAndUploadVideo().run();
    }
  },
  {
    title: "Embed",
    icon: GalleryVertical,
    command: ({ editor, range }) => {
      editor.chain().focus().deleteRange(range).openIframeDialog().run();
    }
  },
  {
    title: "Link",
    icon: Link$2,
    command: ({ editor, range }) => {
      editor.chain().focus().deleteRange(range).setLink({ href: "" }).run();
    }
  },
  {
    title: "Horizontal Rule",
    icon: Minus,
    command: ({ editor, range }) => {
      editor.chain().focus().deleteRange(range).setHorizontalRule().run();
    }
  },
  {
    title: "Table",
    icon: Table,
    command: ({ editor, range }) => {
      editor.chain().focus().deleteRange(range).insertTable({ rows: 3, cols: 3, withHeaderRow: true }).run();
    }
  }
];
const SlashCommands = createSuggestionExtension({
  name: "slashCommands",
  char: "/",
  pluginKey: SlashCommandSuggestionKey,
  items: ({ query }) => {
    const commands2 = getCommands();
    return commands2.filter(
      (item) => item.title.toLowerCase().startsWith(query.toLowerCase())
    );
  },
  command: ({ editor, range, props: item }) => {
    if (item && typeof item.command === "function") {
      item.command({ editor, range });
    } else {
      console.error(
        "Slash command execution error: command function not found on selected item or item is invalid.",
        item
      );
    }
  },
  component: SlashCommandsList
});
function markdownToHTML(text) {
  return marked.parse(text, {
    gfm: true,
    breaks: true,
    async: false
  });
}
function detectMarkdown(text) {
  const lines = text.split("\n");
  const markdown = lines.filter(
    (line) => (
      // check for inline markdown content like images, links, italic, bold, etc.
      /!\[.*\]\(.*\)/.test(line) || /\[.*\]\(.*\)/.test(line) || /(^|\s)\*.*\*(\s|$)/.test(line) || /(^|\s)_.*_(\s|$)/.test(line) || /(^|\s)\*\*.*\*\*(\s|$)/.test(line) || /(^|\s)__.*__(\s|$)/.test(line) || /(^|\s)~~.*~~(\s|$)/.test(line) || // check for block markdown content like headings, code blocks, lists, etc.
      line.startsWith("![") || line.startsWith("#") || line.startsWith("> ") || line.startsWith("*") || line.startsWith("- ") || line.startsWith("1. ") || line.startsWith("```") || line.startsWith("`") || line.startsWith("[") || line.startsWith("---")
    )
  );
  return markdown.length > 0;
}
const ContentPasteExtension = Extension.create({
  name: "contentPaste",
  addOptions() {
    return {
      enabled: true,
      showConfirmation: true,
      uploadFunction: null
    };
  },
  addProseMirrorPlugins() {
    const extensionThis = this;
    return [
      new Plugin({
        key: new PluginKey("contentPaste"),
        props: {
          handlePaste: (view, event, slice) => {
            var _a, _b;
            if (!this.options.enabled) return false;
            const files = Array.from(
              ((_a = event.clipboardData) == null ? void 0 : _a.files) || []
            );
            const images = Array.from(files).filter(
              (file) => file.type.startsWith("image/")
            );
            if (images.length > 0) {
              processMultipleImages(images, view, null, extensionThis.options);
              return true;
            }
            const text = (_b = event.clipboardData) == null ? void 0 : _b.getData("text/plain");
            if (!text) return false;
            if (!detectMarkdown(text)) return false;
            if (this.options.showConfirmation) {
              const shouldConvert = confirm(
                "Do you want to convert markdown content to HTML before pasting?"
              );
              if (!shouldConvert) return false;
            }
            const htmlContent = markdownToHTML(text);
            const tempDiv = document.createElement("div");
            tempDiv.innerHTML = htmlContent;
            const parser = DOMParser$1.fromSchema(view.state.schema);
            const parsedSlice = parser.parseSlice(tempDiv, {
              preserveWhitespace: true
            });
            const tr = view.state.tr.replaceSelection(parsedSlice);
            view.dispatch(tr);
            return true;
          }
        }
      })
    ];
  }
});
const TagNode = Node.create({
  name: "tagItem",
  group: "inline",
  inline: true,
  selectable: true,
  atom: true,
  addAttributes() {
    return {
      tagId: {
        default: null,
        parseHTML: (element) => element.getAttribute("data-tag-id"),
        renderHTML: (attributes) => {
          if (!attributes.tagId) {
            return {};
          }
          return { "data-tag-id": attributes.tagId };
        }
      },
      tagLabel: {
        default: "tag",
        parseHTML: (element) => element.getAttribute("data-tag-label"),
        renderHTML: (attributes) => ({ "data-tag-label": attributes.tagLabel })
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "span.tag-item",
        getAttrs: (dom) => {
          const element = dom;
          return {
            tagId: element.getAttribute("data-tag-id"),
            tagLabel: element.getAttribute("data-tag-label") || element.innerText.replace(/^#/, "")
          };
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return [
      "span",
      mergeAttributes(HTMLAttributes, { class: "tag-item" }),
      `#${HTMLAttributes["data-tag-label"]}`
    ];
  },
  addCommands() {
    return {
      setTag: (attributes) => ({ commands: commands2 }) => {
        return commands2.insertContent({
          type: this.name,
          attrs: attributes
        });
      }
    };
  }
});
const TagExtension = createSuggestionExtension({
  name: "tagSuggestion",
  char: "#",
  pluginKey: new PluginKey("tagSuggestion"),
  component: SuggestionList,
  addOptions() {
    return {
      tags: []
    };
  },
  items: ({ query, editor }) => {
    const { tags: _tags } = editor.extensionManager.extensions.find(
      (ext) => ext.name === "tagSuggestion"
    ).options;
    let tags = toValue(_tags);
    let filteredTags = tags.filter(
      (tag) => tag.label.toLowerCase().startsWith(query.toLowerCase())
    ).map((tag) => ({ ...tag, display: tag.label }));
    if (query.length > 0 && !tags.some(
      (tag) => tag.label.toLowerCase() === query.toLowerCase()
    )) {
      filteredTags.push({
        display: `New tag: "${query}"`,
        label: query,
        isNew: true
      });
    }
    return filteredTags;
  },
  command: ({ editor, range, props }) => {
    const attributes = {
      tagLabel: props.label,
      ...props.id && !props.isNew && { tagId: props.id }
    };
    editor.chain().focus().insertContentAt(range, [
      {
        type: TagNode.name,
        attrs: attributes
      },
      {
        type: "text",
        text: " "
      }
    ]).run();
  },
  tippyOptions: {
    placement: "bottom-start",
    offset: [0, 8]
  },
  allowSpaces: false,
  decorationTag: "span",
  decorationClass: "tag-suggestion-active"
});
const Heading = Heading$1.extend({
  addInputRules() {
    return this.options.levels.map((level) => {
      let regexp = new RegExp(`^(#{${level}}) $`);
      return textblockTypeInputRule({
        find: regexp,
        type: this.type,
        getAttributes: { level }
      });
    });
  }
});
const _hoisted_1$h = {
  class: "lucide lucide-square-pen",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function render$3(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$h, _cache[0] || (_cache[0] = [
    createBaseVNode(
      "path",
      { d: "M12 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7" },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      { d: "M18.375 2.625a1 1 0 0 1 3 3l-9.013 9.014a2 2 0 0 1-.853.505l-2.873.84a.5.5 0 0 1-.62-.62l.84-2.873a2 2 0 0 1 .506-.852z" },
      null,
      -1
      /* HOISTED */
    )
  ]));
}
const LucideEdit = markRaw({ name: "lucide-edit", render: render$3 });
const _hoisted_1$g = {
  class: "lucide lucide-image-plus",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function render$2(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$g, _cache[0] || (_cache[0] = [
    createStaticVNode('<path d="M16 5h6"></path><path d="M19 2v6"></path><path d="M21 11.5V19a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h7.5"></path><path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21"></path><circle cx="9" cy="9" r="2"></circle>', 5)
  ]));
}
const LucideImagePlus = markRaw({ name: "lucide-image-plus", render: render$2 });
const _sfc_main$o = /* @__PURE__ */ defineComponent({
  __name: "ImageGroupUploadDialog",
  props: {
    modelValue: { type: Boolean, required: true },
    files: { type: Array, required: true },
    editor: { type: Object, required: true },
    mode: { type: String, required: true, default: "new" },
    existingImages: { type: Array, required: false },
    initialColumns: { type: Number, required: false }
  },
  emits: ["update:modelValue", "close", "update:files", "save"],
  setup(__props, { expose: __expose, emit: __emit }) {
    __expose();
    const props = __props;
    const emit = __emit;
    const modelValue = computed({
      get: () => props.modelValue,
      set: (val) => emit("update:modelValue", val)
    });
    const isFileDragging = ref(false);
    const draggedIndex = ref(null);
    const overIndex = ref(null);
    const columnsInitialized = ref(false);
    const editingCaption = ref(null);
    const captionEditValue = ref("");
    const captionInputRef = ref(null);
    const uploading = ref(false);
    const columns = ref(4);
    const uploadProgress = ref(0);
    const uploadedCount = ref(0);
    const totalCount = ref(0);
    const uploadErrors = ref([]);
    const uploadResults = ref([]);
    const images = ref([]);
    watch(
      () => props.modelValue,
      (isOpen) => {
        if (isOpen && props.mode === "edit") {
          const existingItems = (props.existingImages || []).map(
            createExistingImageItem
          );
          const fileItems = (props.files || []).map(createImageItem);
          images.value = [...existingItems, ...fileItems];
          if (props.initialColumns) {
            columns.value = props.initialColumns;
            columnsInitialized.value = true;
          }
        } else if (isOpen && props.mode === "new") {
          images.value = (props.files || []).map(createImageItem);
          columns.value = getDefaultColumns(images.value.length);
          columnsInitialized.value = true;
        }
      },
      { immediate: true }
    );
    watch(
      () => props.existingImages,
      (newExistingImages) => {
        if (props.modelValue && props.mode === "edit") {
          const existingItems = (newExistingImages || []).map(
            createExistingImageItem
          );
          const fileItems = (props.files || []).map(createImageItem);
          images.value = [...existingItems, ...fileItems];
        }
      },
      { deep: true }
    );
    watch(
      () => props.files,
      (newFiles) => {
        if (props.mode === "new") {
          images.value = (newFiles || []).map(createImageItem);
        }
      },
      { deep: true }
    );
    onMounted(() => {
      window.addEventListener("dragover", onDragOverWindow);
      window.addEventListener("drop", onDrop);
      window.addEventListener("dragleave", onDragLeaveWindow);
    });
    onUnmounted(() => {
      window.removeEventListener("dragover", onDragOverWindow);
      window.removeEventListener("drop", onDrop);
      window.removeEventListener("dragleave", onDragLeaveWindow);
    });
    async function handleSave() {
      const newFiles = images.value.filter((item) => item.type === "file" && item.file).map((item) => item.file);
      images.value.filter((item) => item.type === "existing" && item.existing).map((item) => item.existing);
      let uploadResults2 = [];
      if (newFiles.length > 0) {
        uploadResults2 = await uploadFiles(newFiles);
      }
      const fileToUploadMap = /* @__PURE__ */ new Map();
      newFiles.forEach((file, index) => {
        const result = uploadResults2[index];
        if ((result == null ? void 0 : result.success) && result.file) {
          fileToUploadMap.set(file, {
            src: result.file.file_url || "",
            alt: result.file.file_name || ""
          });
        }
      });
      const finalImages = [];
      for (const item of images.value) {
        if (item.type === "existing" && item.existing) {
          finalImages.push(item.existing);
        } else if (item.type === "file" && item.file) {
          const uploadedImage = fileToUploadMap.get(item.file);
          if (uploadedImage) {
            finalImages.push(uploadedImage);
          }
        }
      }
      emit("save", {
        images: finalImages,
        columns: columns.value
      });
      uploading.value = false;
      modelValue.value = false;
    }
    async function handleUpload() {
      if (!props.files || props.files.length === 0) return;
      const results = await uploadFiles(props.files);
      const uploadedImages = results.filter((result) => result.success && result.file).map((result) => {
        var _a, _b;
        return {
          src: ((_a = result.file) == null ? void 0 : _a.file_url) || "",
          alt: ((_b = result.file) == null ? void 0 : _b.file_name) || ""
        };
      });
      if (uploadedImages.length > 1) {
        props.editor.chain().focus().setImageGroup({ images: uploadedImages, columns: columns.value }).run();
      }
      uploading.value = false;
      modelValue.value = false;
      emit("close");
    }
    function handleCancel() {
      modelValue.value = false;
      emit("close");
    }
    function removeImage(idx) {
      images.value.splice(idx, 1);
      if (props.mode === "new") {
        const newFiles = images.value.filter((item) => item.type === "file" && item.file).map((item) => item.file);
        emit("update:files", newFiles);
      }
    }
    function triggerFileInput() {
      const fileInput = document.createElement("input");
      fileInput.type = "file";
      fileInput.accept = "image/*";
      fileInput.multiple = true;
      fileInput.onchange = (e) => {
        const files = e.target.files;
        if (files) {
          addFiles(Array.from(files));
        }
      };
      fileInput.click();
    }
    function addFiles(files) {
      const imageFiles = files.filter((file) => file.type.startsWith("image/"));
      const newImageItems = imageFiles.map(createImageItem);
      const existingFileSignatures = images.value.filter((item) => item.type === "file" && item.file).map((item) => `${item.file.name}-${item.file.size}`);
      const uniqueNewItems = newImageItems.filter(
        (item) => !existingFileSignatures.includes(`${item.file.name}-${item.file.size}`)
      );
      images.value.push(...uniqueNewItems);
      if (props.mode === "new") {
        const newFiles = images.value.filter((item) => item.type === "file" && item.file).map((item) => item.file);
        emit("update:files", newFiles);
      }
    }
    function onDrop(e) {
      var _a;
      e.preventDefault();
      e.stopPropagation();
      const droppedFiles = Array.from(((_a = e.dataTransfer) == null ? void 0 : _a.files) || []);
      if (droppedFiles.length) {
        addFiles(droppedFiles);
      } else if (draggedIndex.value !== null && overIndex.value !== null && draggedIndex.value !== overIndex.value) {
        const [moved] = images.value.splice(draggedIndex.value, 1);
        images.value.splice(overIndex.value, 0, moved);
        if (props.mode === "new") {
          const newFiles = images.value.filter((item) => item.type === "file" && item.file).map((item) => item.file);
          emit("update:files", newFiles);
        }
      }
      isFileDragging.value = false;
      draggedIndex.value = null;
      overIndex.value = null;
    }
    function createImageItem(file) {
      return {
        type: "file",
        file,
        id: `file-${file.name}-${file.size}-${Date.now()}`
      };
    }
    function createExistingImageItem(existing) {
      return {
        type: "existing",
        existing,
        id: `existing-${existing.src}-${Date.now()}`
      };
    }
    function getDefaultColumns(count) {
      if (count <= 4) return count;
      if (count % 4 === 0) return 4;
      if (count % 3 === 0) return 3;
      if (count > 10) return 4;
      return 3;
    }
    function getUploadFunction() {
      var _a;
      const imageGroupExtension = props.editor.extensionManager.extensions.find(
        (ext) => ext.name === "imageGroup"
      );
      return (_a = imageGroupExtension == null ? void 0 : imageGroupExtension.options) == null ? void 0 : _a.uploadFunction;
    }
    function filePreview(file) {
      const url = URL.createObjectURL(file);
      onUnmounted(() => {
        URL.revokeObjectURL(url);
      });
      return url;
    }
    function isImageSupported(file) {
      const unsupportedTypes = ["image/heic", "image/heif"];
      const unsupportedExtensions = [".heic", ".heif"];
      const hasUnsupportedType = unsupportedTypes.includes(file.type);
      const hasUnsupportedExtension = unsupportedExtensions.some(
        (ext) => {
          var _a;
          return (_a = file.name) == null ? void 0 : _a.toLowerCase().endsWith(ext);
        }
      );
      return !hasUnsupportedType && !hasUnsupportedExtension;
    }
    function onDragOver(e, idx) {
      e.preventDefault();
      overIndex.value = idx;
    }
    function onDragStart(idx) {
      draggedIndex.value = idx;
    }
    function onDragEnd() {
      draggedIndex.value = null;
      overIndex.value = null;
    }
    function onDragLeave(e, idx) {
      if (overIndex.value === idx) {
        overIndex.value = null;
      }
    }
    function isDropTarget(idx) {
      return overIndex.value === idx && draggedIndex.value !== null && draggedIndex.value !== idx;
    }
    function onDragOverWindow(e) {
      e.preventDefault();
      if (e.dataTransfer && Array.from(e.dataTransfer.types).includes("Files")) {
        isFileDragging.value = true;
      }
    }
    function onDragLeaveWindow(e) {
      if (e.target === window || e.relatedTarget === null) {
        isFileDragging.value = false;
      }
    }
    const gridStyle = computed(() => ({
      gridTemplateColumns: `repeat(${columns.value || 4}, minmax(0, 1fr))`
    }));
    const internalColumns = computed({
      get: () => String(columns.value ?? 4),
      set: (val) => {
        columns.value = +val;
      }
    });
    const selectOptions = [
      { label: "2 columns", value: "2" },
      { label: "3 columns", value: "3" },
      { label: "4 columns", value: "4" }
    ];
    function startEditingCaption(itemId, currentAlt) {
      editingCaption.value = itemId;
      captionEditValue.value = currentAlt;
      nextTick(() => {
        if (captionInputRef.value) {
          captionInputRef.value.focus();
          captionInputRef.value.select();
        }
      });
    }
    function saveCaption(itemId, itemIndex) {
      var _a;
      const [type, indexStr] = itemId.split("-");
      const newCaption = captionEditValue.value.trim();
      if (type === "existing") {
        if ((_a = images.value[itemIndex]) == null ? void 0 : _a.existing) {
          images.value[itemIndex].existing.alt = newCaption;
        }
      } else if (type === "file") {
        if (images.value[itemIndex]) {
          images.value[itemIndex].alt = newCaption;
        }
      }
      editingCaption.value = null;
      captionEditValue.value = "";
    }
    function cancelEditingCaption() {
      editingCaption.value = null;
      captionEditValue.value = "";
    }
    function handleCaptionBlur(itemId, itemIndex) {
      if (editingCaption.value === itemId) {
        saveCaption(itemId, itemIndex);
      }
    }
    async function uploadFiles(files) {
      const uploadFunction = getUploadFunction();
      if (!uploadFunction) {
        console.error("uploadFunction not found");
        throw new Error("Upload function not found");
      }
      uploading.value = true;
      totalCount.value = files.length;
      uploadedCount.value = 0;
      uploadProgress.value = 0;
      uploadErrors.value = Array(files.length).fill(null);
      uploadResults.value = Array(files.length).fill(null);
      const uploadPromises = files.map(async (file, index) => {
        try {
          const result = await uploadFunction(file);
          uploadResults.value[index] = { success: true, file: result };
          return { success: true, file: result };
        } catch (error) {
          const err = error;
          uploadErrors.value[index] = err;
          uploadResults.value[index] = { success: false, error: err };
          return { success: false, error: err };
        } finally {
          uploadedCount.value++;
          uploadProgress.value = Math.round(
            uploadedCount.value / totalCount.value * 100
          );
        }
      });
      const results = await Promise.all(uploadPromises);
      return results;
    }
    const __returned__ = { props, emit, modelValue, isFileDragging, draggedIndex, overIndex, columnsInitialized, editingCaption, captionEditValue, captionInputRef, uploading, columns, uploadProgress, uploadedCount, totalCount, uploadErrors, uploadResults, images, handleSave, handleUpload, handleCancel, removeImage, triggerFileInput, addFiles, onDrop, createImageItem, createExistingImageItem, getDefaultColumns, getUploadFunction, filePreview, isImageSupported, onDragOver, onDragStart, onDragEnd, onDragLeave, isDropTarget, onDragOverWindow, onDragLeaveWindow, gridStyle, internalColumns, selectOptions, startEditingCaption, saveCaption, cancelEditingCaption, handleCaptionBlur, uploadFiles, Dialog: __unplugin_components_1$1, Button, Select, get LucideX() {
      return LucideX;
    }, get LucideImagePlus() {
      return LucideImagePlus;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$f = { class: "space-y-2" };
const _hoisted_2$5 = { class: "flex items-center gap-2" };
const _hoisted_3$5 = ["onDragstart", "onDragover", "onDragleave"];
const _hoisted_4$2 = ["onClick"];
const _hoisted_5$2 = ["src", "alt"];
const _hoisted_6$1 = ["onClick"];
const _hoisted_7$1 = ["title"];
const _hoisted_8$1 = ["onBlur", "onKeydown"];
const _hoisted_9 = {
  key: 0,
  class: "flex flex-col items-center justify-center w-full h-full text-ink-gray-4 bg-surface-gray-1 rounded-[2px]"
};
const _hoisted_10 = ["title"];
const _hoisted_11 = ["src", "alt"];
const _hoisted_12 = ["onClick"];
const _hoisted_13 = ["title"];
const _hoisted_14 = ["onBlur", "onKeydown"];
const _hoisted_15 = {
  key: 1,
  class: "text-p-sm text-ink-gray-5"
};
const _hoisted_16 = {
  key: 2,
  class: "flex flex-col items-center justify-center min-h-[200px]"
};
const _hoisted_17 = { class: "text-ink-gray-4 mb-2" };
const _hoisted_18 = { key: 3 };
const _hoisted_19 = { class: "mb-2 text-sm" };
const _hoisted_20 = { class: "w-full bg-gray-200 rounded h-2 overflow-hidden" };
const _hoisted_21 = {
  key: 0,
  class: "mt-2 text-red-500 text-xs"
};
const _hoisted_22 = { class: "flex justify-end gap-2" };
const _hoisted_23 = {
  key: 0,
  class: "fixed inset-0 z-50 bg-gray-900/60 pointer-events-none flex items-center justify-center"
};
function _sfc_render$i(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(
    Fragment,
    null,
    [
      createVNode($setup["Dialog"], {
        modelValue: $setup.modelValue,
        "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => $setup.modelValue = $event),
        options: {
          title: $setup.props.mode === "edit" ? "Edit Images" : "Upload Images",
          size: "3xl"
        },
        onClose: _cache[9] || (_cache[9] = ($event) => _ctx.$emit("close")),
        disableOutsideClickToClose: true
      }, {
        "body-content": withCtx(() => [
          createBaseVNode("div", _hoisted_1$f, [
            createBaseVNode("div", _hoisted_2$5, [
              createVNode($setup["Button"], { onClick: $setup.triggerFileInput }, {
                prefix: withCtx(() => [
                  createVNode($setup["LucideImagePlus"], { class: "size-4" })
                ]),
                default: withCtx(() => [
                  _cache[10] || (_cache[10] = createTextVNode(" Add images "))
                ]),
                _: 1
                /* STABLE */
              }),
              createVNode($setup["Select"], {
                id: "columns-select",
                options: $setup.selectOptions,
                modelValue: $setup.internalColumns,
                "onUpdate:modelValue": [
                  _cache[0] || (_cache[0] = ($event) => $setup.internalColumns = $event),
                  _cache[1] || (_cache[1] = (val) => $setup.columns = +val)
                ],
                size: "sm",
                variant: "subtle",
                class: "w-28"
              }, null, 8, ["modelValue"])
            ]),
            $setup.images && $setup.images.length ? (openBlock(), createElementBlock(
              "div",
              {
                key: 0,
                class: "grid gap-px mb-4",
                style: normalizeStyle($setup.gridStyle)
              },
              [
                (openBlock(true), createElementBlock(
                  Fragment,
                  null,
                  renderList($setup.images, (item, idx) => {
                    var _a, _b, _c, _d;
                    return openBlock(), createElementBlock("div", {
                      key: item.id,
                      class: normalizeClass(["relative aspect-square w-full h-full overflow-hidden group bg-surface-white", { "ring-2 ring-primary-400 z-10": $setup.isDropTarget(idx) }]),
                      draggable: true,
                      onDragstart: ($event) => $setup.onDragStart(idx),
                      onDragover: ($event) => $setup.onDragOver($event, idx),
                      onDrop: _cache[6] || (_cache[6] = ($event) => $setup.onDrop($event)),
                      onDragend: $setup.onDragEnd,
                      onDragleave: ($event) => $setup.onDragLeave($event, idx)
                    }, [
                      createBaseVNode("button", {
                        type: "button",
                        class: "absolute top-1 right-1 z-10 bg-white/80 hover:bg-white rounded-full p-1 shadow transition-opacity opacity-0 group-hover:opacity-100 focus:opacity-100",
                        "aria-label": "Remove image",
                        onClick: withModifiers(($event) => $setup.removeImage(idx), ["stop"])
                      }, [
                        createVNode($setup["LucideX"], { class: "w-4 h-4 text-gray-700" })
                      ], 8, _hoisted_4$2),
                      createCommentVNode(" Existing images from edit mode "),
                      item.type === "existing" ? (openBlock(), createElementBlock(
                        Fragment,
                        { key: 0 },
                        [
                          createBaseVNode("img", {
                            src: (_a = item.existing) == null ? void 0 : _a.src,
                            alt: ((_b = item.existing) == null ? void 0 : _b.alt) || "",
                            class: "object-cover w-full h-full rounded-[2px]"
                          }, null, 8, _hoisted_5$2),
                          createCommentVNode(" Caption overlay "),
                          createBaseVNode(
                            "div",
                            {
                              class: normalizeClass([
                                "absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/60 to-transparent rounded-b-[2px] transition-opacity",
                                $setup.editingCaption === `${item.type}-${idx}` ? "opacity-100" : "opacity-0 group-hover:opacity-100"
                              ])
                            },
                            [
                              $setup.editingCaption !== `${item.type}-${idx}` ? (openBlock(), createElementBlock("div", {
                                key: 0,
                                class: "p-2 cursor-pointer",
                                onClick: withModifiers(($event) => {
                                  var _a2;
                                  return $setup.startEditingCaption(
                                    `${item.type}-${idx}`,
                                    ((_a2 = item.existing) == null ? void 0 : _a2.alt) || ""
                                  );
                                }, ["stop"])
                              }, [
                                createBaseVNode("div", {
                                  class: "text-white text-xs truncate",
                                  title: ((_c = item.existing) == null ? void 0 : _c.alt) || "Click to add caption"
                                }, toDisplayString(((_d = item.existing) == null ? void 0 : _d.alt) || "Add caption..."), 9, _hoisted_7$1)
                              ], 8, _hoisted_6$1)) : (openBlock(), createElementBlock("div", {
                                key: 1,
                                class: "p-2",
                                onClick: _cache[3] || (_cache[3] = withModifiers(() => {
                                }, ["stop"]))
                              }, [
                                withDirectives(createBaseVNode("input", {
                                  ref_for: true,
                                  ref: (el) => $setup.captionInputRef = el,
                                  "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $setup.captionEditValue = $event),
                                  onBlur: ($event) => $setup.handleCaptionBlur(`${item.type}-${idx}`, idx),
                                  onKeydown: [
                                    withKeys(withModifiers(($event) => $setup.saveCaption(`${item.type}-${idx}`, idx), ["prevent"]), ["enter"]),
                                    withKeys($setup.cancelEditingCaption, ["escape"])
                                  ],
                                  class: "w-full text-xs bg-white/90 text-gray-900 px-1 py-0.5 rounded-sm border-none outline-none",
                                  placeholder: "Add caption...",
                                  maxlength: "200"
                                }, null, 40, _hoisted_8$1), [
                                  [vModelText, $setup.captionEditValue]
                                ])
                              ]))
                            ],
                            2
                            /* CLASS */
                          )
                        ],
                        64
                        /* STABLE_FRAGMENT */
                      )) : item.type === "file" && item.file ? (openBlock(), createElementBlock(
                        Fragment,
                        { key: 1 },
                        [
                          createCommentVNode(" New file uploads "),
                          !$setup.isImageSupported(item.file) ? (openBlock(), createElementBlock("div", _hoisted_9, [
                            createBaseVNode("span", {
                              class: "text-p-xs text-ink-gray-4 w-full text-center px-2 mt-1",
                              title: item.file.name
                            }, toDisplayString(item.file.name), 9, _hoisted_10)
                          ])) : item.file.type.startsWith("image/") ? (openBlock(), createElementBlock(
                            Fragment,
                            { key: 1 },
                            [
                              createBaseVNode("img", {
                                src: $setup.filePreview(item.file),
                                class: "object-cover w-full h-full rounded-[2px]",
                                alt: item.alt || ""
                              }, null, 8, _hoisted_11),
                              createCommentVNode(" Caption overlay "),
                              createBaseVNode(
                                "div",
                                {
                                  class: normalizeClass([
                                    "absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/60 to-transparent rounded-b-[2px] transition-opacity",
                                    $setup.editingCaption === `${item.type}-${idx}` ? "opacity-100" : "opacity-0 group-hover:opacity-100"
                                  ])
                                },
                                [
                                  $setup.editingCaption !== `${item.type}-${idx}` ? (openBlock(), createElementBlock("div", {
                                    key: 0,
                                    class: "p-2 cursor-pointer",
                                    onClick: withModifiers(($event) => $setup.startEditingCaption(`${item.type}-${idx}`, item.alt || ""), ["stop"])
                                  }, [
                                    createBaseVNode("div", {
                                      class: "text-white text-xs truncate",
                                      title: item.alt || "Click to add caption"
                                    }, toDisplayString(item.alt || "Add caption..."), 9, _hoisted_13)
                                  ], 8, _hoisted_12)) : (openBlock(), createElementBlock("div", {
                                    key: 1,
                                    class: "p-2",
                                    onClick: _cache[5] || (_cache[5] = withModifiers(() => {
                                    }, ["stop"]))
                                  }, [
                                    withDirectives(createBaseVNode("input", {
                                      ref_for: true,
                                      ref: "captionInput",
                                      "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => $setup.captionEditValue = $event),
                                      onBlur: ($event) => $setup.handleCaptionBlur(`${item.type}-${idx}`, idx),
                                      onKeydown: [
                                        withKeys(withModifiers(($event) => $setup.saveCaption(`${item.type}-${idx}`, idx), ["prevent"]), ["enter"]),
                                        withKeys($setup.cancelEditingCaption, ["escape"])
                                      ],
                                      class: "w-full text-xs bg-white/90 text-gray-900 px-1 py-0.5 rounded border-none outline-none",
                                      placeholder: "Add caption...",
                                      maxlength: "200"
                                    }, null, 40, _hoisted_14), [
                                      [vModelText, $setup.captionEditValue]
                                    ])
                                  ]))
                                ],
                                2
                                /* CLASS */
                              )
                            ],
                            64
                            /* STABLE_FRAGMENT */
                          )) : createCommentVNode("v-if", true)
                        ],
                        64
                        /* STABLE_FRAGMENT */
                      )) : createCommentVNode("v-if", true)
                    ], 42, _hoisted_3$5);
                  }),
                  128
                  /* KEYED_FRAGMENT */
                ))
              ],
              4
              /* STYLE */
            )) : createCommentVNode("v-if", true),
            $setup.images && $setup.images.length ? (openBlock(), createElementBlock("div", _hoisted_15, " Upload more images by dropping them anywhere in this window. Reorder images by dragging them. Hover over an image to edit caption. ")) : (openBlock(), createElementBlock("div", _hoisted_16, [
              createBaseVNode(
                "div",
                {
                  class: "w-full flex flex-1 flex-col items-center justify-center border border-outline-gray-2 rounded-lg bg-surface-gray-1 h-full cursor-pointer transition hover:border-primary-400 hover:bg-primary-50 text-center",
                  onClick: $setup.triggerFileInput,
                  onDragover: _cache[7] || (_cache[7] = withModifiers(() => {
                  }, ["prevent"])),
                  onDrop: withModifiers($setup.onDrop, ["prevent"])
                },
                [
                  createBaseVNode("div", _hoisted_17, [
                    createVNode($setup["LucideImagePlus"], { class: "size-6" })
                  ]),
                  _cache[11] || (_cache[11] = createBaseVNode(
                    "div",
                    { class: "text-ink-gray-5 text-sm font-medium" },
                    " Drag & drop images here or click to select ",
                    -1
                    /* HOISTED */
                  ))
                ],
                32
                /* NEED_HYDRATION */
              )
            ])),
            $setup.uploading ? (openBlock(), createElementBlock("div", _hoisted_18, [
              createBaseVNode(
                "div",
                _hoisted_19,
                " Uploading: " + toDisplayString($setup.uploadedCount) + "/" + toDisplayString($setup.totalCount),
                1
                /* TEXT */
              ),
              createBaseVNode("div", _hoisted_20, [
                createBaseVNode(
                  "div",
                  {
                    class: "bg-surface-gray-5 h-2 transition-all",
                    style: normalizeStyle({ width: $setup.uploadProgress + "%" })
                  },
                  null,
                  4
                  /* STYLE */
                )
              ]),
              $setup.uploadErrors && $setup.uploadErrors.some((e) => e) ? (openBlock(), createElementBlock("div", _hoisted_21, " Some files failed to upload. ")) : createCommentVNode("v-if", true)
            ])) : createCommentVNode("v-if", true)
          ])
        ]),
        actions: withCtx(() => [
          createBaseVNode("div", _hoisted_22, [
            createVNode($setup["Button"], {
              variant: "ghost",
              disabled: $setup.uploading,
              onClick: $setup.handleCancel
            }, {
              default: withCtx(() => _cache[12] || (_cache[12] = [
                createTextVNode(" Cancel ")
              ])),
              _: 1
              /* STABLE */
            }, 8, ["disabled"]),
            $setup.props.mode === "edit" ? (openBlock(), createBlock($setup["Button"], {
              key: 0,
              variant: "solid",
              loading: $setup.uploading,
              onClick: $setup.handleSave
            }, {
              default: withCtx(() => _cache[13] || (_cache[13] = [
                createTextVNode(" Save ")
              ])),
              _: 1
              /* STABLE */
            }, 8, ["loading"])) : createCommentVNode("v-if", true),
            $setup.props.mode === "new" ? (openBlock(), createBlock($setup["Button"], {
              key: 1,
              variant: "solid",
              loading: $setup.uploading,
              onClick: $setup.handleUpload
            }, {
              default: withCtx(() => _cache[14] || (_cache[14] = [
                createTextVNode(" Upload ")
              ])),
              _: 1
              /* STABLE */
            }, 8, ["loading"])) : createCommentVNode("v-if", true)
          ])
        ]),
        _: 1
        /* STABLE */
      }, 8, ["modelValue", "options"]),
      (openBlock(), createBlock(Teleport, { to: "body" }, [
        createVNode(Transition, {
          name: "fade",
          "enter-active-class": "transition-opacity duration-200",
          "leave-active-class": "transition-opacity duration-200",
          "enter-from-class": "opacity-0",
          "enter-to-class": "opacity-100",
          "leave-from-class": "opacity-100",
          "leave-to-class": "opacity-0"
        }, {
          default: withCtx(() => [
            $setup.isFileDragging ? (openBlock(), createElementBlock("div", _hoisted_23, _cache[15] || (_cache[15] = [
              createBaseVNode(
                "div",
                { class: "text-ink-gray-1 text-base font-medium" },
                " Drop images anywhere ",
                -1
                /* HOISTED */
              )
            ]))) : createCommentVNode("v-if", true)
          ]),
          _: 1
          /* STABLE */
        })
      ]))
    ],
    64
    /* STABLE_FRAGMENT */
  );
}
_sfc_main$o.__file = "src/components/TextEditor/extensions/image-group/ImageGroupUploadDialog.vue";
const ImageGroupUploadDialog = /* @__PURE__ */ _export_sfc(_sfc_main$o, [["render", _sfc_render$i], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/TextEditor/extensions/image-group/ImageGroupUploadDialog.vue"]]);
const _sfc_main$n = /* @__PURE__ */ defineComponent({
  __name: "ImageGroupNodeView",
  props: {
    decorations: { type: Array, required: true },
    selected: { type: Boolean, required: true },
    updateAttributes: { type: Function, required: true },
    deleteNode: { type: Function, required: true },
    node: { type: null, required: true },
    view: { type: null, required: true },
    getPos: { type: Function, required: true },
    innerDecorations: { type: null, required: true },
    editor: { type: Object, required: true },
    extension: { type: Object, required: true },
    HTMLAttributes: { type: Object, required: true }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const props = __props;
    const columns = computed(() => props.node.attrs.columns || 4);
    const images = computed(() => props.node.content.content || []);
    const gridStyle = computed(() => ({
      gridTemplateColumns: `repeat(${columns.value}, minmax(0, 1fr))`
    }));
    const isEditable = ref(props.editor.isEditable);
    const selectOptions = [
      { label: "2 columns", value: "2" },
      { label: "3 columns", value: "3" },
      { label: "4 columns", value: "4" }
    ];
    const internalColumns = computed({
      get: () => String(columns.value),
      set: (val) => props.updateAttributes({ columns: +val })
    });
    const showViewer = ref(false);
    const viewerIndex = ref(0);
    const viewerImages = computed(
      () => images.value.map((img) => ({
        src: img.attrs.src,
        alt: img.attrs.alt || ""
      }))
    );
    const showEditModal = ref(false);
    const editFiles = ref([]);
    const existingImages = computed(
      () => images.value.map((img) => ({
        src: img.attrs.src,
        alt: img.attrs.alt || ""
      }))
    );
    onMounted(() => {
      const updateEditable = () => {
        isEditable.value = props.editor.isEditable;
      };
      props.editor.on("update", updateEditable);
      onUnmounted(() => {
        props.editor.off("update", updateEditable);
      });
    });
    function edit() {
      editFiles.value = [];
      showEditModal.value = true;
    }
    function handleEditModalClose() {
      showEditModal.value = false;
      editFiles.value = [];
    }
    async function handleEditSave(data) {
      props.editor.commands.command(({ tr, state }) => {
        const pos = props.getPos();
        if (typeof pos === "number") {
          const node = state.doc.nodeAt(pos);
          if (node && node.type.name === "imageGroup") {
            const newContent = data.images.map(
              (img) => state.schema.nodes.image.create({ src: img.src, alt: img.alt })
            );
            const newAttrs = { ...node.attrs, columns: data.columns };
            const newNode = node.type.create(newAttrs, newContent);
            tr.replaceWith(pos, pos + node.nodeSize, newNode);
            return true;
          }
        }
        return false;
      });
      showEditModal.value = false;
    }
    function openViewer(idx) {
      if (props.editor.isEditable) return;
      viewerIndex.value = idx;
      showViewer.value = true;
    }
    function removeImage(idx) {
      const newImages = images.value.slice();
      newImages.splice(idx, 1);
      if (newImages.length === 0) {
        props.editor.commands.deleteNode("imageGroup");
      } else {
        props.updateAttributes({});
        props.editor.commands.command(({ tr, state }) => {
          const pos = props.getPos();
          if (typeof pos === "number") {
            const node = state.doc.nodeAt(pos);
            if (node && node.type.name === "imageGroup") {
              const newContent = newImages.map(
                (img) => state.schema.nodes.image.create(img.attrs)
              );
              tr.replaceWith(pos + 1, pos + 1 + node.content.size, newContent);
              return true;
            }
          }
          return false;
        });
      }
    }
    const __returned__ = { props, columns, images, gridStyle, isEditable, selectOptions, internalColumns, showViewer, viewerIndex, viewerImages, showEditModal, editFiles, existingImages, edit, handleEditModalClose, handleEditSave, openViewer, removeImage, get NodeViewWrapper() {
      return NodeViewWrapper;
    }, get LucideX() {
      return LucideX;
    }, get LucideEdit() {
      return LucideEdit;
    }, Button, Select, ImageViewerModal, ImageGroupUploadDialog };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$e = { class: "w-full" };
const _hoisted_2$4 = {
  key: 0,
  class: "flex items-center mb-2 gap-2"
};
const _hoisted_3$4 = ["onClick"];
const _hoisted_4$1 = ["src", "alt", "onClick"];
const _hoisted_5$1 = ["src", "alt"];
const _hoisted_6 = {
  key: 3,
  class: "absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/60 to-transparent rounded-b-[2px] opacity-0 group-hover:opacity-100 transition-opacity"
};
const _hoisted_7 = { class: "p-2" };
const _hoisted_8 = ["title"];
function _sfc_render$h(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock($setup["NodeViewWrapper"], null, {
    default: withCtx(() => [
      createBaseVNode("div", _hoisted_1$e, [
        $setup.isEditable ? (openBlock(), createElementBlock("div", _hoisted_2$4, [
          createVNode($setup["Button"], { onClick: $setup.edit }, {
            prefix: withCtx(() => [
              createVNode($setup["LucideEdit"], { class: "size-4" })
            ]),
            default: withCtx(() => [
              _cache[3] || (_cache[3] = createTextVNode(" Edit "))
            ]),
            _: 1
            /* STABLE */
          }),
          createVNode($setup["Select"], {
            options: $setup.selectOptions,
            modelValue: $setup.internalColumns,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.internalColumns = $event),
            size: "sm",
            variant: "subtle",
            class: "w-28"
          }, null, 8, ["modelValue"])
        ])) : createCommentVNode("v-if", true),
        createBaseVNode(
          "div",
          {
            class: "grid gap-px",
            style: normalizeStyle($setup.gridStyle)
          },
          [
            (openBlock(true), createElementBlock(
              Fragment,
              null,
              renderList($setup.images, (img, idx) => {
                return openBlock(), createElementBlock("div", {
                  key: img.attrs.src + idx,
                  class: "relative aspect-square w-full h-full overflow-hidden bg-surface-white group"
                }, [
                  $setup.isEditable ? (openBlock(), createElementBlock("button", {
                    key: 0,
                    type: "button",
                    class: "absolute top-1 right-1 z-10 bg-white/80 hover:bg-white rounded-full p-1 shadow transition-opacity opacity-0 group-hover:opacity-100 focus:opacity-100",
                    "aria-label": "Remove image",
                    onClick: withModifiers(($event) => $setup.removeImage(idx), ["stop"])
                  }, [
                    createVNode($setup["LucideX"], { class: "w-4 h-4 text-gray-700" })
                  ], 8, _hoisted_3$4)) : createCommentVNode("v-if", true),
                  !$setup.isEditable ? (openBlock(), createElementBlock("img", {
                    key: 1,
                    src: img.attrs.src,
                    alt: img.attrs.alt || "",
                    class: "object-cover w-full h-full not-prose cursor-pointer rounded-[2px]",
                    onClick: ($event) => $setup.openViewer(idx)
                  }, null, 8, _hoisted_4$1)) : (openBlock(), createElementBlock("img", {
                    key: 2,
                    src: img.attrs.src,
                    alt: img.attrs.alt || "",
                    class: "object-cover w-full h-full not-prose rounded-[2px]"
                  }, null, 8, _hoisted_5$1)),
                  createCommentVNode(" Caption overlay (visible when there's alt text) "),
                  img.attrs.alt ? (openBlock(), createElementBlock("div", _hoisted_6, [
                    createBaseVNode("div", _hoisted_7, [
                      createBaseVNode("div", {
                        class: "text-white text-xs truncate",
                        title: img.attrs.alt
                      }, toDisplayString(img.attrs.alt), 9, _hoisted_8)
                    ])
                  ])) : createCommentVNode("v-if", true)
                ]);
              }),
              128
              /* KEYED_FRAGMENT */
            ))
          ],
          4
          /* STYLE */
        ),
        $setup.showViewer ? (openBlock(), createBlock($setup["ImageViewerModal"], {
          key: 1,
          show: $setup.showViewer,
          "onUpdate:show": _cache[1] || (_cache[1] = ($event) => $setup.showViewer = $event),
          images: $setup.viewerImages,
          initialIndex: $setup.viewerIndex
        }, null, 8, ["show", "images", "initialIndex"])) : createCommentVNode("v-if", true),
        $setup.showEditModal ? (openBlock(), createBlock($setup["ImageGroupUploadDialog"], {
          key: 2,
          modelValue: $setup.showEditModal,
          "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $setup.showEditModal = $event),
          files: $setup.editFiles,
          editor: $setup.props.editor,
          mode: "edit",
          existingImages: $setup.existingImages,
          initialColumns: $setup.columns,
          onClose: $setup.handleEditModalClose,
          onSave: $setup.handleEditSave
        }, null, 8, ["modelValue", "files", "editor", "existingImages", "initialColumns"])) : createCommentVNode("v-if", true),
        renderSlot(_ctx.$slots, "default")
      ])
    ]),
    _: 3
    /* FORWARDED */
  });
}
_sfc_main$n.__file = "src/components/TextEditor/extensions/image-group/ImageGroupNodeView.vue";
const ImageGroupNodeView = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["render", _sfc_render$h], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/TextEditor/extensions/image-group/ImageGroupNodeView.vue"]]);
const ImageGroup = Node.create({
  name: "imageGroup",
  group: "block",
  content: "image+",
  // one or more images
  selectable: true,
  draggable: true,
  isolating: true,
  addOptions() {
    return {
      uploadFunction: null,
      HTMLAttributes: {}
    };
  },
  addAttributes() {
    return {
      columns: {
        default: 4
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: 'div[data-type="image-group"]',
        getAttrs: (element) => {
          if (typeof element === "string") return {};
          const el = element;
          return {
            columns: el.getAttribute("data-columns") ? Number(el.getAttribute("data-columns")) : 4
          };
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes, node }) {
    return [
      "div",
      mergeAttributes(
        {
          "data-type": "image-group",
          "data-columns": node.attrs.columns
        },
        this.options.HTMLAttributes,
        HTMLAttributes
      ),
      0
      // content placeholder for child images
    ];
  },
  addNodeView() {
    return VueNodeViewRenderer(ImageGroupNodeView);
  },
  addCommands() {
    return {
      setImageGroup: (attrs) => ({ commands: commands2 }) => {
        return commands2.insertContent({
          type: this.name,
          attrs: {
            columns: attrs.columns || 4
          },
          content: attrs.images.map((img) => ({
            type: "image",
            attrs: img
          }))
        });
      }
    };
  }
});
function useFileUpload() {
  const state = reactive({
    uploading: false,
    progress: 0,
    uploaded: 0,
    total: 0,
    error: null,
    result: null
  });
  const reset = () => {
    state.uploading = false;
    state.progress = 0;
    state.uploaded = 0;
    state.total = 0;
    state.error = null;
    state.result = null;
  };
  const isUploading = computed(() => state.uploading);
  const progress = computed(() => state.progress);
  const error = computed(() => state.error);
  const result = computed(() => state.result);
  return {
    upload: (file, options = {}) => upload(file, options, state, reset),
    reset,
    state,
    isUploading,
    progress,
    error,
    result
  };
}
async function upload(file, options = {}, state, reset) {
  reset();
  state.uploading = true;
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.upload.addEventListener("loadstart", () => {
      state.uploading = true;
      state.error = null;
    });
    xhr.upload.addEventListener("progress", (e) => {
      if (e.lengthComputable) {
        state.uploaded = e.loaded;
        state.total = e.total;
        state.progress = Math.round(e.loaded / e.total * 100);
      }
    });
    xhr.upload.addEventListener("load", () => {
      state.progress = 100;
    });
    xhr.addEventListener("error", (error) => {
      state.uploading = false;
      state.error = "Upload failed";
      reject("Upload failed");
    });
    xhr.onreadystatechange = () => {
      if (xhr.readyState == XMLHttpRequest.DONE) {
        let error;
        if (xhr.status === 200) {
          let r = null;
          try {
            r = JSON.parse(xhr.responseText);
          } catch (e) {
            r = xhr.responseText;
          }
          const result = r.message || r;
          state.result = result;
          resolve(result);
        } else if (xhr.status === 403) {
          error = JSON.parse(xhr.responseText);
        } else {
          try {
            error = JSON.parse(xhr.responseText);
          } catch (e) {
            error = "Upload failed";
          }
        }
        if (error) {
          let exception;
          let errorParts = [
            [error.exc_type, error._error_message].filter(Boolean).join(" ")
          ];
          if (error.exc) {
            exception = error.exc;
            try {
              exception = JSON.parse(exception)[0];
              console.log(exception);
            } catch (e2) {
            }
          }
          let e = new Error(errorParts.join("\n"));
          let messages = error._server_messages ? JSON.parse(error._server_messages) : [];
          messages = messages.map((m) => {
            try {
              return JSON.parse(m).message;
            } catch (error2) {
              return m;
            }
          }).filter(Boolean);
          if (!messages.length) {
            messages = error._error_message ? [error._error_message] : ["Internal Server Error"];
          }
          e.message = messages.join("\n");
          state.error = e;
          reject(e);
        }
        state.uploading = false;
      }
    };
    const uploadEndpoint = options.upload_endpoint || "/api/method/upload_file";
    xhr.open("POST", uploadEndpoint, true);
    xhr.setRequestHeader("Accept", "application/json");
    if (window.csrf_token && window.csrf_token !== "{{ csrf_token }}") {
      xhr.setRequestHeader("X-Frappe-CSRF-Token", window.csrf_token);
    }
    const formData = new FormData();
    if (file) {
      formData.append("file", file, file.name);
    }
    formData.append("is_private", options.private ? "1" : "0");
    formData.append("folder", options.folder || "Home");
    if (options.file_url) {
      formData.append("file_url", options.file_url);
    }
    if (options.doctype) {
      formData.append("doctype", options.doctype);
    }
    if (options.docname) {
      formData.append("docname", options.docname);
    }
    if (options.fieldname) {
      formData.append("fieldname", options.fieldname);
    }
    if (options.method) {
      formData.append("method", options.method);
    }
    if (options.type) {
      formData.append("type", options.type);
    }
    if (options.optimize) {
      formData.append("optimize", "1");
      if (options.max_width) {
        formData.append("max_width", options.max_width.toString());
      }
      if (options.max_height) {
        formData.append("max_height", options.max_height.toString());
      }
    }
    if (options.params) {
      for (let [k, v] of Object.entries(options.params)) {
        formData.append(k, v);
      }
    }
    xhr.send(formData);
  });
}
const _sfc_main$m = /* @__PURE__ */ defineComponent({
  ...{ inheritAttrs: false },
  __name: "TextEditor",
  props: {
    content: { type: [String, null], required: false, default: null },
    placeholder: { type: [String, Function], required: false, default: "" },
    editorClass: { type: [String, Array, Object], required: false, default: "" },
    editable: { type: Boolean, required: false, default: true },
    autofocus: { type: Boolean, required: false, default: false },
    bubbleMenu: { type: [Boolean, Array], required: false, default: false },
    bubbleMenuOptions: { type: Object, required: false, default: () => ({}) },
    fixedMenu: { type: [Boolean, Array], required: false, default: false },
    floatingMenu: { type: [Boolean, Array], required: false, default: false },
    extensions: { type: Array, required: false, default: () => [] },
    starterkitOptions: { type: null, required: false, default: () => ({}) },
    mentions: { type: [Object, Array, null], required: false, default: null },
    tags: { type: Array, required: false, default: () => [] },
    uploadFunction: { type: Function, required: false },
    uploadArgs: { type: Object, required: false }
  },
  emits: ["change", "focus", "blur", "transaction"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const lowlight = createLowlight(grammars);
    function defaultUploadFunction(file) {
      let fileUpload = useFileUpload();
      return fileUpload.upload(file, props.uploadArgs || {});
    }
    const props = __props;
    const emit = __emit;
    const editor = ref(null);
    const attrs = useAttrs();
    const attrsClass = computed(() => normalizeClass(attrs.class));
    const attrsStyle = computed(() => normalizeStyle(attrs.style));
    const editorProps = computed(() => {
      return {
        attributes: {
          class: normalizeClass([
            "prose prose-table:table-fixed prose-td:p-2 prose-th:p-2 prose-td:border prose-th:border prose-td:border-outline-gray-2 prose-th:border-outline-gray-2 prose-td:relative prose-th:relative prose-th:bg-surface-gray-2",
            props.editorClass
          ])
        }
      };
    });
    watch(
      () => props.content,
      (val) => {
        if (editor.value) {
          let currentHTML = editor.value.getHTML();
          if (currentHTML !== val) {
            editor.value.commands.setContent(val);
          }
        }
      }
    );
    watch(
      () => props.editable,
      (value) => {
        if (editor.value) {
          editor.value.setEditable(value);
        }
      }
    );
    watch(
      editorProps,
      (value) => {
        if (editor.value) {
          editor.value.setOptions({
            editorProps: value
          });
        }
      },
      { deep: true }
    );
    onMounted(() => {
      var _a;
      editor.value = new Editor({
        content: props.content || null,
        editorProps: editorProps.value,
        editable: props.editable,
        autofocus: props.autofocus,
        extensions: [
          StarterKit.configure({
            ...props.starterkitOptions,
            codeBlock: false,
            heading: false
          }),
          Heading.configure({
            ...typeof ((_a = props.starterkitOptions) == null ? void 0 : _a.heading) === "object" && props.starterkitOptions.heading !== null ? props.starterkitOptions.heading : {}
          }),
          Table$2.configure({
            resizable: true
          }),
          TaskList,
          TaskItem.configure({
            nested: true
          }),
          TableRow,
          TableHeader,
          TableCell,
          Typography,
          TextAlign.configure({
            types: ["heading", "paragraph"]
          }),
          TextStyle,
          NamedColorExtension,
          NamedHighlightExtension,
          CodeBlockLowlight.extend({
            addNodeView() {
              return VueNodeViewRenderer(CodeBlockComponent);
            }
          }).configure({ lowlight }),
          ImageExtension.configure({
            uploadFunction: props.uploadFunction || defaultUploadFunction
          }),
          ImageGroup.configure({
            uploadFunction: props.uploadFunction || defaultUploadFunction
          }),
          ImageViewerExtension,
          VideoExtension.configure({
            uploadFunction: props.uploadFunction || defaultUploadFunction
          }),
          IframeExtension,
          LinkExtension.configure({
            openOnClick: false
          }),
          Placeholder.configure({
            placeholder: typeof props.placeholder === "function" ? props.placeholder : () => props.placeholder
          }),
          props.mentions && MentionExtension.configure(
            Array.isArray(props.mentions) ? { mentions: props.mentions } : {
              mentions: props.mentions.mentions,
              component: props.mentions.component
            }
          ),
          EmojiExtension,
          SlashCommands,
          TagNode,
          TagExtension.configure({
            tags: () => props.tags
          }),
          ContentPasteExtension.configure({
            enabled: true,
            showConfirmation: true,
            uploadFunction: props.uploadFunction || defaultUploadFunction
          }),
          ...props.extensions || []
        ],
        onUpdate: ({ editor: editor2 }) => {
          emit("change", editor2.getHTML());
        },
        onTransaction: ({ editor: editor2 }) => {
          emit("transaction", editor2);
        },
        onFocus: ({ editor: editor2, event }) => {
          emit("focus", event);
        },
        onBlur: ({ editor: editor2, event }) => {
          emit("blur", event);
        }
      });
    });
    onBeforeUnmount(() => {
      if (editor.value) {
        editor.value.destroy();
        editor.value = null;
      }
    });
    provide(
      "editor",
      computed(() => editor.value)
    );
    __expose({
      editor
    });
    const __returned__ = { lowlight, defaultUploadFunction, props, emit, editor, attrs, attrsClass, attrsStyle, editorProps, get EditorContent() {
      return EditorContent;
    }, TextEditorFixedMenu, TextEditorBubbleMenu, TextEditorFloatingMenu };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render$g(_ctx, _cache, $props, $setup, $data, $options) {
  return $setup.editor ? (openBlock(), createElementBlock(
    "div",
    {
      key: 0,
      class: normalizeClass(["relative w-full", $setup.attrsClass]),
      style: normalizeStyle($setup.attrsStyle)
    },
    [
      createVNode($setup["TextEditorBubbleMenu"], {
        buttons: $props.bubbleMenu,
        options: $props.bubbleMenuOptions
      }, null, 8, ["buttons", "options"]),
      createVNode($setup["TextEditorFixedMenu"], {
        class: "w-full overflow-x-auto rounded-t-lg border border-outline-gray-modals",
        buttons: $props.fixedMenu
      }, null, 8, ["buttons"]),
      createVNode($setup["TextEditorFloatingMenu"], { buttons: $props.floatingMenu }, null, 8, ["buttons"]),
      renderSlot(_ctx.$slots, "top", { editor: $setup.editor }),
      renderSlot(_ctx.$slots, "editor", { editor: $setup.editor }, () => [
        createVNode($setup["EditorContent"], { editor: $setup.editor }, null, 8, ["editor"])
      ]),
      renderSlot(_ctx.$slots, "bottom", { editor: $setup.editor })
    ],
    6
    /* CLASS, STYLE */
  )) : createCommentVNode("v-if", true);
}
_sfc_main$m.__file = "src/components/TextEditor/TextEditor.vue";
const TextEditor = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["render", _sfc_render$g], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/TextEditor/TextEditor.vue"]]);
const _sfc_main$l = {
  __name: "ListEmptyState",
  setup(__props, { expose: __expose }) {
    __expose();
    const list = inject("list");
    const __returned__ = { list, inject, get Button() {
      return Button;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
};
const _hoisted_1$d = { class: "flex h-full w-full flex-col items-center justify-center text-base" };
const _hoisted_2$3 = { class: "text-xl font-medium text-ink-gray-8 mt-6" };
const _hoisted_3$3 = { class: "mt-1 text-base text-ink-gray-5" };
function _sfc_render$f(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$d, [
    renderSlot(_ctx.$slots, "default", {}, () => [
      createBaseVNode(
        "div",
        _hoisted_2$3,
        toDisplayString($setup.list.options.emptyState.title),
        1
        /* TEXT */
      ),
      createBaseVNode(
        "div",
        _hoisted_3$3,
        toDisplayString($setup.list.options.emptyState.description),
        1
        /* TEXT */
      ),
      $setup.list.options.emptyState.button ? (openBlock(), createBlock(
        $setup["Button"],
        mergeProps({ key: 0 }, $setup.list.options.emptyState.button, { class: "mt-4" }),
        null,
        16
        /* FULL_PROPS */
      )) : createCommentVNode("v-if", true)
    ])
  ]);
}
_sfc_main$l.__file = "src/components/ListView/ListEmptyState.vue";
const ListEmptyState = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["render", _sfc_render$f], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/ListView/ListEmptyState.vue"]]);
const _sfc_main$k = {
  __name: "ListRows",
  setup(__props, { expose: __expose }) {
    __expose();
    const list = inject("list");
    const __returned__ = { list, ListRow, inject };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
};
const _hoisted_1$c = { class: "h-full overflow-y-auto" };
function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$c, [
    renderSlot(_ctx.$slots, "default", {}, () => [
      (openBlock(true), createElementBlock(
        Fragment,
        null,
        renderList($setup.list.rows, (row) => {
          return openBlock(), createBlock($setup["ListRow"], {
            key: row[$setup.list.rowKey],
            row
          }, null, 8, ["row"]);
        }),
        128
        /* KEYED_FRAGMENT */
      ))
    ])
  ]);
}
_sfc_main$k.__file = "src/components/ListView/ListRows.vue";
const ListRows = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["render", _sfc_render$e], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/ListView/ListRows.vue"]]);
const _sfc_main$j = {};
const _hoisted_1$b = {
  xmlns: "http://www.w3.org/2000/svg",
  fill: "none",
  viewBox: "0 0 16 16"
};
function _sfc_render$d(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$b, _cache[0] || (_cache[0] = [
    createBaseVNode(
      "path",
      {
        fill: "currentColor",
        d: "M4.293 5.28h7.413a.5.5 0 0 1 .41.787l-3.707 5.295a.5.5 0 0 1-.82 0L3.884 6.067a.5.5 0 0 1 .41-.787Z"
      },
      null,
      -1
      /* HOISTED */
    )
  ]));
}
_sfc_main$j.__file = "src/icons/DownSolid.vue";
const DownSolid = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["render", _sfc_render$d], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/icons/DownSolid.vue"]]);
const _sfc_main$i = {
  __name: "ListGroupHeader",
  props: {
    group: {
      type: Object,
      required: true
    }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const props = __props;
    const list = inject("list");
    function toggleGroup() {
      if (props.group.collapsed == null) {
        props.group.collapsed = false;
      }
      props.group.collapsed = !props.group.collapsed;
    }
    const __returned__ = { props, list, toggleGroup, inject, DownSolid };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
};
const _hoisted_1$a = { class: "flex items-center" };
const _hoisted_2$2 = { class: "w-full py-1.5 pr-2" };
const _hoisted_3$2 = {
  key: 1,
  class: "text-base font-medium leading-6"
};
function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(
    Fragment,
    null,
    [
      createBaseVNode("div", _hoisted_1$a, [
        createBaseVNode("button", {
          onClick: $setup.toggleGroup,
          class: "ml-[3px] mr-[11px] rounded p-1 hover:bg-surface-gray-2"
        }, [
          createVNode($setup["DownSolid"], {
            class: normalizeClass(["h-4 w-4 text-ink-gray-6 transition-transform duration-200", [$props.group.collapsed ? "-rotate-90" : ""]])
          }, null, 8, ["class"])
        ]),
        renderSlot(_ctx.$slots, "default", {}, () => [
          createBaseVNode("div", _hoisted_2$2, [
            $setup.list.slots["group-header"] ? (openBlock(), createBlock(
              resolveDynamicComponent($setup.list.slots["group-header"]),
              normalizeProps(mergeProps({ key: 0 }, { group: $props.group })),
              null,
              16
              /* FULL_PROPS */
            )) : (openBlock(), createElementBlock(
              "span",
              _hoisted_3$2,
              toDisplayString($props.group.group),
              1
              /* TEXT */
            ))
          ])
        ])
      ]),
      _cache[0] || (_cache[0] = createBaseVNode(
        "div",
        { class: "mx-2 h-px border-t border-outline-gray-modals" },
        null,
        -1
        /* HOISTED */
      ))
    ],
    64
    /* STABLE_FRAGMENT */
  );
}
_sfc_main$i.__file = "src/components/ListView/ListGroupHeader.vue";
const ListGroupHeader = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["render", _sfc_render$c], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/ListView/ListGroupHeader.vue"]]);
const _sfc_main$h = {
  __name: "ListGroupRows",
  props: {
    group: {
      type: Object,
      required: true
    }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const props = __props;
    const list = inject("list");
    const __returned__ = { props, list, ListRow, inject };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
};
const _hoisted_1$9 = {
  key: 0,
  class: "mb-5 mt-2"
};
function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
  return !$props.group.collapsed ? (openBlock(), createElementBlock("div", _hoisted_1$9, [
    renderSlot(_ctx.$slots, "default", {}, () => [
      (openBlock(true), createElementBlock(
        Fragment,
        null,
        renderList($props.group.rows, (row) => {
          return openBlock(), createBlock($setup["ListRow"], {
            key: row[$setup.list.rowKey],
            row
          }, null, 8, ["row"]);
        }),
        128
        /* KEYED_FRAGMENT */
      ))
    ])
  ])) : createCommentVNode("v-if", true);
}
_sfc_main$h.__file = "src/components/ListView/ListGroupRows.vue";
const ListGroupRows = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["render", _sfc_render$b], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/ListView/ListGroupRows.vue"]]);
const _sfc_main$g = {
  __name: "ListGroups",
  setup(__props, { expose: __expose }) {
    __expose();
    const list = inject("list");
    const __returned__ = { list, ListGroupHeader, ListGroupRows, inject };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
};
const _hoisted_1$8 = { class: "h-full overflow-y-auto" };
function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$8, [
    (openBlock(true), createElementBlock(
      Fragment,
      null,
      renderList($setup.list.rows, (group) => {
        return openBlock(), createElementBlock("div", {
          key: group.group
        }, [
          renderSlot(_ctx.$slots, "default", {}, () => [
            createVNode($setup["ListGroupHeader"], { group }, {
              default: withCtx(() => [
                _ctx.$slots["group-header"] ? renderSlot(_ctx.$slots, "group-header", mergeProps({
                  key: 0,
                  ref_for: true
                }, { group })) : createCommentVNode("v-if", true)
              ]),
              _: 2
              /* DYNAMIC */
            }, 1032, ["group"]),
            createVNode($setup["ListGroupRows"], { group }, null, 8, ["group"])
          ])
        ]);
      }),
      128
      /* KEYED_FRAGMENT */
    ))
  ]);
}
_sfc_main$g.__file = "src/components/ListView/ListGroups.vue";
const ListGroups = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["render", _sfc_render$a], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/ListView/ListGroups.vue"]]);
const _sfc_main$f = /* @__PURE__ */ Object.assign({
  inheritAttrs: false
}, {
  __name: "ListSelectBanner",
  setup(__props, { expose: __expose }) {
    __expose();
    const list = inject("list");
    let selectedText = computed(() => {
      return list.value.options.selectionText(list.value.selections.size);
    });
    const __returned__ = { list, get selectedText() {
      return selectedText;
    }, set selectedText(v) {
      selectedText = v;
    }, Checkbox, get Button() {
      return Button;
    }, computed, inject };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$7 = {
  key: 0,
  class: "absolute inset-x-0 bottom-6 mx-auto w-max text-base"
};
const _hoisted_2$1 = { class: "flex flex-1 justify-between border-r border-outline-gray-2 text-ink-gray-9" };
const _hoisted_3$1 = { class: "flex items-center space-x-3" };
const _hoisted_4 = { class: "mr-3" };
const _hoisted_5 = { class: "flex items-center space-x-1" };
function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Transition, {
    "enter-active-class": "duration-300 ease-out",
    "enter-from-class": "transform opacity-0",
    "enter-to-class": "opacity-100",
    "leave-active-class": "duration-300 ease-in",
    "leave-from-class": "opacity-100",
    "leave-to-class": "transform opacity-0"
  }, {
    default: withCtx(() => [
      $setup.list.selections.size ? (openBlock(), createElementBlock("div", _hoisted_1$7, [
        createBaseVNode(
          "div",
          {
            class: normalizeClass(["flex min-w-[596px] items-center space-x-3 rounded-lg bg-surface-white px-4 py-2 shadow-2xl", _ctx.$attrs.class])
          },
          [
            renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({
              selections: $setup.list.selections,
              allRowsSelected: $setup.list.allRowsSelected,
              selectAll: () => $setup.list.toggleAllRows(true),
              unselectAll: () => $setup.list.toggleAllRows(false)
            })), () => [
              createBaseVNode("div", _hoisted_2$1, [
                createBaseVNode("div", _hoisted_3$1, [
                  createVNode($setup["Checkbox"], {
                    modelValue: true,
                    disabled: true,
                    class: "text-ink-gray-9"
                  }),
                  createBaseVNode(
                    "div",
                    null,
                    toDisplayString($setup.selectedText),
                    1
                    /* TEXT */
                  )
                ]),
                createBaseVNode("div", _hoisted_4, [
                  renderSlot(_ctx.$slots, "actions", normalizeProps(guardReactiveProps({
                    selections: $setup.list.selections,
                    allRowsSelected: $setup.list.allRowsSelected,
                    selectAll: () => $setup.list.toggleAllRows(true),
                    unselectAll: () => $setup.list.toggleAllRows(false)
                  })))
                ])
              ]),
              createBaseVNode("div", _hoisted_5, [
                createVNode($setup["Button"], {
                  class: normalizeClass(["w- text-ink-gray-7", $setup.list.allRowsSelected ? "cursor-not-allowed" : ""]),
                  disabled: $setup.list.allRowsSelected,
                  variant: "ghost",
                  onClick: _cache[0] || (_cache[0] = ($event) => $setup.list.toggleAllRows(true))
                }, {
                  default: withCtx(() => _cache[2] || (_cache[2] = [
                    createTextVNode(" Select all ")
                  ])),
                  _: 1
                  /* STABLE */
                }, 8, ["disabled", "class"]),
                createVNode($setup["Button"], {
                  icon: "x",
                  variant: "ghost",
                  onClick: _cache[1] || (_cache[1] = ($event) => $setup.list.toggleAllRows(false))
                })
              ])
            ])
          ],
          2
          /* CLASS */
        )
      ])) : createCommentVNode("v-if", true)
    ]),
    _: 3
    /* FORWARDED */
  });
}
_sfc_main$f.__file = "src/components/ListView/ListSelectBanner.vue";
const ListSelectBanner = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["render", _sfc_render$9], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/ListView/ListSelectBanner.vue"]]);
const _sfc_main$e = /* @__PURE__ */ Object.assign({
  inheritAttrs: false
}, {
  __name: "ListView",
  props: {
    columns: {
      type: Array,
      default: []
    },
    rows: {
      type: Array,
      default: []
    },
    rowKey: {
      type: String,
      required: true
    },
    options: {
      type: Object,
      default: () => ({
        getRowRoute: null,
        onRowClick: null,
        showTooltip: true,
        selectable: true,
        resizeColumn: false,
        rowHeight: 40,
        emptyState: {
          title: "No Data",
          description: "No data available"
        }
      })
    }
  },
  emits: ["update:selections", "update:active-row"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const slots = useSlots();
    let selections = reactive(/* @__PURE__ */ new Set());
    let activeRow = ref(null);
    const emit = __emit;
    watch(selections, (value) => {
      if (selections.size) {
        activeRow.value = null;
      }
      emit("update:selections", value);
    });
    watch(activeRow, (value) => {
      emit("update:active-row", value);
    });
    let _options = computed(() => {
      function defaultTrue(value) {
        return value === void 0 ? true : value;
      }
      function defaultFalse(value) {
        return value === void 0 ? false : value;
      }
      return {
        getRowRoute: props.options.getRowRoute || null,
        onRowClick: props.options.onRowClick || null,
        showTooltip: defaultTrue(props.options.showTooltip),
        selectionText: props.options.selectionText || ((val) => val === 1 ? "1 row selected" : `${val} rows selected`),
        enableActive: defaultFalse(props.options.enableActive),
        selectable: defaultTrue(props.options.selectable),
        resizeColumn: defaultFalse(props.options.resizeColumn),
        rowHeight: props.options.rowHeight || 40,
        emptyState: props.options.emptyState
      };
    });
    const allRowsSelected = computed(() => {
      if (!props.rows.length) return false;
      if (showGroupedRows.value) {
        return selections.size === props.rows.reduce((acc, row) => acc + row.rows.length, 0);
      }
      return selections.size === props.rows.length;
    });
    const selectable = computed(() => {
      return _options.value.selectable;
    });
    let showGroupedRows = computed(() => {
      return props.rows.every(
        (row) => row.group && row.rows && Array.isArray(row.rows)
      );
    });
    function toggleRow(row) {
      if (!selections.delete(row)) {
        selections.add(row);
      }
    }
    function toggleAllRows(select) {
      if (!select || allRowsSelected.value) {
        selections.clear();
        return;
      }
      if (showGroupedRows.value) {
        props.rows.forEach((row) => {
          row.rows.forEach((r) => selections.add(r[props.rowKey]));
        });
        return;
      }
      props.rows.forEach((row) => selections.add(row[props.rowKey]));
    }
    provide(
      "list",
      computed(() => ({
        rowKey: props.rowKey,
        rows: props.rows,
        columns: props.columns,
        options: _options.value,
        selections,
        activeRow,
        allRowsSelected: allRowsSelected.value,
        slots,
        toggleRow,
        toggleAllRows
      }))
    );
    __expose({
      selections,
      allRowsSelected,
      toggleRow,
      toggleAllRows
    });
    const __returned__ = { props, slots, get selections() {
      return selections;
    }, set selections(v) {
      selections = v;
    }, get activeRow() {
      return activeRow;
    }, set activeRow(v) {
      activeRow = v;
    }, emit, get _options() {
      return _options;
    }, set _options(v) {
      _options = v;
    }, allRowsSelected, selectable, get showGroupedRows() {
      return showGroupedRows;
    }, set showGroupedRows(v) {
      showGroupedRows = v;
    }, toggleRow, toggleAllRows, ListEmptyState, ListHeader, ListRows, ListGroups, ListSelectBanner, ref, reactive, computed, provide, watch, useSlots };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$6 = { class: "relative flex w-full flex-1 flex-col overflow-x-auto" };
function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$6, [
    createBaseVNode(
      "div",
      {
        class: normalizeClass(["flex w-max min-w-full flex-col overflow-y-hidden", _ctx.$attrs.class]),
        style: normalizeStyle(_ctx.$attrs.style)
      },
      [
        renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({ showGroupedRows: $setup.showGroupedRows, selectable: $setup.selectable })), () => [
          createVNode($setup["ListHeader"]),
          $setup.props.rows.length ? (openBlock(), createElementBlock(
            Fragment,
            { key: 0 },
            [
              $setup.showGroupedRows ? (openBlock(), createBlock($setup["ListGroups"], { key: 0 })) : (openBlock(), createBlock($setup["ListRows"], { key: 1 }))
            ],
            64
            /* STABLE_FRAGMENT */
          )) : (openBlock(), createBlock($setup["ListEmptyState"], { key: 1 })),
          $setup.selectable ? (openBlock(), createBlock($setup["ListSelectBanner"], { key: 2 })) : createCommentVNode("v-if", true)
        ])
      ],
      6
      /* CLASS, STYLE */
    )
  ]);
}
_sfc_main$e.__file = "src/components/ListView/ListView.vue";
const ListView = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["render", _sfc_render$8], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/ListView/ListView.vue"]]);
const _sfc_main$d = {
  __name: "ListFooter",
  props: {
    modelValue: {
      type: Number,
      default: 20
    },
    options: {
      type: Object,
      default: () => ({
        rowCount: 0,
        totalCount: 0,
        pageLengthOptions: [20, 50, 100]
      })
    }
  },
  emits: ["update:modelValue", "loadMore"],
  setup(__props, { expose: __expose, emit: __emit }) {
    __expose();
    const props = __props;
    const emit = __emit;
    const pageLengthCount = computed({
      get: () => props.modelValue,
      set: (value) => emit("update:modelValue", value)
    });
    const pageLengthOptions = ref(props.options.pageLengthOptions || [20, 50, 100]);
    const showLoadMore = computed(() => {
      return props.options.rowCount && props.options.totalCount && props.options.rowCount < props.options.totalCount;
    });
    const __returned__ = { props, emit, pageLengthCount, pageLengthOptions, showLoadMore, TabButtons, ref, computed };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
};
_sfc_main$d.__file = "src/components/ListView/ListFooter.vue";
const _hoisted_1$5 = {
  class: "lucide lucide-info",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function render$1(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$5, _cache[0] || (_cache[0] = [
    createBaseVNode(
      "circle",
      {
        cx: "12",
        cy: "12",
        r: "10"
      },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      { d: "M12 16v-4" },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      { d: "M12 8h.01" },
      null,
      -1
      /* HOISTED */
    )
  ]));
}
const LucideInfo = markRaw({ name: "lucide-info", render: render$1 });
const _hoisted_1$4 = {
  class: "lucide lucide-triangle-alert",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function render(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4, _cache[0] || (_cache[0] = [
    createBaseVNode(
      "path",
      { d: "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3" },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      { d: "M12 9v4" },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      { d: "M12 17h.01" },
      null,
      -1
      /* HOISTED */
    )
  ]));
}
const LucideAlertTriangle = markRaw({ name: "lucide-alert-triangle", render });
const _sfc_main$c = {};
const _hoisted_1$3 = {
  xmlns: "http://www.w3.org/2000/svg",
  fill: "none",
  viewBox: "0 0 16 16"
};
function _sfc_render$7(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3, _cache[0] || (_cache[0] = [
    createBaseVNode(
      "path",
      {
        fill: "currentColor",
        d: "M8 .75a7.25 7.25 0 1 1 0 14.5A7.25 7.25 0 0 1 8 .75Zm0 1a6.25 6.25 0 1 0 0 12.5 6.25 6.25 0 0 0 0-12.5Zm2.59 3.527a.501.501 0 0 1 .758.623l-.057.085-3.848 4.666a.501.501 0 0 1-.78-.011L4.936 8.41l-.053-.086a.501.501 0 0 1 .775-.6l.07.074 1.34 1.733 3.45-4.183.072-.072Z"
      },
      null,
      -1
      /* HOISTED */
    )
  ]));
}
_sfc_main$c.__file = "src/icons/CircleCheck.vue";
const CircleCheck = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["render", _sfc_render$7], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/icons/CircleCheck.vue"]]);
const _sfc_main$b = /* @__PURE__ */ defineComponent({
  __name: "Toast",
  props: {
    open: { type: Boolean, required: true },
    message: { type: String, required: false },
    type: { type: String, required: false },
    duration: { type: Number, required: false },
    icon: { type: null, required: false },
    closable: { type: Boolean, required: false },
    action: { type: Object, required: false }
  },
  emits: ["update:open", "action"],
  setup(__props, { expose: __expose, emit: __emit }) {
    __expose();
    const props = __props;
    const emit = __emit;
    const modelOpen = computed({
      get: () => props.open,
      set: (value) => emit("update:open", value)
    });
    function handleAction() {
      var _a, _b;
      (_b = (_a = props.action) == null ? void 0 : _a.onClick) == null ? void 0 : _b.call(_a);
      emit("action");
    }
    const __returned__ = { props, emit, modelOpen, handleAction, get ToastAction() {
      return ToastAction_default;
    }, get ToastClose() {
      return ToastClose_default;
    }, get ToastDescription() {
      return ToastDescription_default;
    }, get ToastRoot() {
      return ToastRoot_default;
    }, get LucideInfo() {
      return LucideInfo;
    }, get LucideAlertTriangle() {
      return LucideAlertTriangle;
    }, get LucideX() {
      return LucideX;
    }, CircleCheck };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$2 = { class: "flex items-center gap-2 flex-grow overflow-hidden" };
const _hoisted_2 = { class: "flex flex-col flex-grow overflow-hidden" };
const _hoisted_3 = { class: "flex items-center gap-2 h-7" };
function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock($setup["ToastRoot"], {
    open: $setup.modelOpen,
    "onUpdate:open": _cache[0] || (_cache[0] = ($event) => $setup.modelOpen = $event),
    duration: $props.closable ? $props.duration : 0,
    class: normalizeClass([
      "toast-root-animatable",
      "bg-surface-gray-6 border-none rounded-md px-4 py-1.5 shadow-lg flex items-center justify-between gap-3 min-w-[280px] max-w-[400px] pointer-events-auto list-none"
    ])
  }, {
    default: withCtx(() => [
      createBaseVNode("div", _hoisted_1$2, [
        createBaseVNode("div", null, [
          $props.icon ? (openBlock(), createBlock(resolveDynamicComponent($props.icon), {
            key: 0,
            class: "flex-shrink-0 size-4"
          })) : $props.type == "success" ? (openBlock(), createBlock($setup["CircleCheck"], {
            key: 1,
            class: "flex-shrink-0 size-4 text-ink-green-2"
          })) : $props.type == "warning" ? (openBlock(), createBlock($setup["LucideAlertTriangle"], {
            key: 2,
            class: "flex-shrink-0 size-4 text-ink-amber-2"
          })) : $props.type == "error" ? (openBlock(), createBlock($setup["LucideInfo"], {
            key: 3,
            class: "flex-shrink-0 size-4 text-ink-red-2"
          })) : createCommentVNode("v-if", true)
        ]),
        createBaseVNode("div", _hoisted_2, [
          $props.message ? (openBlock(), createBlock($setup["ToastDescription"], {
            key: 0,
            class: "text-p-sm break-words text-ink-white",
            innerHTML: $props.message
          }, null, 8, ["innerHTML"])) : createCommentVNode("v-if", true)
        ])
      ]),
      createBaseVNode("div", _hoisted_3, [
        $props.action ? (openBlock(), createBlock($setup["ToastAction"], {
          key: 0,
          class: "flex-shrink-0 rounded px-2 py-1 text-sm text-ink-blue-link hover:text-ink-gray-3 focus:outline-none focus-visible:ring focus-visible:ring-outline-gray-4",
          "alt-text": $props.action.altText || $props.action.label,
          onClick: $setup.handleAction
        }, {
          default: withCtx(() => [
            createTextVNode(
              toDisplayString($props.action.label),
              1
              /* TEXT */
            )
          ]),
          _: 1
          /* STABLE */
        }, 8, ["alt-text"])) : createCommentVNode("v-if", true),
        $props.closable ? (openBlock(), createBlock($setup["ToastClose"], {
          key: 1,
          class: "flex-shrink-0 rounded p-1 text-ink-white hover:text-ink-gray-3 focus:outline-none focus-visible:ring focus-visible:ring-outline-gray-4"
        }, {
          default: withCtx(() => [
            createVNode($setup["LucideX"], { class: "size-4" })
          ]),
          _: 1
          /* STABLE */
        })) : createCommentVNode("v-if", true)
      ])
    ]),
    _: 1
    /* STABLE */
  }, 8, ["open", "duration"]);
}
_sfc_main$b.__file = "src/components/Toast/Toast.vue";
const ToastComponent = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["render", _sfc_render$6], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/Toast/Toast.vue"]]);
const toastsState = ref([]);
let toastIdCounter = 0;
const updateToastInState = (id, updates) => {
  const index = toastsState.value.findIndex((t) => t.id === id);
  if (index !== -1) {
    toastsState.value[index] = {
      ...toastsState.value[index],
      ...updates,
      open: true
    };
  }
};
const toast = {
  create: (options) => {
    const id = `toast-${toastIdCounter++}`;
    const durationInMs = options.duration != null ? options.duration * 1e3 : 5e3;
    const sanitizedMessage = purify.sanitize(options.message, {
      ALLOWED_TAGS: ["a", "em", "strong", "i", "b", "u"]
    });
    const toastItem = {
      id: options.id || id,
      open: true,
      message: sanitizedMessage,
      type: options.type || "info",
      duration: durationInMs,
      action: options.action,
      icon: options.icon,
      closable: options.closable ?? true
    };
    toastsState.value.push(toastItem);
    return toastItem.id;
  },
  remove: (id) => {
    toastsState.value = toastsState.value.filter((t) => t.id !== id);
  },
  removeAll: () => {
    toastsState.value = [];
  },
  promise: async (promiseToResolve, options) => {
    const loadingDurationInSeconds = options.duration ?? 0;
    const toastId = toast.create({
      message: options.loading,
      type: "info",
      icon: () => h(LoadingIndicator, { class: "text-ink-white" }),
      duration: loadingDurationInSeconds,
      closable: false
    });
    try {
      const data = await promiseToResolve;
      const successMessage = typeof options.success === "function" ? options.success(data) : options.success;
      const successToastDurationInSeconds = options.successDuration ?? options.duration ?? 5;
      updateToastInState(toastId, {
        message: successMessage,
        type: "success",
        duration: successToastDurationInSeconds * 1e3,
        icon: void 0,
        closable: true
      });
      return data;
    } catch (error) {
      const errorMessage = typeof options.error === "function" ? options.error(error) : options.error;
      const errorToastDurationInSeconds = options.errorDuration ?? options.duration ?? 5;
      updateToastInState(toastId, {
        message: errorMessage,
        type: "error",
        duration: errorToastDurationInSeconds * 1e3,
        icon: void 0,
        closable: true
      });
      throw error;
    }
  },
  success: (message, options = {}) => toast.create({ message, type: "success", ...options }),
  error: (message, options = {}) => toast.create({ message, type: "error", ...options }),
  warning: (message, options = {}) => toast.create({ message, type: "warning", ...options }),
  info: (message, options = {}) => toast.create({ message, type: "info", ...options })
};
const Toasts = defineComponent({
  name: "FrappeToasts",
  setup() {
    const handleUpdateOpen = (id, isOpen) => {
      if (!isOpen) {
        toast.remove(id);
      } else {
        const t = toastsState.value.find((item) => item.id === id);
        if (t) t.open = true;
      }
    };
    const handleActionForItem = (toastItem) => {
      toast.remove(toastItem.id);
    };
    return () => toastsState.value.map(
      (t) => h(ToastComponent, {
        key: t.id,
        open: t.open,
        message: t.message,
        type: t.type,
        duration: t.duration,
        action: t.action,
        icon: t.icon,
        closable: t.closable,
        "onUpdate:open": (isOpen) => handleUpdateOpen(t.id, isOpen),
        onAction: () => handleActionForItem(t)
      })
    );
  }
});
const _sfc_main$a = {
  __name: "CommandPalette",
  props: {
    show: { type: Boolean, default: false },
    searchQuery: { type: String, default: "" },
    groups: { type: Array, default: () => [] }
  },
  emits: ["update:show", "update:searchQuery", "select"],
  setup(__props, { expose: __expose, emit: __emit }) {
    __expose();
    const emit = __emit;
    const props = __props;
    const show = computed({
      get: () => props.show,
      set: (value) => emit("update:show", value)
    });
    const searchQuery = computed({
      get: () => props.searchQuery,
      set: (value) => emit("update:searchQuery", value)
    });
    function select(item) {
      emit("select", item);
      show.value = false;
    }
    function keydownWatcher(e) {
      if (e.key === "Escape" && show.value) {
        show.value = false;
        e.preventDefault();
      }
      if (e.key === "k" && (e.ctrlKey || e.metaKey) && !e.target.classList.contains("ProseMirror")) {
        show.value = true;
        e.preventDefault();
      }
    }
    onMounted(() => window.addEventListener("keydown", keydownWatcher));
    onBeforeUnmount(() => window.removeEventListener("keydown", keydownWatcher));
    const __returned__ = { emit, props, show, searchQuery, select, keydownWatcher, get Combobox() {
      return lt;
    }, get ComboboxInput() {
      return it;
    }, get ComboboxOption() {
      return rt;
    }, get ComboboxOptions() {
      return ut;
    }, computed, onBeforeUnmount, onMounted };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
};
_sfc_main$a.__file = "src/components/CommandPalette/CommandPalette.vue";
const _sfc_main$9 = {
  __name: "CommandPaletteItem",
  props: {
    item: { type: Object, required: true },
    active: { type: Boolean, default: false }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const __returned__ = {};
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
};
_sfc_main$9.__file = "src/components/CommandPalette/CommandPaletteItem.vue";
const _sfc_main$8 = {};
const _hoisted_1$1 = {
  width: "16",
  height: "17",
  viewBox: "0 0 16 17",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
};
function _sfc_render$5(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1, _cache[0] || (_cache[0] = [
    createBaseVNode(
      "path",
      {
        d: "M2 4.5H14",
        stroke: "currentColor",
        "stroke-miterlimit": "10",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
      },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      {
        d: "M4 8.5H12",
        stroke: "currentColor",
        "stroke-miterlimit": "10",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
      },
      null,
      -1
      /* HOISTED */
    ),
    createBaseVNode(
      "path",
      {
        d: "M6.5 12.5H9.5",
        stroke: "currentColor",
        "stroke-miterlimit": "10",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
      },
      null,
      -1
      /* HOISTED */
    )
  ]));
}
_sfc_main$8.__file = "src/components/ListFilter/FilterIcon.vue";
const FilterIcon = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["render", _sfc_render$5], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/ListFilter/FilterIcon.vue"]]);
const _sfc_main$7 = {
  __name: "NestedPopover",
  props: {
    placement: {
      type: String,
      default: "bottom-start"
    }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const props = __props;
    const reference = ref(null);
    const popover = ref(null);
    let popper = ref(null);
    function setupPopper() {
      if (!popper.value) {
        popper.value = createPopper(reference.value.el, popover.value.el, {
          placement: props.placement
        });
      } else {
        popper.value.update();
      }
    }
    function updatePosition() {
      nextTick(() => setupPopper());
    }
    onBeforeUnmount(() => {
      var _a;
      (_a = popper.value) == null ? void 0 : _a.destroy();
    });
    const __returned__ = { props, reference, popover, get popper() {
      return popper;
    }, set popper(v) {
      popper = v;
    }, setupPopper, updatePosition, get Popover() {
      return ye;
    }, get PopoverButton() {
      return Ge;
    }, get PopoverPanel() {
      return je;
    }, get createPopper() {
      return createPopper;
    }, nextTick, ref, onBeforeUnmount };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
};
function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock($setup["Popover"], null, {
    default: withCtx(({ open }) => [
      createVNode(
        $setup["PopoverButton"],
        {
          as: "div",
          ref: "reference",
          onClick: $setup.updatePosition,
          onFocusin: $setup.updatePosition,
          onKeydown: $setup.updatePosition
        },
        {
          default: withCtx(({ open: open2 }) => [
            renderSlot(_ctx.$slots, "target", normalizeProps(guardReactiveProps({ open: open2 })))
          ]),
          _: 2
          /* DYNAMIC */
        },
        1536
        /* NEED_PATCH, DYNAMIC_SLOTS */
      ),
      withDirectives(createBaseVNode(
        "div",
        null,
        [
          createVNode(
            $setup["PopoverPanel"],
            {
              ref: "popover",
              static: "",
              class: "z-[100]"
            },
            {
              default: withCtx(({ open: open2, close }) => [
                renderSlot(_ctx.$slots, "body", normalizeProps(guardReactiveProps({ open: open2, close })))
              ]),
              _: 2
              /* DYNAMIC */
            },
            1536
            /* NEED_PATCH, DYNAMIC_SLOTS */
          )
        ],
        512
        /* NEED_PATCH */
      ), [
        [vShow, open]
      ])
    ]),
    _: 3
    /* FORWARDED */
  });
}
_sfc_main$7.__file = "src/components/ListFilter/NestedPopover.vue";
const NestedPopover = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render$4], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/ListFilter/NestedPopover.vue"]]);
const _sfc_main$6 = {
  __name: "SearchComplete",
  props: {
    value: {
      type: String,
      required: false,
      default: ""
    },
    doctype: {
      type: String,
      required: true
    },
    searchField: {
      type: String,
      required: false,
      default: "name"
    },
    labelField: {
      type: String,
      required: false,
      default: "name"
    },
    valueField: {
      type: String,
      required: false,
      default: "name"
    },
    pageLength: {
      type: Number,
      required: false,
      default: 10
    }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const props = __props;
    watch(
      () => props.doctype,
      (value) => {
        r.doctype = value;
        r.reload();
      }
    );
    const r = createListResource({
      doctype: props.doctype,
      pageLength: props.pageLength,
      cache: ["link_doctype", props.doctype],
      auto: true,
      fields: [props.labelField, props.searchField, props.valueField],
      onSuccess: () => {
        selection.value = props.value ? options.value.find((o) => o.value === props.value) : null;
      }
    });
    const options = computed(
      () => {
        var _a;
        return ((_a = r.data) == null ? void 0 : _a.map((result) => ({
          label: result[props.labelField],
          value: result[props.valueField]
        }))) || [];
      }
    );
    const selection = ref(null);
    function onUpdateQuery(query) {
      r.update({
        filters: {
          [props.searchField]: ["like", `%${query}%`]
        }
      });
      r.reload();
    }
    const __returned__ = { props, r, options, selection, onUpdateQuery, get Autocomplete() {
      return Autocomplete;
    }, get createListResource() {
      return createListResource;
    }, computed, ref, watch };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
};
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock($setup["Autocomplete"], {
    placeholder: "Select an option",
    options: $setup.options,
    value: $setup.selection,
    "onUpdate:query": _cache[0] || (_cache[0] = (q) => $setup.onUpdateQuery(q)),
    onChange: _cache[1] || (_cache[1] = (v) => $setup.selection = v)
  }, null, 8, ["options", "value"]);
}
_sfc_main$6.__file = "src/components/ListFilter/SearchComplete.vue";
const SearchComplete = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["render", _sfc_render$3], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/ListFilter/SearchComplete.vue"]]);
const _sfc_main$5 = {
  __name: "ListFilter",
  props: {
    modelValue: {
      type: Object,
      default: () => ({})
    },
    docfields: {
      type: Array,
      default: () => []
    }
  },
  emits: ["update:modelValue"],
  setup(__props, { expose: __expose, emit: __emit }) {
    __expose();
    const typeCheck = ["Check"];
    const typeLink = ["Link"];
    const typeNumber = ["Float", "Int"];
    const typeSelect = ["Select"];
    const typeString = [
      "Data",
      "Long Text",
      "Small Text",
      "Text Editor",
      "Text",
      "JSON",
      "Code"
    ];
    const emits = __emit;
    const props = __props;
    const fields = computed(() => {
      const fields2 = props.docfields.filter((field) => {
        return !field.is_virtual && (typeCheck.includes(field.fieldtype) || typeLink.includes(field.fieldtype) || typeNumber.includes(field.fieldtype) || typeSelect.includes(field.fieldtype) || typeString.includes(field.fieldtype));
      }).map((field) => {
        return {
          label: field.label,
          value: field.fieldname,
          description: field.fieldtype,
          ...field
        };
      });
      return fields2;
    });
    const filters = computed({
      get: () => makeFiltersList(props.modelValue),
      set: (value) => emits("update:modelValue", makeFiltersDict(value))
    });
    function makeFiltersList(filtersDict) {
      return Object.entries(filtersDict).map(([fieldname, [operator, value]]) => {
        const field = getField(fieldname);
        return {
          fieldname,
          operator,
          value,
          field
        };
      });
    }
    function getField(fieldname) {
      return fields.value.find((f) => f.fieldname === fieldname);
    }
    function makeFiltersDict(filtersList) {
      return filtersList.reduce((acc, filter) => {
        const { fieldname, operator, value } = filter;
        acc[fieldname] = [operator, value];
        return acc;
      }, {});
    }
    function getOperators(fieldtype) {
      let options = [];
      if (typeString.includes(fieldtype) || typeLink.includes(fieldtype)) {
        options.push(
          ...[
            { label: "Equals", value: "=" },
            { label: "Not Equals", value: "!=" },
            { label: "Like", value: "like" },
            { label: "Not Like", value: "not like" }
          ]
        );
      }
      if (typeNumber.includes(fieldtype)) {
        options.push(
          ...[
            { label: "<", value: "<" },
            { label: ">", value: ">" },
            { label: "<=", value: "<=" },
            { label: ">=", value: ">=" },
            { label: "Equals", value: "=" },
            { label: "Not Equals", value: "!=" }
          ]
        );
      }
      if (typeSelect.includes(fieldtype)) {
        options.push(
          ...[
            { label: "Equals", value: "=" },
            { label: "Not Equals", value: "!=" }
          ]
        );
      }
      if (typeCheck.includes(fieldtype)) {
        options.push(...[{ label: "Equals", value: "=" }]);
      }
      return options;
    }
    function getDefaultOperator(fieldtype) {
      if (typeSelect.includes(fieldtype) || typeLink.includes(fieldtype) || typeCheck.includes(fieldtype) || typeNumber.includes(fieldtype)) {
        return "=";
      }
      return "like";
    }
    function getValueSelector(fieldtype, options) {
      if (typeSelect.includes(fieldtype) || typeCheck.includes(fieldtype)) {
        const _options = fieldtype == "Check" ? ["Yes", "No"] : getSelectOptions(options);
        return h(FormControl, {
          type: "select",
          options: _options
        });
      } else {
        return h(FormControl, { type: "text" });
      }
    }
    function getDefaultValue(field) {
      if (typeSelect.includes(field.fieldtype)) {
        return getSelectOptions(field.options)[0];
      }
      if (typeCheck.includes(field.fieldtype)) {
        return "Yes";
      }
      return "";
    }
    function getSelectOptions(options) {
      return options.split("\n");
    }
    function addFilter(fieldname) {
      const field = getField(fieldname);
      const filter = {
        fieldname,
        operator: getDefaultOperator(field.fieldtype),
        value: getDefaultValue(field),
        field
      };
      filters.value = [...filters.value, filter];
    }
    function removeFilter(index) {
      filters.value = filters.value.filter((_, i) => i !== index);
    }
    const __returned__ = { typeCheck, typeLink, typeNumber, typeSelect, typeString, emits, props, fields, filters, makeFiltersList, getField, makeFiltersDict, getOperators, getDefaultOperator, getValueSelector, getDefaultValue, getSelectOptions, addFilter, removeFilter, get Autocomplete() {
      return Autocomplete;
    }, get FeatherIcon() {
      return FeatherIcon;
    }, get FormControl() {
      return FormControl;
    }, computed, h, FilterIcon, NestedPopover, SearchComplete };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
};
_sfc_main$5.__file = "src/components/ListFilter/ListFilter.vue";
const _sfc_main$4 = /* @__PURE__ */ defineComponent({
  __name: "ToastProvider",
  setup(__props, { expose: __expose }) {
    __expose();
    const __returned__ = { get ToastProvider() {
      return ToastProvider_default;
    }, get ToastViewport() {
      return ToastViewport_default;
    }, get Toasts() {
      return Toasts;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock($setup["ToastProvider"], { "swipe-direction": "down" }, {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default"),
      createVNode($setup["Toasts"]),
      createVNode($setup["ToastViewport"], { class: "fixed bottom-0 items-end right-0 flex flex-col p-5 gap-[10px] w-auto max-w-full z-[2147483647] outline-none pointer-events-none" })
    ]),
    _: 3
    /* FORWARDED */
  });
}
_sfc_main$4.__file = "src/components/Toast/ToastProvider.vue";
const ToastProvider = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$2], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/Toast/ToastProvider.vue"]]);
const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  __name: "FrappeUIProvider",
  setup(__props, { expose: __expose }) {
    __expose();
    const __returned__ = { ToastProvider };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
_sfc_main$3.__file = "src/components/Provider/FrappeUIProvider.vue";
const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  __name: "Layout",
  props: /* @__PURE__ */ mergeModels({
    cols: { type: Number, required: false },
    rowHeight: { type: Number, required: false },
    disabled: { type: null, required: false }
  }, {
    "modelValue": { type: Array, ...{
      type: Array,
      default: () => []
    } },
    "modelModifiers": {}
  }),
  emits: ["update:modelValue"],
  setup(__props, { expose: __expose }) {
    __expose();
    const props = __props;
    const layout = useModel(__props, "modelValue");
    const layoutReady = ref(false);
    const options = reactive({
      colNum: props.cols || 12,
      margin: [0, 0],
      rowHeight: props.rowHeight || 52,
      isDraggable: computed(() => !props.disabled),
      isResizable: computed(() => !props.disabled),
      responsive: true,
      verticalCompact: true,
      preventCollision: false,
      useCssTransforms: true,
      cols: {
        lg: props.cols || 12,
        md: props.cols || 12,
        sm: props.cols || 12,
        xs: 1,
        xxs: 1
      }
    });
    const __returned__ = { props, layout, layoutReady, options, get GridLayout() {
      return De;
    }, get GridItem() {
      return ot;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
_sfc_main$2.__file = "src/components/VueGridLayout/Layout.vue";
const fileToBase64 = (file) => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onloadend = () => {
      if (reader.result == null) {
        reject(new Error("FileReader result is null"));
      } else if (typeof reader.result === "string") {
        resolve(reader.result);
      }
    };
    reader.readAsDataURL(file);
  });
};
function request(_options) {
  let options = Object.assign({}, _options);
  if (!options.url) {
    throw new Error("[request] options.url is required");
  }
  if (options.transformRequest) {
    options = options.transformRequest(_options);
  }
  if (!options.responseType) {
    options.responseType = "json";
  }
  if (!options.method) {
    options.method = "GET";
  }
  let url = options.url;
  let body;
  if (options.params) {
    if (options.method === "GET") {
      let params = new URLSearchParams();
      for (let key in options.params) {
        params.append(key, options.params[key]);
      }
      url = options.url + "?" + params.toString();
    } else {
      body = JSON.stringify(options.params);
    }
  }
  return fetch(url, {
    method: options.method || "GET",
    headers: options.headers,
    body
  }).then((response) => {
    if (options.transformResponse) {
      return options.transformResponse(response, options);
    }
    if (response.status >= 200 && response.status < 300) {
      if (options.responseType === "json") {
        return response.json();
      }
      return response;
    } else {
      let error = new Error(response.statusText);
      error.response = response;
      throw error;
    }
  }).catch((error) => {
    if (options.transformError) {
      return options.transformError(error);
    }
    throw error;
  });
}
function saveLocal(key, data) {
  if (typeof indexedDB === "undefined") {
    return Promise.resolve(null);
  }
  if (!key) return Promise.resolve();
  return set(key, JSON.stringify(data));
}
function getLocal(key) {
  if (typeof indexedDB === "undefined") {
    return Promise.resolve(null);
  }
  return get(key).then((val) => val ? JSON.parse(val) : val);
}
let cached = {};
function createResource(options, vm) {
  let cacheKey = null;
  if (options.cache) {
    cacheKey = getCacheKey(options.cache);
    let cachedResource = cached[cacheKey];
    if (cachedResource) {
      if (cachedResource.auto) {
        cachedResource.reload();
      }
      return cachedResource;
    }
  }
  if (typeof options == "string") {
    options = {
      url: options,
      auto: true
    };
  }
  let fetchFunction = options.debounce ? debounce(fetch2, options.debounce) : fetch2;
  let out = reactive({
    method: options.method,
    url: options.url,
    data: options.initialData || null,
    previousData: null,
    loading: false,
    fetched: false,
    error: null,
    promise: null,
    auto: options.auto,
    params: null,
    fetch: fetchFunction,
    reload: fetchFunction,
    submit: fetchFunction,
    reset,
    update,
    setData
  });
  async function fetch2(params, tempOptions = {}) {
    let resourceFetcher = options.resourceFetcher || getConfig("resourceFetcher") || request;
    if (params instanceof Event) {
      params = null;
    }
    params = params || out.params;
    if (options.makeParams) {
      params = options.makeParams.call(vm, params);
    }
    out.params = params;
    out.previousData = out.data ? JSON.parse(JSON.stringify(out.data)) : null;
    out.loading = true;
    out.error = null;
    if (options.onFetch) {
      options.onFetch.call(vm, out.params);
    }
    let beforeSubmitFunctions = [options.beforeSubmit, tempOptions.beforeSubmit];
    for (let fn of beforeSubmitFunctions) {
      if (fn) {
        fn.call(vm, out.params);
      }
    }
    let validateFunction = tempOptions.validate || options.validate;
    let errorFunctions = [options.onError, tempOptions.onError];
    let successFunctions = [options.onSuccess, tempOptions.onSuccess];
    let dataFunctions = [options.onData, tempOptions.onData];
    if (validateFunction) {
      let invalidMessage;
      try {
        invalidMessage = await validateFunction.call(vm, out.params);
        if (invalidMessage && typeof invalidMessage == "string") {
          throw new Error(invalidMessage);
        }
      } catch (error) {
        handleError(error, errorFunctions);
        return;
      }
    }
    try {
      out.promise = resourceFetcher({
        ...options,
        params: params || options.params
      });
      let data = await out.promise;
      saveLocal(cacheKey, data);
      out.data = transform(data);
      out.fetched = true;
      for (let fn of successFunctions) {
        if (fn) {
          fn.call(vm, data);
        }
      }
      for (let fn of dataFunctions) {
        if (fn) {
          fn.call(vm, data);
        }
      }
    } catch (error) {
      handleError(error, errorFunctions);
    }
    out.loading = false;
    return out.data;
  }
  function update({ method, url, params, auto }) {
    if (method && method !== options.method) {
      out.method = method;
    }
    if (url && url !== options.url) {
      out.url = url;
    }
    if (params && params !== options.params) {
      out.params = params;
    }
    if (auto !== void 0 && auto !== out.auto) {
      out.auto = auto;
    }
  }
  function reset() {
    out.data = options.initialData || null;
    out.previousData = null;
    out.loading = false;
    out.fetched = false;
    out.error = null;
    out.params = null;
    out.auto = options.auto;
  }
  function handleError(error, errorFunctions) {
    out.loading = false;
    if (out.previousData) {
      out.data = out.previousData;
    }
    out.error = error;
    for (let fn of errorFunctions) {
      if (fn) {
        fn.call(vm, error);
      }
    }
    if (errorFunctions.every((fn) => fn == null)) {
      let errorHandler = getConfig("fallbackErrorHandler");
      if (errorHandler) {
        try {
          errorHandler(error);
        } catch (error2) {
          console.warn("Error in fallbackErrorHandler", error2);
        }
      }
    }
    throw error;
  }
  function setData(data) {
    if (typeof data === "function") {
      data = data.call(vm, out.data);
    }
    out.data = transform(data);
  }
  function transform(data) {
    if (options.transform) {
      let returnValue = options.transform.call(vm, data);
      if (returnValue != null) {
        return returnValue;
      }
    }
    return data;
  }
  if (cacheKey && !cached[cacheKey]) {
    cached[cacheKey] = out;
    getLocal(cacheKey).then((data) => {
      var _a;
      if ((out.loading || !out.fetched) && data) {
        setData(data);
        (_a = options.onData) == null ? void 0 : _a.call(vm, data);
      }
    });
  }
  if (options.auto) {
    out.fetch();
  }
  return out;
}
function getCacheKey(cacheKey) {
  if (!cacheKey) {
    return null;
  }
  if (typeof cacheKey === "string") {
    cacheKey = [cacheKey];
  }
  return JSON.stringify(cacheKey);
}
function onDocUpdate(socket, doctype, callback) {
  subscribe(socket, doctype);
  socket.on("list_update", (data) => {
    if (data.doctype == doctype) {
      callback(data.name);
    }
  });
}
let subscribed = {};
function subscribe(socket, doctype) {
  if (subscribed[doctype]) return;
  socket.emit("doctype_subscribe", doctype);
  subscribed[doctype] = true;
}
let listCache = reactive({});
let resourcesByDocType = {};
function createListResource(options, vm) {
  var _a, _b, _c, _d, _e;
  if (!options.doctype) {
    throw new Error("List resource requires doctype");
  }
  let cacheKey = getCacheKey(options.cache);
  if (cacheKey) {
    let cachedResource = listCache[cacheKey];
    if (cachedResource) {
      if (cachedResource.auto) {
        cachedResource.reload();
      }
      return cachedResource;
    }
  }
  let defaultListUrl = getConfig("defaultListUrl") || "frappe.client.get_list";
  let defaultDocInsertUrl = getConfig("defaultDocInsertUrl") || "frappe.client.insert";
  let defaultDocUpdateUrl = getConfig("defaultDocUpdateUrl") || "frappe.client.set_value";
  let defaultDocDeleteUrl = getConfig("defaultDocDeleteUrl") || "frappe.client.delete";
  let defaultRunDocMethodUrl = getConfig("defaultRunDocMethodUrl") || "run_doc_method";
  let out = reactive({
    doctype: options.doctype,
    fields: options.fields,
    filters: options.filters,
    orFilters: options.orFilters,
    orderBy: options.orderBy,
    start: options.start || 0,
    pageLength: options.pageLength || 20,
    groupBy: options.groupBy,
    parent: options.parent,
    debug: options.debug || 0,
    originalData: null,
    dataMap: {},
    data: null,
    previous,
    hasPreviousPage: false,
    next,
    hasNextPage: true,
    auto: options.auto,
    list: createResource(
      {
        url: options.url || defaultListUrl,
        makeParams() {
          return {
            doctype: out.doctype,
            fields: out.fields,
            filters: out.filters,
            or_filters: out.orFilters,
            order_by: out.orderBy,
            start: out.start,
            limit: out.pageLength,
            limit_start: out.start,
            limit_page_length: out.pageLength,
            group_by: out.groupBy,
            parent: out.parent,
            debug: out.debug
          };
        },
        onSuccess(data) {
          var _a2;
          out.hasPreviousPage = !!out.start;
          out.hasNextPage = data.length < out.pageLength ? false : true;
          let pagedData;
          if (!out.start || out.start == 0) {
            pagedData = data;
          } else if (out.start > 0) {
            pagedData = out.originalData.concat(data);
          }
          saveLocal(cacheKey, pagedData);
          setData(pagedData);
          (_a2 = options.onSuccess) == null ? void 0 : _a2.call(vm, out.data);
        },
        onError: options.onError
      },
      vm
    ),
    fetchOne: createResource(
      {
        url: options.url || defaultListUrl,
        makeParams(name) {
          return {
            doctype: out.doctype,
            fields: out.fields || "*",
            filters: { name }
          };
        },
        onSuccess(data) {
          var _a2, _b2;
          if (data.length > 0 && out.originalData) {
            let doc = data[0];
            updateRowInListResource(out.doctype, doc);
          }
          (_b2 = (_a2 = options.fetchOne) == null ? void 0 : _a2.onSuccess) == null ? void 0 : _b2.call(vm, out.data);
        },
        onError: (_a = options.fetchOne) == null ? void 0 : _a.onError
      },
      vm
    ),
    insert: createResource(
      {
        url: defaultDocInsertUrl,
        makeParams(values) {
          return {
            doc: {
              doctype: out.doctype,
              ...values
            }
          };
        },
        onSuccess(data) {
          var _a2, _b2;
          out.list.fetch();
          (_b2 = (_a2 = options.insert) == null ? void 0 : _a2.onSuccess) == null ? void 0 : _b2.call(vm, data);
        },
        onError: (_b = options.insert) == null ? void 0 : _b.onError
      },
      vm
    ),
    setValue: createResource(
      {
        url: defaultDocUpdateUrl,
        makeParams(options2) {
          let { name, ...values } = options2;
          return {
            doctype: out.doctype,
            name,
            fieldname: values
          };
        },
        onSuccess(doc) {
          var _a2, _b2;
          updateRowInListResource(out.doctype, doc);
          (_b2 = (_a2 = options.setValue) == null ? void 0 : _a2.onSuccess) == null ? void 0 : _b2.call(vm, doc);
        },
        onError: (_c = options.setValue) == null ? void 0 : _c.onError
      },
      vm
    ),
    delete: createResource(
      {
        url: defaultDocDeleteUrl,
        makeParams(name) {
          return {
            doctype: out.doctype,
            name
          };
        },
        onSuccess(data) {
          var _a2, _b2;
          out.list.fetch();
          (_b2 = (_a2 = options.delete) == null ? void 0 : _a2.onSuccess) == null ? void 0 : _b2.call(vm, data);
        },
        onError: (_d = options.delete) == null ? void 0 : _d.onError
      },
      vm
    ),
    runDocMethod: createResource(
      {
        url: defaultRunDocMethodUrl,
        makeParams({ method, name, ...values }) {
          return {
            dt: out.doctype,
            dn: name,
            method,
            args: values
          };
        },
        onSuccess(data) {
          var _a2, _b2;
          if (data.docs) {
            for (let doc of data.docs) {
              updateRowInListResource(doc.doctype, doc);
            }
          }
          (_b2 = (_a2 = options.runDocMethod) == null ? void 0 : _a2.onSuccess) == null ? void 0 : _b2.call(vm, data);
        },
        onError: (_e = options.runDocMethod) == null ? void 0 : _e.onError
      },
      vm
    ),
    update,
    fetch: fetch2,
    reload,
    setData,
    transform,
    getRow
  });
  function update(updatedOptions) {
    Object.assign(out, updatedOptions);
  }
  function transform(data) {
    if (options.transform) {
      let returnValue = options.transform.call(vm, data);
      if (returnValue != null) {
        return returnValue;
      }
    }
    return data;
  }
  function reload() {
    let _start = out.start;
    let _pageLength = out.pageLength;
    if (out.start > 0) {
      out.start = 0;
      out.pageLength = out.originalData.length;
    }
    return out.list.fetch().finally(() => {
      out.start = _start;
      out.pageLength = _pageLength;
    });
  }
  function fetch2() {
    reload();
  }
  function setData(data) {
    out.originalData = data;
    if (typeof data === "function") {
      data = data.call(vm, out.data);
    }
    out.data = transform(data);
    if (Array.isArray(out.data)) {
      out.dataMap = {};
      for (let row of out.data) {
        if (!row.name) continue;
        let key = row.name.toString();
        out.dataMap[key] = row;
      }
    }
  }
  function previous() {
    out.start = out.start - out.pageLength;
    out.list.fetch();
  }
  function next() {
    out.start = out.start + out.pageLength;
    out.list.fetch();
  }
  function getRow(name) {
    let key = name.toString();
    return out.dataMap[key];
  }
  if (options.realtime && (vm == null ? void 0 : vm.$socket)) {
    onDocUpdate(vm.$socket, out.doctype, (name) => {
      var _a2;
      if ((_a2 = out.originalData) == null ? void 0 : _a2.find((d) => d.name === name)) {
        out.fetchOne.submit(name);
      }
    });
  }
  if (cacheKey) {
    listCache[cacheKey] = out;
    getLocal(cacheKey).then((data) => {
      var _a2;
      if ((out.list.loading || !out.list.fetched) && data) {
        setData(data);
        (_a2 = options.onData) == null ? void 0 : _a2.call(vm, data);
      }
    });
  }
  if (options.auto) {
    out.list.fetch();
  }
  resourcesByDocType[out.doctype] = resourcesByDocType[out.doctype] || [];
  resourcesByDocType[out.doctype].push(out);
  return out;
}
function updateRowInListResource(doctype, doc) {
  if (!doc.name) return;
  let resources = resourcesByDocType[doctype] || [];
  for (let resource of resources) {
    if (resource.originalData) {
      for (let row of resource.originalData) {
        if (row.name && row.name == doc.name) {
          delete row._previousData;
          let previousRowData = JSON.stringify(row);
          for (let key in row) {
            if (key in doc) {
              row[key] = doc[key];
            }
          }
          row._previousData = previousRowData;
        }
      }
      resource.data = resource.transform(resource.originalData);
    }
  }
}
reactive({});
class IDBStore {
  constructor() {
    __publicField(this, "memoryStore", {});
    __publicField(this, "useIndexedDB");
    this.useIndexedDB = typeof window !== "undefined" && !!window.indexedDB;
  }
  set(key, data) {
    if (!this.validateKey(key)) {
      return Promise.resolve(null);
    }
    try {
      if (this.useIndexedDB) {
        return set(key, JSON.stringify(data));
      }
      this.memoryStore[key] = JSON.stringify(data);
      return Promise.resolve();
    } catch (error) {
      return this.handleError(error, "save to");
    }
  }
  setMany(data) {
    try {
      if (this.useIndexedDB) {
        let entries = [];
        for (const [key, value] of Object.entries(data)) {
          entries.push([key, JSON.stringify(value)]);
        }
        return setMany(entries);
      }
      for (const [key, value] of Object.entries(data)) {
        this.memoryStore[key] = JSON.stringify(value);
      }
      return Promise.resolve();
    } catch (error) {
      return this.handleError(error, "save to");
    }
  }
  delete(key) {
    if (!this.validateKey(key)) {
      return Promise.resolve(null);
    }
    try {
      if (this.useIndexedDB) {
        return del(key);
      }
      delete this.memoryStore[key];
      return Promise.resolve();
    } catch (error) {
      return this.handleError(error, "delete from");
    }
  }
  get(key) {
    if (!this.validateKey(key)) {
      return Promise.resolve(null);
    }
    if (this.useIndexedDB) {
      return get(key).then((val) => {
        if (!val) return null;
        try {
          return JSON.parse(val);
        } catch (error) {
          return this.handleError(error, "parse data from");
        }
      });
    }
    try {
      const val = this.memoryStore[key];
      return Promise.resolve(val ? JSON.parse(val) : null);
    } catch (error) {
      return this.handleError(error, "parse data from");
    }
  }
  async keys() {
    try {
      if (this.useIndexedDB) {
        return keys();
      }
      return Promise.resolve(Object.keys(this.memoryStore));
    } catch (error) {
      console.error(
        `Failed to get keys from ${this.useIndexedDB ? "IndexedDB" : "memory store"}:`,
        error
      );
      return Promise.resolve([]);
    }
  }
  validateKey(key) {
    return !!key;
  }
  handleError(error, operation) {
    console.error(
      `Failed to ${operation} ${this.useIndexedDB ? "IndexedDB" : "memory store"}:`,
      error
    );
    return Promise.resolve(null);
  }
}
let idbStore = new IDBStore();
class DocStore {
  constructor() {
    __publicField(this, "docs");
    __publicField(this, "lastFetched");
    __publicField(this, "cacheTimeout", 5 * 60 * 1e3);
    // 5 minutes
    __publicField(this, "storePrefix", "doc:");
    this.docs = /* @__PURE__ */ new Map();
    this.lastFetched = /* @__PURE__ */ new Map();
  }
  setCacheTimeout(minutes) {
    if (minutes < 1) {
      throw new Error("Cache timeout must be at least 1 minute");
    }
    this.cacheTimeout = minutes * 60 * 1e3;
  }
  async setDoc(doc) {
    if (!(doc == null ? void 0 : doc.doctype) || !(doc == null ? void 0 : doc.name)) {
      throw new Error("Invalid doc: must have doctype and name");
    }
    doc.name = doc.name.toString();
    const key = this.getKey(doc.doctype, doc.name);
    try {
      await idbStore.set(this.storePrefix + key, doc);
      if (!this.docs.has(key)) {
        this.docs.set(key, ref(null));
      }
      const docRef = this.docs.get(key);
      if (docRef) {
        docRef.value = doc;
      }
      this.lastFetched.set(key, Date.now());
    } catch (error) {
      console.error("Failed to set doc in IDB:", error);
      throw error;
    }
  }
  getDoc(doctype, name) {
    const nameStr = toValue(name);
    if (!doctype || !nameStr) {
      throw new Error("doctype and name are required");
    }
    const key = this.getKey(doctype, nameStr);
    if (!this.docs.has(key)) {
      this.docs.set(key, ref(null));
      this.loadDoc(key, true);
    } else if (this.isStale(key)) {
      this.loadDoc(key, false);
    }
    return this.docs.get(key);
  }
  async loadDoc(key, isFirstLoad) {
    try {
      if (!isFirstLoad && this.isStale(key)) {
        await this.cleanup(key);
      }
      const idbDoc = await idbStore.get(this.storePrefix + key);
      if (idbDoc) {
        const docRef = this.docs.get(key);
        if (docRef) {
          docRef.value = idbDoc;
        }
        this.lastFetched.set(key, Date.now());
      }
    } catch (error) {
      console.error("Failed to load doc from IDB:", error);
      throw error;
    }
  }
  async setDocs(docs) {
    const docMap = {};
    for (const doc of docs) {
      if (!(doc == null ? void 0 : doc.doctype) || !(doc == null ? void 0 : doc.name)) continue;
      doc.name = doc.name.toString();
      const key = this.getKey(doc.doctype, doc.name);
      if (!this.docs.has(key)) {
        this.docs.set(key, ref(null));
      }
      const docRef = this.docs.get(key);
      if (docRef) {
        docRef.value = doc;
      }
      this.lastFetched.set(key, Date.now());
      docMap[this.storePrefix + key] = doc;
    }
    await idbStore.setMany(docMap);
  }
  async invalidateDoc(doctype, name) {
    if (!doctype || !name) return;
    const key = this.getKey(doctype, name);
    await this.cleanup(key);
  }
  removeDoc(doctype, name) {
    return this.invalidateDoc(doctype, name);
  }
  getKey(doctype, name) {
    return `${doctype.trim()}/${name.trim()}`;
  }
  isStale(key) {
    const fetchTime = this.lastFetched.get(key);
    if (!fetchTime) return true;
    return Date.now() - fetchTime > this.cacheTimeout;
  }
  async cleanup(key) {
    this.docs.delete(key);
    this.lastFetched.delete(key);
    await idbStore.delete(this.storePrefix + key);
  }
  async clearAll() {
    try {
      const allKeys = await idbStore.keys();
      const docKeys = allKeys.filter(
        (key) => key.startsWith(this.storePrefix)
      );
      await Promise.all(docKeys.map((key) => idbStore.delete(key)));
      this.docs.clear();
      this.lastFetched.clear();
    } catch (error) {
      console.error("Failed to clear all docs:", error);
      throw error;
    }
  }
}
const docStore = new DocStore();
class ListStore {
  constructor() {
    __publicField(this, "byDocType");
    this.byDocType = {};
  }
  addList(doctype, list) {
    this.ensureList(doctype);
    this.byDocType[doctype].push(list);
  }
  updateRows(docs) {
    for (let doc of docs) {
      this.updateRow(doc.doctype, doc);
    }
  }
  updateRow(doctype, doc) {
    this.ensureList(doctype);
    this.byDocType[doctype].forEach((list) => {
      list.updateRow(doc);
    });
  }
  removeRow(doctype, name) {
    this.ensureList(doctype);
    this.byDocType[doctype].forEach((list) => {
      list.removeRow(name);
    });
  }
  ensureList(docType) {
    if (!this.byDocType[docType]) {
      this.byDocType[docType] = [];
    }
  }
}
const listStore = new ListStore();
class FrappeResponseError extends Error {
  constructor(message, options) {
    super(message);
    __publicField(this, "title");
    __publicField(this, "type");
    __publicField(this, "exception");
    __publicField(this, "indicator");
    this.name = "FrappeResponseError";
    this.title = options.title;
    this.type = options.type;
    this.exception = options.exception;
    this.indicator = options.indicator;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, FrappeResponseError);
    }
  }
}
createFetch({
  options: {
    fetch: (...args) => fetch(...args),
    // required for vitest
    beforeFetch({ options }) {
      options.headers = setHeaders(options.headers || {});
      return { options };
    },
    afterFetch(ctx) {
      let responseData = JSON.parse(ctx.data);
      ctx.data = responseData;
      if (responseData.debug) {
        let path = ctx.response.url.replace(window.location.origin, "");
        console.group(path);
        for (let d of responseData.debug) {
          console.log(d == null ? void 0 : d.message);
        }
        console.groupEnd();
      }
      if (responseData.docs) {
        let docs = responseData.docs;
        for (let doc of docs) {
          doc.name = doc.name.toString();
        }
        docStore.setDocs(docs);
        listStore.updateRows(docs);
      }
      return ctx;
    },
    onFetchError(ctx) {
      var _a;
      if (((_a = ctx.response) == null ? void 0 : _a.ok) && ctx.error) {
        console.error(
          "Fetch request succeeded but there was a programming error:\n\n",
          ctx.error
        );
        return ctx;
      }
      try {
        let errorResponse = JSON.parse(ctx.data);
        let errors = errorResponse.errors;
        let error = errors[0];
        let errorDescription = error.message ? `: ${error.message}` : error.exception ? ` (Traceback)` : "";
        let frappeError = new FrappeResponseError(
          `${error.type}${errorDescription}`,
          {
            title: error.title,
            type: error.type,
            exception: error.exception,
            indicator: error.indicator
          }
        );
        if (error.exception) {
          console.log(error.exception);
        }
        ctx.error = frappeError;
        return ctx;
      } catch (e) {
        console.log("Error parsing error response:", e);
        return ctx;
      }
    }
  }
});
function setHeaders(headers) {
  let siteName = null;
  let csrfToken = null;
  if (typeof window !== "undefined") {
    siteName = window.location.hostname;
    csrfToken = window.csrf_token !== "{{ csrf_token }}" ? window.csrf_token : null;
  }
  const defaultHeaders = {
    Accept: "application/json",
    "Content-Type": "application/json; charset=utf-8"
  };
  if (siteName) {
    defaultHeaders["X-Frappe-Site-Name"] = siteName;
  }
  if (csrfToken) {
    defaultHeaders["X-Frappe-CSRF-Token"] = csrfToken;
  }
  return { ...headers, ...defaultHeaders };
}
const _sfc_main$1 = {
  __name: "ListRowItem",
  props: {
    column: {
      type: Object,
      default: {}
    },
    row: {
      type: Object,
      default: {}
    },
    item: {
      type: [String, Number, Object],
      default: ""
    },
    align: {
      type: String,
      default: "left"
    }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const props = __props;
    const label = computed(() => {
      var _a, _b;
      if ((_a = props.column) == null ? void 0 : _a.getLabel) return (_b = props.column) == null ? void 0 : _b.getLabel({ row: props.row });
      return getValue(props.item).label || "";
    });
    const tooltip = computed(() => {
      if (!list.value.options.showTooltip) return "";
      return props.column.getTooltip ? props.column.getTooltip(props.row) : getValue(props.item).label;
    });
    function getValue(value) {
      if (value && typeof value === "object") {
        return value;
      }
      return { label: value };
    }
    const list = inject("list");
    const __returned__ = { props, label, tooltip, getValue, list, computed, inject, get Tooltip() {
      return __unplugin_components_0$2;
    }, get alignmentMap() {
      return alignmentMap;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
};
const _hoisted_1 = { class: "truncate text-base" };
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(
    "div",
    {
      class: normalizeClass(["flex items-center space-x-2", $setup.alignmentMap[$props.align]])
    },
    [
      renderSlot(_ctx.$slots, "prefix", {}, () => [
        $props.column.prefix ? (openBlock(), createBlock(resolveDynamicComponent(
          typeof $props.column.prefix === "function" ? $props.column.prefix({ row: $props.row }) : $props.column.prefix
        ), { key: 0 })) : createCommentVNode("v-if", true)
      ]),
      createVNode(
        $setup["Tooltip"],
        normalizeProps(guardReactiveProps(
          $setup.list.options.showTooltip ? {
            text: $setup.tooltip
          } : { text: "" }
        )),
        {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({ label: $setup.label })), () => [
              createBaseVNode(
                "div",
                _hoisted_1,
                toDisplayString($setup.label),
                1
                /* TEXT */
              )
            ])
          ]),
          _: 3
          /* FORWARDED */
        },
        16
        /* FULL_PROPS */
      ),
      renderSlot(_ctx.$slots, "suffix")
    ],
    2
    /* CLASS */
  );
}
_sfc_main$1.__file = "src/components/ListView/ListRowItem.vue";
const ListRowItem = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/ListView/ListRowItem.vue"]]);
const _sfc_main = {
  __name: "ListRow",
  props: {
    row: {
      type: Object,
      required: true
    }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const props = __props;
    const list = inject("list");
    const isLastRow = computed(() => {
      var _a;
      if (!((_a = list.value.rows) == null ? void 0 : _a.length)) return false;
      return list.value.rows[list.value.rows.length - 1][list.value.rowKey] === props.row[list.value.rowKey];
    });
    const isSelected = computed(() => {
      return list.value.selections.has(props.row[list.value.rowKey]);
    });
    const isActive = computed(
      () => list.value.options.enableActive && list.value.activeRow.value === props.row.name
    );
    const isHoverable = computed(() => {
      return list.value.options.getRowRoute || list.value.options.onRowClick;
    });
    const rowHeight = computed(() => {
      if (typeof list.value.options.rowHeight === "number") {
        return `${list.value.options.rowHeight}px`;
      }
      return list.value.options.rowHeight;
    });
    const roundedClass = computed(() => {
      var _a, _b, _c;
      if (!isSelected.value) return "rounded";
      const selections = [...list.value.selections];
      let groups = ((_a = list.value.rows[0]) == null ? void 0 : _a.group) ? list.value.rows.map((k) => k.rows) : [list.value.rows];
      for (let rows of groups) {
        let currentIndex = rows.findIndex((k) => k == props.row);
        if (currentIndex === -1) continue;
        let atBottom = !selections.includes((_b = rows[currentIndex + 1]) == null ? void 0 : _b.name);
        let atTop = !selections.includes((_c = rows[currentIndex - 1]) == null ? void 0 : _c.name);
        return (atBottom ? "rounded-b " : "") + (atTop ? "rounded-t" : "");
      }
    });
    const onRowClick = (row, e) => {
      if (list.value.options.onRowClick) list.value.options.onRowClick(row, e);
      if (list.value.activeRow.value === row.name) {
        list.value.activeRow.value = null;
      } else {
        list.value.activeRow.value = row.name;
      }
    };
    const __returned__ = { props, list, isLastRow, isSelected, isActive, isHoverable, rowHeight, roundedClass, onRowClick, Checkbox, ListRowItem, get alignmentMap() {
      return alignmentMap;
    }, get getGridTemplateColumns() {
      return getGridTemplateColumns;
    }, computed, inject, ref };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent($setup.list.options.getRowRoute ? "router-link" : "div"), mergeProps({
    class: [[
      $setup.roundedClass,
      $setup.isSelected || $setup.isActive ? "bg-surface-gray-2" : "",
      $setup.isHoverable ? "cursor-pointer" : "",
      $setup.isHoverable ? $setup.isSelected || $setup.isActive ? "hover:bg-surface-gray-3" : "hover:bg-surface-menu-bar" : ""
    ], "flex flex-col transition-all duration-300 ease-in-out"]
  }, {
    to: $setup.list.options.getRowRoute ? $setup.list.options.getRowRoute($props.row) : void 0,
    onClick: (e) => $setup.onRowClick($props.row, e)
  }), {
    default: withCtx(() => [
      (openBlock(), createBlock(resolveDynamicComponent($setup.list.options.getRowRoute ? "template" : "button"), { class: "[all:unset] hover:[all:unset]" }, {
        default: withCtx(() => {
          var _a, _b;
          return [
            createBaseVNode(
              "div",
              {
                class: "grid items-center space-x-4 px-2",
                style: normalizeStyle({
                  height: $setup.rowHeight,
                  gridTemplateColumns: $setup.getGridTemplateColumns(
                    $setup.list.columns,
                    $setup.list.options.selectable
                  )
                })
              },
              [
                $setup.list.options.selectable ? (openBlock(), createElementBlock(
                  "div",
                  {
                    key: 0,
                    class: "w-fit pr-2 py-3 flex",
                    onClick: _cache[1] || (_cache[1] = withModifiers(() => {
                    }, ["stop", "prevent"])),
                    onDblclick: _cache[2] || (_cache[2] = withModifiers(() => {
                    }, ["stop"]))
                  },
                  [
                    createVNode($setup["Checkbox"], {
                      modelValue: $setup.isSelected,
                      class: "cursor-pointer duration-300",
                      onClick: _cache[0] || (_cache[0] = withModifiers(($event) => $setup.list.toggleRow($props.row[$setup.list.rowKey]), ["stop"]))
                    }, null, 8, ["modelValue"])
                  ],
                  32
                  /* NEED_HYDRATION */
                )) : createCommentVNode("v-if", true),
                (openBlock(true), createElementBlock(
                  Fragment,
                  null,
                  renderList($setup.list.columns, (column, i) => {
                    return openBlock(), createElementBlock(
                      "div",
                      {
                        key: column.key,
                        class: normalizeClass([
                          $setup.alignmentMap[column.align],
                          i == 0 ? "text-ink-gray-9" : "text-ink-gray-7"
                        ])
                      },
                      [
                        renderSlot(_ctx.$slots, "default", mergeProps({ ref_for: true }, { idx: i, column, item: $props.row[column.key], isActive: $setup.isActive }), () => [
                          $setup.list.slots.cell ? (openBlock(), createBlock(
                            resolveDynamicComponent($setup.list.slots.cell),
                            mergeProps({
                              key: 0,
                              ref_for: true
                            }, {
                              column,
                              row: $props.row,
                              item: $props.row[column.key],
                              align: column.align
                            }),
                            null,
                            16
                            /* FULL_PROPS */
                          )) : (openBlock(), createBlock($setup["ListRowItem"], {
                            key: 1,
                            column,
                            row: $props.row,
                            item: $props.row[column.key],
                            align: column.align
                          }, null, 8, ["column", "row", "item", "align"]))
                        ])
                      ],
                      2
                      /* CLASS */
                    );
                  }),
                  128
                  /* KEYED_FRAGMENT */
                ))
              ],
              4
              /* STYLE */
            ),
            !$setup.isLastRow ? (openBlock(), createElementBlock(
              "div",
              {
                key: 0,
                class: normalizeClass([
                  "h-px border-t",
                  $setup.roundedClass === "rounded" || ((_b = (_a = $setup.roundedClass) == null ? void 0 : _a.includes) == null ? void 0 : _b.call(_a, "rounded-b")) ? "mx-2 border-outline-gray-1" : "border-t-[--surface-gray-2]"
                ])
              },
              null,
              2
              /* CLASS */
            )) : createCommentVNode("v-if", true)
          ];
        }),
        _: 3
        /* FORWARDED */
      }))
    ]),
    _: 3
    /* FORWARDED */
  }, 16, ["class"]);
}
_sfc_main.__file = "src/components/ListView/ListRow.vue";
const ListRow = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__file", "/home/runner/work/frappe-ui/frappe-ui/src/components/ListView/ListRow.vue"]]);
export {
  ALLOWED_DOMAINS as A,
  ImageGroupUploadDialog as I,
  ListHeader as L,
  TextEditor as T,
  ListHeaderItem as a,
  ListRow as b,
  ListRowItem as c,
  ListRows as d,
  ListSelectBanner as e,
  ListView as f,
  TextEditorFixedMenu as g,
  detectPlatform as h,
  calculateAspectRatio as i,
  getOptimalDimensions as j,
  processURL as p,
  validateURL as v
};
